//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { APIClientBase } from './APIClientBase';
import * as jQuery from 'jquery';

export class DocumentToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Updates the comments on the specified document
     * @param id Document Key
     * @param updatedData Replacement comment data
     * @return Specified comments not found
     */
    updateDocComments(id: string, updatedData: Comment) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocCommentsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocCommentsWithCallbacks(id: string, updatedData: Comment, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocComments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocComments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts Comments on the specified document
     * @param id Document Key
     * @param newData New comment data
     */
    addDocComments(id: string, newData: Comment) {
        return new Promise<Comment | null>((resolve, reject) => {
            this.addDocCommentsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocCommentsWithCallbacks(id: string, newData: Comment, onSuccess?: (result: Comment | null) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocComments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocComments(xhr: any): Comment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not accessible", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the comments for the specified document
     * @param id Document Key
     */
    getDocComments(id: string) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getDocCommentsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocCommentsWithCallbacks(id: string, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocComments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocComments(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the item comments for the specified document
     * @param id Document Key
     * @param itemId Item Key
     */
    getDocItemComments(id: string, itemId: string) {
        return new Promise<DocItemComment[] | null>((resolve, reject) => {
            this.getDocItemCommentsWithCallbacks(id, itemId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemCommentsWithCallbacks(id: string, itemId: string, onSuccess?: (result: DocItemComment[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Item/{itemId}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocItemComments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItemComments(xhr: any): DocItemComment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not accessible", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocItemComment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of tabs
     * @param id Document Key
     */
    getDocTabs(id: string) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getDocTabsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocTabsWithCallbacks(id: string, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/tabs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocTabs(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Runs the ATC scripts; no automatic save is implied (the script can save)
     * @param id Document Key
     * @param scriptName Name of Script
     */
    runDocWorkflow(id: string, scriptName: string | null) {
        return new Promise<string | null>((resolve, reject) => {
            this.runDocWorkflowWithCallbacks(id, scriptName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private runDocWorkflowWithCallbacks(id: string, scriptName: string | null, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/workflow/{scriptName}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (scriptName === undefined || scriptName === null)
            throw new Error("The parameter 'scriptName' must be defined.");
        url_ = url_.replace("{scriptName}", encodeURIComponent("" + scriptName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processRunDocWorkflowWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRunDocWorkflowWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processRunDocWorkflowWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processRunDocWorkflow(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processRunDocWorkflow(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the ATC Workflow log for the current document session
     * @param id Document Key
     */
    getDocWorkflowLog(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocWorkflowLogWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocWorkflowLogWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/workflow/log";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocWorkflowLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocWorkflowLog(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocWorkflowLog(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns one or all Access Control entries for the current document session
     * @param id Document Key
     * @param type (optional) Access Type (eg DocOwner)
     */
    getDocAccessControl(id: string, type?: string | null | undefined) {
        return new Promise<DocAccessControl[] | null>((resolve, reject) => {
            this.getDocAccessControlWithCallbacks(id, type, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAccessControlWithCallbacks(id: string, type: string | null | undefined, onSuccess?: (result: DocAccessControl[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/access?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAccessControlWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAccessControlWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAccessControlWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocAccessControl(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAccessControl(xhr: any): DocAccessControl[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAccessControl.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the Document Session Key
     * @param id Document Key
     * @param freshenData (optional) Reloads document when true
     */
    getDocSession(id: string, freshenData?: boolean | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocSessionWithCallbacks(id, freshenData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocSessionWithCallbacks(id: string, freshenData: boolean | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (freshenData === null)
            throw new Error("The parameter 'freshenData' cannot be null.");
        else if (freshenData !== undefined)
            url_ += "freshenData=" + encodeURIComponent("" + freshenData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocSession(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends the Document Session
     * @param id Document Key
     * @param sessionID cache key or session
     */
    endDocSession(id: string, sessionID: string | null) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.endDocSessionWithCallbacks(id, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private endDocSessionWithCallbacks(id: string, sessionID: string | null, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sessionID === undefined)
            throw new Error("The parameter 'sessionID' must be defined.");
        else if(sessionID !== null)
            url_ += "sessionID=" + encodeURIComponent("" + sessionID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processEndDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processEndDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processEndDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processEndDocSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processEndDocSession(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result406);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the current Document state (approved, etc)
     * @param id Document Key
     */
    getDocState(id: string) {
        return new Promise<DocumentState | null>((resolve, reject) => {
            this.getDocStateWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocStateWithCallbacks(id: string, onSuccess?: (result: DocumentState | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session/state";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocStateWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocStateWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocStateWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocState(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocState(xhr: any): DocumentState | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentState.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the specified session exists for the current user, associates the Document and Session Key
     * @param id Document Key
     * @param sessionID session id
     */
    patchDocSession(id: string, sessionID: string | null) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocSessionWithCallbacks(id, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocSessionWithCallbacks(id: string, sessionID: string | null, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session/{sessionID}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocSession(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Session Id required", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Modifies the current exclusivity of this document session
     * @param id Document Key
     * @param requestedMode First letter is enough: Default is Doc Session (aka Automatic; D or A), User Session (U), Released (becomes shared, R or 0), Manual (requires permission, M or number of hours)
     * @param forHours Duration, required for Manual
     */
    patchExclusivity(id: string, requestedMode: string | null, forHours: number) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchExclusivityWithCallbacks(id, requestedMode, forHours, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchExclusivityWithCallbacks(id: string, requestedMode: string | null, forHours: number, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session/exclusivity/{requestedMode}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (requestedMode === undefined || requestedMode === null)
            throw new Error("The parameter 'requestedMode' must be defined.");
        url_ = url_.replace("{requestedMode}", encodeURIComponent("" + requestedMode));
        if (forHours === undefined || forHours === null)
            throw new Error("The parameter 'forHours' must be defined and cannot be null.");
        else
            url_ += "forHours=" + encodeURIComponent("" + forHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchExclusivityWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchExclusivity(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchExclusivity(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 412) {
            const _responseText = xhr.responseText;
            let result412: any = null;
            let resultData412 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result412 = resultData412 !== undefined ? resultData412 : <any>null;
    
            return throwException("Could not obtain requested access", status, _responseText, _headers, result412);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Modifies data in this document session
     * @param id Document Key
     * @param changes collection of changes
     * @param pds (optional) when included specified PDS key
     * @param releaseSession (optional) when included and true releases document
     */
    patchDocData(id: string, changes: DocFieldChange[], pds?: string | null | undefined, releaseSession?: boolean | undefined) {
        return new Promise<{ [key: string]: number; } | null>((resolve, reject) => {
            this.patchDocDataWithCallbacks(id, changes, pds, releaseSession, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocDataWithCallbacks(id: string, changes: DocFieldChange[], pds: string | null | undefined, releaseSession: boolean | undefined, onSuccess?: (result: { [key: string]: number; } | null) => void, onFail?: (exception: string | string | string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session/changes?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pds !== undefined && pds !== null)
            url_ += "pds=" + encodeURIComponent("" + pds) + "&";
        if (releaseSession === null)
            throw new Error("The parameter 'releaseSession' cannot be null.");
        else if (releaseSession !== undefined)
            url_ += "releaseSession=" + encodeURIComponent("" + releaseSession) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changes);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocData(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocData(xhr: any): { [key: string]: number; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request missing required information", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Request inappropriate", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result304 = resultData304 !== undefined ? resultData304 : <any>null;
    
            return throwException("The value has not changed", status, _responseText, _headers, result304);

        } else if (status === 412) {
            const _responseText = xhr.responseText;
            let result412: any = null;
            let resultData412 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result412 = resultData412 !== undefined ? resultData412 : <any>null;
    
            return throwException("Could not obtain requested access", status, _responseText, _headers, result412);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the document Is in an appropriate state, change the document number
     * @param id Document Key
     * @param newNumber New Document Number
     */
    patchDocNumber(id: string, newNumber: string | null) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocNumberWithCallbacks(id, newNumber, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocNumberWithCallbacks(id: string, newNumber: string | null, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/docNo?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newNumber === undefined)
            throw new Error("The parameter 'newNumber' must be defined.");
        else if(newNumber !== null)
            url_ += "newNumber=" + encodeURIComponent("" + newNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocNumberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocNumber(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocNumber(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Request Not acceptable (document status Or state?  already used?)", status, _responseText, _headers, result406);

        } else if (status === 422) {
            const _responseText = xhr.responseText;
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = resultData422 !== undefined ? resultData422 : <any>null;
    
            return throwException("Request Not acceptable, number already used?)", status, _responseText, _headers, result422);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Permission required", status, _responseText, _headers, result401);

        } else if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result304 = resultData304 !== undefined ? resultData304 : <any>null;
    
            return throwException("The document already has the requested number", status, _responseText, _headers, result304);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Failed to persist the change", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Copies the specified document; returns a single guid for one of the created documents
     * @param id Document Key
     * @param destinationProject (optional) optional - target project; if Not specified, same project
     * @param withItems (optional) optional - should items be copied
     * @param withAttachments (optional) optional - should attachments be copied (0=no,1=copy Or .net filter; default Is no
     * @param withRoute (optional) Optional - how route should be handled (0=no,1=copy,Or predefined route name
     * @param withLink (optional) Optional - include link to source
     * @param withDue (optional) Optional - specific New due date, default Is tomorrow
     * @param withCopies (optional) Optional - number of copies, default Is one
     * @param withRecur (optional) Optional - due interval between copies (NA-none;DDaily;WWeekly, see Code Set [Recur])
     */
    postDocFrom(id: string, destinationProject?: string | null | undefined, withItems?: string | null | undefined, withAttachments?: string | null | undefined, withRoute?: string | null | undefined, withLink?: boolean | undefined, withDue?: Date | undefined, withCopies?: number | undefined, withRecur?: string | null | undefined) {
        return new Promise<string[] | null>((resolve, reject) => {
            this.postDocFromWithCallbacks(id, destinationProject, withItems, withAttachments, withRoute, withLink, withDue, withCopies, withRecur, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postDocFromWithCallbacks(id: string, destinationProject: string | null | undefined, withItems: string | null | undefined, withAttachments: string | null | undefined, withRoute: string | null | undefined, withLink: boolean | undefined, withDue: Date | undefined, withCopies: number | undefined, withRecur: string | null | undefined, onSuccess?: (result: string[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/from/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (destinationProject !== undefined && destinationProject !== null)
            url_ += "destinationProject=" + encodeURIComponent("" + destinationProject) + "&";
        if (withItems !== undefined && withItems !== null)
            url_ += "withItems=" + encodeURIComponent("" + withItems) + "&";
        if (withAttachments !== undefined && withAttachments !== null)
            url_ += "withAttachments=" + encodeURIComponent("" + withAttachments) + "&";
        if (withRoute !== undefined && withRoute !== null)
            url_ += "withRoute=" + encodeURIComponent("" + withRoute) + "&";
        if (withLink === null)
            throw new Error("The parameter 'withLink' cannot be null.");
        else if (withLink !== undefined)
            url_ += "withLink=" + encodeURIComponent("" + withLink) + "&";
        if (withDue === null)
            throw new Error("The parameter 'withDue' cannot be null.");
        else if (withDue !== undefined)
            url_ += "withDue=" + encodeURIComponent(withDue ? "" + withDue.toISOString() : "") + "&";
        if (withCopies === null)
            throw new Error("The parameter 'withCopies' cannot be null.");
        else if (withCopies !== undefined)
            url_ += "withCopies=" + encodeURIComponent("" + withCopies) + "&";
        if (withRecur !== undefined && withRecur !== null)
            url_ += "withRecur=" + encodeURIComponent("" + withRecur) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostDocFromWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostDocFromWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostDocFromWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostDocFrom(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostDocFrom(xhr: any): string[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Options cannot be combined as specified", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Failed to persist", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header Of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocHeader(id: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeaderWithCallbacks(id: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocHeader(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the specified document
     * @param id Document Key
     */
    deleteDocHeader(id: string) {
        return new Promise<any>((resolve, reject) => {
            this.deleteDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocHeaderWithCallbacks(id: string, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocHeader(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocHeader(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the delete", status, _responseText, _headers, result409);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the header On the specified document
     * @param id Document Key
     * @param updatedData Replacement data
     */
    updateDocHeader(id: string, updatedData: DocMasterDetail) {
        return new Promise<any>((resolve, reject) => {
            this.updateDocHeaderWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocHeaderWithCallbacks(id: string, updatedData: DocMasterDetail, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocHeader(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocHeader(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document number cannot be changed by this method", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the update", status, _responseText, _headers, result409);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns TSQL script
     * @param id Document Key
     */
    getDocTSQL(id: string) {
        return new Promise<string[] | null>((resolve, reject) => {
            this.getDocTSQLWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocTSQLWithCallbacks(id: string, onSuccess?: (result: string[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/TSQL";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocTSQLWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocTSQLWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocTSQLWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocTSQL(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocTSQL(xhr: any): string[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header Of the specified document revision, including a Document Session Key
     * @param id Document Key
     * @param revKey Revision Key
     */
    getDocHeaderRevision(id: string, revKey: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeaderRevisionWithCallbacks(id, revKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeaderRevisionWithCallbacks(id: string, revKey: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{revKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revKey === undefined || revKey === null)
            throw new Error("The parameter 'revKey' must be defined.");
        url_ = url_.replace("{revKey}", encodeURIComponent("" + revKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeaderRevisionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeaderRevisionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeaderRevisionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocHeaderRevision(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeaderRevision(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates a Single field On the header Of the specified document
     * @param id Document Key
     * @param fieldName Field Name
     * @param newValue Replacement data
     */
    patchDocHeader(id: string, fieldName: string | null, newValue: string) {
        return new Promise<{ [key: string]: number; } | null>((resolve, reject) => {
            this.patchDocHeaderWithCallbacks(id, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocHeaderWithCallbacks(id: string, fieldName: string | null, newValue: string, onSuccess?: (result: { [key: string]: number; } | null) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{fieldName}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocHeader(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocHeader(xhr: any): { [key: string]: number; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document number cannot be changed by this method", status, _responseText, _headers, result406);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified New value Is Not acceptable", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the update", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a New document using the Create Next rules
     * @param id Source Document Key
     */
    createNextDocument(id: string) {
        return new Promise<string>((resolve, reject) => {
            this.createNextDocumentWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createNextDocumentWithCallbacks(id: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/next";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateNextDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateNextDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateNextDocumentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateNextDocument(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateNextDocument(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a New document
     * @param id Document Key (use empty for auto assign)
     * @param typeKey Type
     * @param forProject (optional) Project
     * @param forParent (optional) Parent Doc Key
     * @param forBatch (optional) Batch/Subcontract
     */
    createDocument(id: string, typeKey: string, forProject?: string | null | undefined, forParent?: string | null | undefined, forBatch?: string | null | undefined) {
        return new Promise<string>((resolve, reject) => {
            this.createDocumentWithCallbacks(id, typeKey, forProject, forParent, forBatch, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createDocumentWithCallbacks(id: string, typeKey: string, forProject: string | null | undefined, forParent: string | null | undefined, forBatch: string | null | undefined, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{typeKey}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (typeKey === undefined || typeKey === null)
            throw new Error("The parameter 'typeKey' must be defined.");
        url_ = url_.replace("{typeKey}", encodeURIComponent("" + typeKey));
        if (forProject !== undefined && forProject !== null)
            url_ += "forProject=" + encodeURIComponent("" + forProject) + "&";
        if (forParent !== undefined && forParent !== null)
            url_ += "forParent=" + encodeURIComponent("" + forParent) + "&";
        if (forBatch !== undefined && forBatch !== null)
            url_ += "forBatch=" + encodeURIComponent("" + forBatch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateDocumentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateDocument(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateDocument(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a New revision of the specified document
     * @param id Source Document Key
     */
    createNextRevision(id: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.createNextRevisionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createNextRevisionWithCallbacks(id: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/revision";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateNextRevisionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateNextRevisionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateNextRevisionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateNextRevision(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateNextRevision(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Reverses posting of the specified document
     * @param id Source Document Key
     */
    reversePosting(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.reversePostingWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private reversePostingWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/reversal";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReversePostingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReversePostingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReversePostingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processReversePosting(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReversePosting(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could Not reverse", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the items of the specified document (current revision)
     * @param id Document Key
     */
    getDocItems(id: string) {
        return new Promise<DocItem[] | null>((resolve, reject) => {
            this.getDocItemsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemsWithCallbacks(id: string, onSuccess?: (result: DocItem[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItems(xhr: any): DocItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Failed to persist", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the item on the specified document
     * @param id Document Key
     * @param updatedData Replacement item data
     * @return Specified item not found
     */
    updateDocItems(id: string, updatedData: DocItem) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocItemsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocItemsWithCallbacks(id: string, updatedData: DocItem, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocItems(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts item on the specified document
     * @param id Document Key
     * @param newData New item data
     */
    addDocItems(id: string, newData: DocItem) {
        return new Promise<DocItem | null>((resolve, reject) => {
            this.addDocItemsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocItemsWithCallbacks(id: string, newData: DocItem, onSuccess?: (result: DocItem | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocItems(xhr: any): DocItem | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocItem.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the item on the specified document
     * @param id Document Key
     * @param itemKey Doc Item Key
     * @return Specified addresses not found
     */
    deleteDocItems(id: string, itemKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocItemsWithCallbacks(id, itemKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocItemsWithCallbacks(id: string, itemKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items/{itemKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (itemKey === undefined || itemKey === null)
            throw new Error("The parameter 'itemKey' must be defined.");
        url_ = url_.replace("{itemKey}", encodeURIComponent("" + itemKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocItems(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the item with the specified key
     * @param itemKey Doc Item Key
     * @param crossDocDelete (optional) Even if multiple references?
     * @return Specified item not found
     */
    deleteDocItem(itemKey: string, crossDocDelete?: boolean | undefined) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocItemWithCallbacks(itemKey, crossDocDelete, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocItemWithCallbacks(itemKey: string, crossDocDelete: boolean | undefined, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/Items/{itemKey}?";
        if (itemKey === undefined || itemKey === null)
            throw new Error("The parameter 'itemKey' must be defined.");
        url_ = url_.replace("{itemKey}", encodeURIComponent("" + itemKey));
        if (crossDocDelete === null)
            throw new Error("The parameter 'crossDocDelete' cannot be null.");
        else if (crossDocDelete !== undefined)
            url_ += "crossDocDelete=" + encodeURIComponent("" + crossDocDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocItemWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocItemWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocItemWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocItem(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocItem(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the route on the specified document
     * @param id Document Key
     */
    getDocRoute(id: string) {
        return new Promise<DocRoute[] | null>((resolve, reject) => {
            this.getDocRouteWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocRouteWithCallbacks(id: string, onSuccess?: (result: DocRoute[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocRoute(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocRoute(xhr: any): DocRoute[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Failed to persist", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocRoute.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param updatedRoute Replacement Route
     * @return Specified route not found
     */
    updateDocRoute(id: string, updatedRoute: DocRoute) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocRouteWithCallbacks(id, updatedRoute, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocRouteWithCallbacks(id: string, updatedRoute: DocRoute, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedRoute);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocRoute(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts a route on the specified document
     * @param id Document Key
     * @param newRoute Route (DocRoute object)
     */
    addDocRoute(id: string, newRoute: DocRoute) {
        return new Promise<DocRoute | null>((resolve, reject) => {
            this.addDocRouteWithCallbacks(id, newRoute, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocRouteWithCallbacks(id: string, newRoute: DocRoute, onSuccess?: (result: DocRoute | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newRoute);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocRoute(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocRoute(xhr: any): DocRoute | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocRoute.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the route on the specified document
     * @param id Document Key
     * @param routeKey Route Key
     * @return Specified route not found
     */
    deleteDocRoute(id: string, routeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocRouteWithCallbacks(id, routeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocRouteWithCallbacks(id: string, routeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route/{routeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeKey === undefined || routeKey === null)
            throw new Error("The parameter 'routeKey' must be defined.");
        url_ = url_.replace("{routeKey}", encodeURIComponent("" + routeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocRoute(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param routeKey Route Key
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified route not found
     */
    patchDocRoute(id: string, routeKey: string, fieldName: string | null, newValue: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.patchDocRouteWithCallbacks(id, routeKey, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocRouteWithCallbacks(id: string, routeKey: string, fieldName: string | null, newValue: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route/{routeKey}/{fieldName}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeKey === undefined || routeKey === null)
            throw new Error("The parameter 'routeKey' must be defined.");
        url_ = url_.replace("{routeKey}", encodeURIComponent("" + routeKey));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocRoute(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified field invalid for route", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * scraps the specific route on the specified document
     * @param id Document Key
     * @param routeId Replacement Route
     * @return Specified route not found
     */
    docRouteScrap(id: string, routeId: string) {
        return new Promise<string>((resolve, reject) => {
            this.docRouteScrapWithCallbacks(id, routeId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private docRouteScrapWithCallbacks(id: string, routeId: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/route/scrap?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeId === undefined || routeId === null)
            throw new Error("The parameter 'routeId' must be defined and cannot be null.");
        else
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDocRouteScrapWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDocRouteScrapWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDocRouteScrapWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDocRouteScrap(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDocRouteScrap(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Recalculates the content included for the specific route on the specified document
     * @param id Document Key
     * @param routeId Replacement Route
     * @return Specified route not found
     */
    docRouteResetContent(id: string, routeId: string) {
        return new Promise<string>((resolve, reject) => {
            this.docRouteResetContentWithCallbacks(id, routeId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private docRouteResetContentWithCallbacks(id: string, routeId: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/route/content?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeId === undefined || routeId === null)
            throw new Error("The parameter 'routeId' must be defined and cannot be null.");
        else
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDocRouteResetContentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDocRouteResetContentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDocRouteResetContentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDocRouteResetContent(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDocRouteResetContent(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Asks ATC service to performs any route actions (emails or workflows etc) for the current document route
     * @param id Document Key
     * @return Specified route not found
     */
    docRoutePerformActions(id: string) {
        return new Promise<string>((resolve, reject) => {
            this.docRoutePerformActionsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private docRoutePerformActionsWithCallbacks(id: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/route/perform";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDocRoutePerformActionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDocRoutePerformActionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDocRoutePerformActionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDocRoutePerformActions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDocRoutePerformActions(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the dates for the specified document
     * @param id Document Key
     */
    getDocDates(id: string) {
        return new Promise<DocDate[] | null>((resolve, reject) => {
            this.getDocDatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocDatesWithCallbacks(id: string, onSuccess?: (result: DocDate[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocDates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocDates(xhr: any): DocDate[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocDate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the dates on the specified document
     * @param id Document Key
     * @param updatedData Replacement date data
     * @return Specified dates not found
     */
    updateDocDates(id: string, updatedData: DocDate) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocDatesWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocDatesWithCallbacks(id: string, updatedData: DocDate, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocDates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocDates(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts dates on the specified document
     * @param id Document Key
     * @param newData New date data
     */
    addDocDates(id: string, newData: DocDate) {
        return new Promise<DocDate | null>((resolve, reject) => {
            this.addDocDatesWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocDatesWithCallbacks(id: string, newData: DocDate, onSuccess?: (result: DocDate | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocDates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocDates(xhr: any): DocDate | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocDate.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the dates on the specified document
     * @param id Document Key
     * @param dateRowKey Doc Dates Row Key
     * @return Specified addresses not found
     */
    deleteDocDates(id: string, dateRowKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocDatesWithCallbacks(id, dateRowKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocDatesWithCallbacks(id: string, dateRowKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates/{dateRowKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dateRowKey === undefined || dateRowKey === null)
            throw new Error("The parameter 'dateRowKey' must be defined.");
        url_ = url_.replace("{dateRowKey}", encodeURIComponent("" + dateRowKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocDates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocDates(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the addresses for the specified document
     * @param id Document Key
     */
    getDocAddresses(id: string) {
        return new Promise<DocAddress[] | null>((resolve, reject) => {
            this.getDocAddressesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAddressesWithCallbacks(id: string, onSuccess?: (result: DocAddress[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAddressesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocAddresses(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAddresses(xhr: any): DocAddress[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAddress.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the addresses on the specified document
     * @param id Document Key
     * @param updatedData Replacement address data
     * @return Specified addresses not found
     */
    updateDocAddress(id: string, updatedData: DocAddress) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAddressWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAddressWithCallbacks(id: string, updatedData: DocAddress, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocAddress(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts addresses on the specified document
     * @param id Document Key
     * @param newData New address data
     */
    addDocAddresses(id: string, newData: DocAddress) {
        return new Promise<DocAddress | null>((resolve, reject) => {
            this.addDocAddressesWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAddressesWithCallbacks(id: string, newData: DocAddress, onSuccess?: (result: DocAddress | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAddressesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocAddresses(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAddresses(xhr: any): DocAddress | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAddress.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the addresses on the specified document
     * @param id Document Key
     * @param addressKey Address Key
     * @return Specified addresses not found
     */
    deleteDocAddress(id: string, addressKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAddressWithCallbacks(id, addressKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAddressWithCallbacks(id: string, addressKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses/{addressKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (addressKey === undefined || addressKey === null)
            throw new Error("The parameter 'addressKey' must be defined.");
        url_ = url_.replace("{addressKey}", encodeURIComponent("" + addressKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocAddress(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param key Address Key
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified route not found
     */
    patchDocAddress(id: string, key: string, fieldName: string | null, newValue: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.patchDocAddressWithCallbacks(id, key, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocAddressWithCallbacks(id: string, key: string, fieldName: string | null, newValue: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses/{key}/{fieldName}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchDocAddress(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified field invalid for route", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the attachments for the specified document
     * @param id Document Key
     */
    getDocAttachments(id: string) {
        return new Promise<DocAttachment[] | null>((resolve, reject) => {
            this.getDocAttachmentsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttachmentsWithCallbacks(id: string, onSuccess?: (result: DocAttachment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocAttachments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttachments(xhr: any): DocAttachment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttachment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attachments on the specified document
     * @param id Document Key
     * @param updatedData Replacement attachment data
     * @return Specified attachment not found
     */
    updateDocAttachments(id: string, updatedData: DocAttachment) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttachmentsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttachmentsWithCallbacks(id: string, updatedData: DocAttachment, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocAttachments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttachments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an attachment on the specified document
     * @param id Document Key
     * @param newData New attachment data
     */
    addDocAttachments(id: string, newData: DocAttachment) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.addDocAttachmentsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAttachmentsWithCallbacks(id: string, newData: DocAttachment, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocAttachments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAttachments(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Missing or invalid data", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attachment on the specified document
     * @param id Document Key
     * @param attachKey Doc Attachment Key
     * @return Specified addresses not found
     */
    deleteDocAttachments(id: string, attachKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttachmentsWithCallbacks(id, attachKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttachmentsWithCallbacks(id: string, attachKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/{attachKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachKey === undefined || attachKey === null)
            throw new Error("The parameter 'attachKey' must be defined.");
        url_ = url_.replace("{attachKey}", encodeURIComponent("" + attachKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocAttachments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttachments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the specified document from data in the specified attachment; returns a task key
     * @param id Document Key
     * @param fileKey File Key (must be an Excel file)
     * @return Specified attachment not found
     */
    updateDocVXL(id: string, fileKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocVXLWithCallbacks(id, fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocVXLWithCallbacks(id: string, fileKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/import/{fileKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocVXLWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocVXLWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocVXLWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocVXL(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocVXL(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an attachment on the specified document
     * @param id Document Key
     * @param fileKey file Key
     * @param newName New attachment data
     */
    branchFile(id: string, fileKey: string, newName: string | null) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.branchFileWithCallbacks(id, fileKey, newName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private branchFileWithCallbacks(id: string, fileKey: string, newName: string | null, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/branch/{fileKey}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (newName === undefined)
            throw new Error("The parameter 'newName' must be defined.");
        else if(newName !== null)
            url_ += "newName=" + encodeURIComponent("" + newName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processBranchFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processBranchFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processBranchFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processBranchFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processBranchFile(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Missing or invalid data", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an attachment on the specified document
     * @param id Document Key
     * @param fileKey source file Key, dissolved
     * @param targetKey target file Key, absorbs source file
     */
    joinFiles(id: string, fileKey: string, targetKey: string) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.joinFilesWithCallbacks(id, fileKey, targetKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private joinFilesWithCallbacks(id: string, fileKey: string, targetKey: string, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/join/{fileKey}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (targetKey === undefined || targetKey === null)
            throw new Error("The parameter 'targetKey' must be defined and cannot be null.");
        else
            url_ += "targetKey=" + encodeURIComponent("" + targetKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processJoinFilesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processJoinFilesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processJoinFilesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processJoinFiles(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processJoinFiles(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Missing or invalid data", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an attachment on the specified document
     * @param id Document Key
     * @param attachmentKey source file Key
     * @param targetKey target document Key
     * @param move (optional) move
     */
    moveAttachment(id: string, attachmentKey: string, targetKey: string, move?: boolean | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.moveAttachmentWithCallbacks(id, attachmentKey, targetKey, move, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private moveAttachmentWithCallbacks(id: string, attachmentKey: string, targetKey: string, move: boolean | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/move/{attachmentKey}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentKey === undefined || attachmentKey === null)
            throw new Error("The parameter 'attachmentKey' must be defined.");
        url_ = url_.replace("{attachmentKey}", encodeURIComponent("" + attachmentKey));
        if (targetKey === undefined || targetKey === null)
            throw new Error("The parameter 'targetKey' must be defined and cannot be null.");
        else
            url_ += "targetKey=" + encodeURIComponent("" + targetKey) + "&";
        if (move === null)
            throw new Error("The parameter 'move' cannot be null.");
        else if (move !== undefined)
            url_ += "move=" + encodeURIComponent("" + move) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMoveAttachmentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMoveAttachmentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMoveAttachmentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processMoveAttachment(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMoveAttachment(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Missing or invalid data", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the inclusions for the specified document
     * @param id Document Key
     */
    getDocInclusions(id: string) {
        return new Promise<DocInclusion[] | null>((resolve, reject) => {
            this.getDocInclusionsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocInclusionsWithCallbacks(id: string, onSuccess?: (result: DocInclusion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocInclusions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocInclusions(xhr: any): DocInclusion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocInclusion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the inclusions on the specified document
     * @param id Document Key
     * @param updatedData Replacement inclusion(exclusion) data
     * @return Specified inclusion not found
     */
    updateDocInclusions(id: string, updatedData: DocInclusion) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocInclusionsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocInclusionsWithCallbacks(id: string, updatedData: DocInclusion, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocInclusions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocInclusions(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an inclusions on the specified document
     * @param id Document Key
     * @param newData New inclusion(exclusion) data
     */
    addDocInclusions(id: string, newData: DocInclusion) {
        return new Promise<DocInclusion | null>((resolve, reject) => {
            this.addDocInclusionsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocInclusionsWithCallbacks(id: string, newData: DocInclusion, onSuccess?: (result: DocInclusion | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocInclusions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocInclusions(xhr: any): DocInclusion | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocInclusion.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the inclusions on the specified document
     * @param id Document Key
     * @param inclusionKey Inclusion Key
     * @return Specified inclusion not found
     */
    deleteDocInclusions(id: string, inclusionKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocInclusionsWithCallbacks(id, inclusionKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocInclusionsWithCallbacks(id: string, inclusionKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions/{inclusionKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (inclusionKey === undefined || inclusionKey === null)
            throw new Error("The parameter 'inclusionKey' must be defined.");
        url_ = url_.replace("{inclusionKey}", encodeURIComponent("" + inclusionKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocInclusions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocInclusions(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the compliance for the specified document
     * @param id Document Key
     */
    getDocCompliance(id: string) {
        return new Promise<DocCompliance[] | null>((resolve, reject) => {
            this.getDocComplianceWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocComplianceWithCallbacks(id: string, onSuccess?: (result: DocCompliance[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocCompliance(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocCompliance(xhr: any): DocCompliance[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocCompliance.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the compliance on the specified document
     * @param id Document Key
     * @param updatedData Replacement compliance data
     * @return Specified compliance not found
     */
    updateDocCompliance(id: string, updatedData: DocCompliance) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocComplianceWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocComplianceWithCallbacks(id: string, updatedData: DocCompliance, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocCompliance(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocCompliance(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts compliance on the specified document
     * @param id Document Key
     * @param newData New compliance data
     */
    addDocCompliance(id: string, newData: DocCompliance) {
        return new Promise<DocCompliance | null>((resolve, reject) => {
            this.addDocComplianceWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocComplianceWithCallbacks(id: string, newData: DocCompliance, onSuccess?: (result: DocCompliance | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocCompliance(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocCompliance(xhr: any): DocCompliance | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocCompliance.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the compliance on the specified document
     * @param id Document Key
     * @param complianceKey Compliance Item Key
     * @return Specified addresses not found
     */
    deleteDocCompliance(id: string, complianceKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocComplianceWithCallbacks(id, complianceKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocComplianceWithCallbacks(id: string, complianceKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance/{complianceKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (complianceKey === undefined || complianceKey === null)
            throw new Error("The parameter 'complianceKey' must be defined.");
        url_ = url_.replace("{complianceKey}", encodeURIComponent("" + complianceKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocCompliance(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocCompliance(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the meeting attendees for the specified document
     * @param id Document Key
     */
    getDocAttendees(id: string) {
        return new Promise<DocMeetingAttendee[] | null>((resolve, reject) => {
            this.getDocAttendeesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttendeesWithCallbacks(id: string, onSuccess?: (result: DocMeetingAttendee[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttendeesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttendeesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttendeesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocAttendees(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttendees(xhr: any): DocMeetingAttendee[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocMeetingAttendee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attendees on the specified document
     * @param id Document Key
     * @param updatedData Replacement attendee data
     * @return Specified attendee not found
     */
    updateDocAttendee(id: string, updatedData: DocMeetingAttendee) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttendeeWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttendeeWithCallbacks(id: string, updatedData: DocMeetingAttendee, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocAttendee(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttendee(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts attendees on the specified document
     * @param id Document Key
     * @param newData New attendee data
     */
    addDocAttendee(id: string, newData: DocMeetingAttendee) {
        return new Promise<DocMeetingAttendee | null>((resolve, reject) => {
            this.addDocAttendeeWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAttendeeWithCallbacks(id: string, newData: DocMeetingAttendee, onSuccess?: (result: DocMeetingAttendee | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocAttendee(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAttendee(xhr: any): DocMeetingAttendee | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMeetingAttendee.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attendees on the specified document
     * @param id Document Key
     * @param attendeeKey Attendee Key
     * @return Specified addresses not found
     */
    deleteDocAttendee(id: string, attendeeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttendeeWithCallbacks(id, attendeeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttendeeWithCallbacks(id: string, attendeeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees/{attendeeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attendeeKey === undefined || attendeeKey === null)
            throw new Error("The parameter 'attendeeKey' must be defined.");
        url_ = url_.replace("{attendeeKey}", encodeURIComponent("" + attendeeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocAttendee(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttendee(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the attributes for the specified document
     * @param id Document Key
     */
    getDocAttributes(id: string) {
        return new Promise<DocAttribute[] | null>((resolve, reject) => {
            this.getDocAttributesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttributesWithCallbacks(id: string, onSuccess?: (result: DocAttribute[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocAttributes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttributes(xhr: any): DocAttribute[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttribute.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attributes on the specified document
     * @param id Document Key
     * @param updatedData Replacement attribute data
     * @return Specified attribute not found
     */
    updateDocAttributes(id: string, updatedData: DocAttribute) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttributesWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttributesWithCallbacks(id: string, updatedData: DocAttribute, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateDocAttributes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttributes(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts attributes on the specified document
     * @param id Document Key
     * @param newData New attribute data
     */
    addDocAttributes(id: string, newData: DocAttribute) {
        return new Promise<DocAttribute | null>((resolve, reject) => {
            this.addDocAttributesWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAttributesWithCallbacks(id: string, newData: DocAttribute, onSuccess?: (result: DocAttribute | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocAttributes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAttributes(xhr: any): DocAttribute | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttribute.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attributes on the specified document
     * @param id Document Key
     * @param attributeKey Attribute Key
     * @return Specified addresses not found
     */
    deleteDocAttributes(id: string, attributeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttributesWithCallbacks(id, attributeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttributesWithCallbacks(id: string, attributeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes/{attributeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocAttributes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttributes(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the links for the specified document
     * @param id Document Key
     */
    getDocLinks(id: string) {
        return new Promise<DocAttachment[] | null>((resolve, reject) => {
            this.getDocLinksWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocLinksWithCallbacks(id: string, onSuccess?: (result: DocAttachment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDocLinks(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocLinks(xhr: any): DocAttachment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttachment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts a Link on the specified document
     * @param id Document Key
     * @param newData New link data
     */
    addDocLinks(id: string, newData: DocAttachment) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.addDocLinksWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocLinksWithCallbacks(id: string, newData: DocAttachment, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddDocLinks(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocLinks(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attachment on the specified document
     * @param id Document Key
     * @param linkKey Doc Link Key
     * @return Specified addresses not found
     */
    deleteDocLinks(id: string, linkKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocLinksWithCallbacks(id, linkKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocLinksWithCallbacks(id: string, linkKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links/{linkKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (linkKey === undefined || linkKey === null)
            throw new Error("The parameter 'linkKey' must be defined.");
        url_ = url_.replace("{linkKey}", encodeURIComponent("" + linkKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocLinks(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocLinks(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the comments on the specified document
     * @param id Document Key
     * @param commentKey Comment Key
     * @return Specified addresses not found
     */
    deleteDocComments(id: string, commentKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocCommentsWithCallbacks(id, commentKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocCommentsWithCallbacks(id: string, commentKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments/{commentKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (commentKey === undefined || commentKey === null)
            throw new Error("The parameter 'commentKey' must be defined.");
        url_ = url_.replace("{commentKey}", encodeURIComponent("" + commentKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocComments(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocComments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Not acceptable", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about copyability of the specified document
     * @param id Document Key
     */
    getDialogPreCopyThisDoc(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogPreCopyThisDocWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogPreCopyThisDocWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/copyable";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogPreCopyThisDocWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogPreCopyThisDocWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogPreCopyThisDocWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogPreCopyThisDoc(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogPreCopyThisDoc(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about address types for the specified document
     * @param id Document Key
     */
    getDialogAddresses(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogAddressesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogAddressesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/address";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogAddressesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogAddresses(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogAddresses(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about date types for the specified document
     * @param id Document Key
     */
    getDialogDates(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogDatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogDatesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogDates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogDates(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about compliance types for the specified document
     * @param id Document Key
     */
    getDialogComplianceTypes(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogComplianceTypesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogComplianceTypesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogComplianceTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogComplianceTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogComplianceTypesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogComplianceTypes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogComplianceTypes(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about inclusion types for the specified document
     * @param id Document Key
     */
    getDialogInclusionTypes(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogInclusionTypesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogInclusionTypesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogInclusionTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogInclusionTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogInclusionTypesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogInclusionTypes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogInclusionTypes(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about templates for the specified document
     * @param id Document Key
     */
    getDialogTemplates(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogTemplatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogTemplatesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/templates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogTemplatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogTemplatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogTemplatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogTemplates(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogTemplates(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about attach actions for the specified document
     * @param id Document Key
     */
    getDialogAttachables(id: string) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogAttachablesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogAttachablesWithCallbacks(id: string, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/attachable";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogAttachablesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogAttachablesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogAttachablesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogAttachables(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogAttachables(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about route actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [build|apply|quickadd|all]
     */
    getDialogRoutables(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogRoutablesWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogRoutablesWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/routable?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogRoutablesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogRoutablesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogRoutablesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogRoutables(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogRoutables(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about exclusivity actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [HoldAuto,Hold24,Hold,HoldManual,HoldNone,HoldRoute,HoldInfo]
     */
    getDialogExclusivity(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogExclusivityWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogExclusivityWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/exclusive?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogExclusivityWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogExclusivity(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogExclusivity(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [all]
     */
    getDialogAbstract(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogAbstractWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogAbstractWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/abstract?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDialogAbstract(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogAbstract(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Document not accessible", status, _responseText, _headers, result401);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Document access denied", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class SystemClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns server version in major.minor.build.t
     * @param shortVersion (optional) 
     */
    getVersion(shortVersion?: boolean | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getVersionWithCallbacks(shortVersion, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getVersionWithCallbacks(shortVersion: boolean | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/version?";
        if (shortVersion === null)
            throw new Error("The parameter 'shortVersion' cannot be null.");
        else if (shortVersion !== undefined)
            url_ += "shortVersion=" + encodeURIComponent("" + shortVersion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetVersionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetVersion(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetVersion(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns UUID
     */
    getNonce(peerKey: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.getNonceWithCallbacks(peerKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getNonceWithCallbacks(peerKey: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/nonce?";
        if (peerKey === undefined)
            throw new Error("The parameter 'peerKey' must be defined.");
        else if(peerKey !== null)
            url_ += "peerKey=" + encodeURIComponent("" + peerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetNonceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetNonceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetNonceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetNonce(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetNonce(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns server notification or empty string
     * @param hash Optional Notification Hash (eschews stale cache)
     */
    getSystemNotification(hash: string | null) {
        return new Promise<string | null>((resolve, reject) => {
            this.getSystemNotificationWithCallbacks(hash, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSystemNotificationWithCallbacks(hash: string | null, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/notification/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSystemNotificationWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSystemNotificationWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSystemNotificationWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSystemNotification(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSystemNotification(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns site branding label
     */
    getBranding() {
        return new Promise<string | null>((resolve, reject) => {
            this.getBrandingWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getBrandingWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/branding";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetBrandingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetBrandingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetBrandingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetBranding(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetBranding(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns site copyright label
     */
    getCopyright() {
        return new Promise<string | null>((resolve, reject) => {
            this.getCopyrightWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCopyrightWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/copyright";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCopyrightWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCopyrightWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCopyrightWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCopyright(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCopyright(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns site logo URL
     */
    getSiteLogo() {
        return new Promise<string | null>((resolve, reject) => {
            this.getSiteLogoWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSiteLogoWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/logo";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSiteLogoWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSiteLogoWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSiteLogoWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSiteLogo(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSiteLogo(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns state of identity federation peers
     */
    getFederationVia() {
        return new Promise<{ [key: string]: string; } | null>((resolve, reject) => {
            this.getFederationViaWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFederationViaWithCallbacks(onSuccess?: (result: { [key: string]: string; } | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/federation";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFederationViaWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFederationViaWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFederationViaWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFederationVia(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFederationVia(xhr: any): { [key: string]: string; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns public catalog data (for example login-1.htm
     */
    getPublicResource(path: string | null) {
        return new Promise<string | null>((resolve, reject) => {
            this.getPublicResourceWithCallbacks(path, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getPublicResourceWithCallbacks(path: string | null, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/public?";
        if (path === undefined)
            throw new Error("The parameter 'path' must be defined.");
        else if(path !== null)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetPublicResourceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetPublicResourceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetPublicResourceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetPublicResource(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetPublicResource(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns name of this IIS server
     */
    getServerNodeName() {
        return new Promise<string | null>((resolve, reject) => {
            this.getServerNodeNameWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getServerNodeNameWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/node";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetServerNodeNameWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetServerNodeNameWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetServerNodeNameWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetServerNodeName(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetServerNodeName(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns if running in dev mode
     */
    getDevMode() {
        return new Promise<boolean>((resolve, reject) => {
            this.getDevModeWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDevModeWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/dev";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDevModeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDevModeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDevModeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDevMode(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDevMode(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Changes dev mode
     * @param mode New Dev Mode
     */
    setDevMode(mode: boolean) {
        return new Promise<boolean>((resolve, reject) => {
            this.setDevModeWithCallbacks(mode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private setDevModeWithCallbacks(mode: boolean, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/dev/{mode}";
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined.");
        url_ = url_.replace("{mode}", encodeURIComponent("" + mode));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processSetDevModeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetDevModeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processSetDevModeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processSetDevMode(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processSetDevMode(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Allows admin to suppress Declarative Referential Integrity
     * @param key Key, usually a Data PK
     * @param mode New DRI Mode
     */
    setDRI(key: string | null, mode: boolean) {
        return new Promise<boolean>((resolve, reject) => {
            this.setDRIWithCallbacks(key, mode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private setDRIWithCallbacks(key: string | null, mode: boolean, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/dri/{key}/{mode}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined.");
        url_ = url_.replace("{mode}", encodeURIComponent("" + mode));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processSetDRIWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetDRIWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processSetDRIWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processSetDRI(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processSetDRI(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Allows admin to detect state of  Declarative Referential Integrity
     * @param key Key, usually a Data PK
     */
    getDRI(key: string | null) {
        return new Promise<boolean>((resolve, reject) => {
            this.getDRIWithCallbacks(key, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDRIWithCallbacks(key: string | null, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/dri/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDRIWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDRIWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDRIWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDRI(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDRI(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of active document/process types
     * @param key Use nothing for all active processes
     */
    getProcessList(key: string) {
        return new Promise<ProcessDocumentType[] | null>((resolve, reject) => {
            this.getProcessListWithCallbacks(key, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProcessListWithCallbacks(key: string, onSuccess?: (result: ProcessDocumentType[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/process/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProcessListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProcessListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProcessListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProcessList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProcessList(xhr: any): ProcessDocumentType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessDocumentType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of trashed documents
     * @param key (optional) Use empty for all deleted docs
     */
    getDeletedDocList(key?: string | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getDeletedDocListWithCallbacks(key, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDeletedDocListWithCallbacks(key: string | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/documents/trash?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDeletedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDeletedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDeletedDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDeletedDocList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDeletedDocList(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Recovers a specific deleted document
     * @param key (optional) Required DMK
     */
    recoverDeletedDocument(key?: string | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.recoverDeletedDocumentWithCallbacks(key, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private recoverDeletedDocumentWithCallbacks(key: string | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/documents/trash?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processRecoverDeletedDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRecoverDeletedDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processRecoverDeletedDocumentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processRecoverDeletedDocument(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processRecoverDeletedDocument(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of active documents
     */
    getActiveDocList() {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getActiveDocListWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getActiveDocListWithCallbacks(onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/documents/active";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetActiveDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetActiveDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetActiveDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetActiveDocList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetActiveDocList(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of active users
     */
    getActiveUserList() {
        return new Promise<UserSessionInfo[] | null>((resolve, reject) => {
            this.getActiveUserListWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getActiveUserListWithCallbacks(onSuccess?: (result: UserSessionInfo[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/users/active";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetActiveUserListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetActiveUserListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetActiveUserListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetActiveUserList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetActiveUserList(xhr: any): UserSessionInfo[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSessionInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Prunes idle users (per license)
     */
    pruneIdleUsers() {
        return new Promise<number>((resolve, reject) => {
            this.pruneIdleUsersWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private pruneIdleUsersWithCallbacks(onSuccess?: (result: number) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/users/idle";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPruneIdleUsersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPruneIdleUsersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPruneIdleUsersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPruneIdleUsers(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPruneIdleUsers(xhr: any): number | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Reloads site configuration and settings
     */
    reloadSiteConfiguration() {
        return new Promise<string | null>((resolve, reject) => {
            this.reloadSiteConfigurationWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private reloadSiteConfigurationWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/configuration";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReloadSiteConfigurationWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReloadSiteConfigurationWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReloadSiteConfigurationWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processReloadSiteConfiguration(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReloadSiteConfiguration(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Encrypts and stores the posted information in xtsConfig
     * @param partnerType partner type (eg CloudStore)
     * @param servicePoint for Service.oAuthData
     * @param payload Quote enclosed JSON
     */
    postAuthData(partnerType: string | null, servicePoint: string | null, payload: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postAuthDataWithCallbacks(partnerType, servicePoint, payload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postAuthDataWithCallbacks(partnerType: string | null, servicePoint: string | null, payload: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/oauthdata/{partnerType}/{servicePoint}";
        if (partnerType === undefined || partnerType === null)
            throw new Error("The parameter 'partnerType' must be defined.");
        url_ = url_.replace("{partnerType}", encodeURIComponent("" + partnerType));
        if (servicePoint === undefined || servicePoint === null)
            throw new Error("The parameter 'servicePoint' must be defined.");
        url_ = url_.replace("{servicePoint}", encodeURIComponent("" + servicePoint));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostAuthDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostAuthDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostAuthDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostAuthData(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostAuthData(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns obfuscated and Base64 encoded string
     * @param usingKey Key for encrypt
     * @param payload What to encrypt and Base64 (enclose in quotes)
     * @return Umm
     */
    obfuscateData(usingKey: string | null, payload: string) {
        return new Promise<string>((resolve, reject) => {
            this.obfuscateDataWithCallbacks(usingKey, payload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private obfuscateDataWithCallbacks(usingKey: string | null, payload: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/obfuscate/{usingKey}";
        if (usingKey === undefined || usingKey === null)
            throw new Error("The parameter 'usingKey' must be defined.");
        url_ = url_.replace("{usingKey}", encodeURIComponent("" + usingKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processObfuscateDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processObfuscateDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processObfuscateDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processObfuscateData(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processObfuscateData(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Key too simple", status, _responseText, _headers, result400);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns statistical data
     */
    getSystemStats() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getSystemStatsWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSystemStatsWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/system/stats";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSystemStatsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSystemStatsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSystemStatsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSystemStats(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSystemStats(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns a summary overview of the specified project
     * @param projectID Full Project ID
     */
    getProjectDetail(projectID: string | null) {
        return new Promise<ProjectAbstract | null>((resolve, reject) => {
            this.getProjectDetailWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDetailWithCallbacks(projectID: string | null, onSuccess?: (result: ProjectAbstract | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Abstract";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDetailWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectDetail(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDetail(xhr: any): ProjectAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectAbstract.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    x() {
        return new Promise<void>((resolve, reject) => {
            this.xWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private xWithCallbacks(onSuccess?: (result: void) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/ProjectTools";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
            }
        }).done((_data, _textStatus, xhr) => {
            this.processXWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processXWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processXWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processX(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processX(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = xhr.responseText;
            return;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Releases all cached financial data
     * @param projectID Full Project ID
     */
    deleteProjectCache(projectID: string | null) {
        return new Promise<any>((resolve, reject) => {
            this.deleteProjectCacheWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteProjectCacheWithCallbacks(projectID: string | null, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cache";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteProjectCacheWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteProjectCacheWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteProjectCacheWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteProjectCache(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteProjectCache(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a summary of peer tasks for this project
     * @param projectID Full Project ID
     */
    getProjectPeerSummary(projectID: string | null) {
        return new Promise<ProjectXTSTaskState[] | null>((resolve, reject) => {
            this.getProjectPeerSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPeerSummaryWithCallbacks(projectID: string | null, onSuccess?: (result: ProjectXTSTaskState[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/xts";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPeerSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPeerSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPeerSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectPeerSummary(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPeerSummary(xhr: any): ProjectXTSTaskState[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectXTSTaskState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Requests peer re-sync
     * @param projectID Full Project ID
     */
    refreshPeerSummary(projectID: string | null) {
        return new Promise<any>((resolve, reject) => {
            this.refreshPeerSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private refreshPeerSummaryWithCallbacks(projectID: string | null, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/xts";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processRefreshPeerSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRefreshPeerSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processRefreshPeerSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processRefreshPeerSummary(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processRefreshPeerSummary(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that link to the specified project
     * @param projectID Full Project ID
     */
    getProjectLinks(projectID: string | null) {
        return new Promise<ProjectLink[] | null>((resolve, reject) => {
            this.getProjectLinksWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectLinksWithCallbacks(projectID: string | null, onSuccess?: (result: ProjectLink[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Links";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectLinks(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectLinks(xhr: any): ProjectLink[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WBS for the specified project
     * @param projectID Full Project ID
     */
    getProjectWBS(projectID: string | null) {
        return new Promise<ProjectWBS[] | null>((resolve, reject) => {
            this.getProjectWBSWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWBSWithCallbacks(projectID: string | null, onSuccess?: (result: ProjectWBS[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/wbs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWBSWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectWBS(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWBS(xhr: any): ProjectWBS[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectWBS.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds WBS to the specified project
     * @param projectID Full Project ID
     */
    addProjectWBS(projectID: string | null, wbsLine: ProjectWBS) {
        return new Promise<ProjectWBS | null>((resolve, reject) => {
            this.addProjectWBSWithCallbacks(projectID, wbsLine, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addProjectWBSWithCallbacks(projectID: string | null, wbsLine: ProjectWBS, onSuccess?: (result: ProjectWBS | null) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/wbs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wbsLine);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddProjectWBSWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddProjectWBS(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddProjectWBS(xhr: any): ProjectWBS | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("WBS Line not found", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("value cannot be changed by this method", status, _responseText, _headers, result406);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified new value is not acceptable", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWBS.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WBS for the specified project
     * @param projectID Full Project ID
     */
    putProjectWBS(projectID: string | null, wbsLine: ProjectWBS) {
        return new Promise<ProjectWBS | null>((resolve, reject) => {
            this.putProjectWBSWithCallbacks(projectID, wbsLine, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private putProjectWBSWithCallbacks(projectID: string | null, wbsLine: ProjectWBS, onSuccess?: (result: ProjectWBS | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/wbs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wbsLine);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPutProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPutProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPutProjectWBSWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPutProjectWBS(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPutProjectWBS(xhr: any): ProjectWBS | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWBS.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WBS for the specified project
     * @param projectID Full Project ID
     * @param wBSID Row Key or WB Code
     * @param fieldName Field Name
     * @param newValue Replacement data
     */
    patchProjectWBS(projectID: string | null, wBSID: string | null, fieldName: string | null, newValue: string) {
        return new Promise<ProjectWBS | null>((resolve, reject) => {
            this.patchProjectWBSWithCallbacks(projectID, wBSID, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchProjectWBSWithCallbacks(projectID: string | null, wBSID: string | null, fieldName: string | null, newValue: string, onSuccess?: (result: ProjectWBS | null) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/wbs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (wBSID === undefined)
            throw new Error("The parameter 'wBSID' must be defined.");
        else if(wBSID !== null)
            url_ += "WBSID=" + encodeURIComponent("" + wBSID) + "&";
        if (fieldName === undefined)
            throw new Error("The parameter 'fieldName' must be defined.");
        else if(fieldName !== null)
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchProjectWBSWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchProjectWBSWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchProjectWBS(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchProjectWBS(xhr: any): ProjectWBS | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("WBS Line not found", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("value cannot be changed by this method", status, _responseText, _headers, result406);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified new value is not acceptable", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWBS.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showExp (optional) Include Expense
     * @param showRev (optional) Include Revenue
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCost(projectID: string | null, summaryByAccount?: boolean | undefined, summaryByTask?: boolean | undefined, showExp?: boolean | undefined, showRev?: boolean | undefined, showUnits?: boolean | undefined, showThousands?: boolean | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getProjectCostWithCallbacks(projectID, summaryByAccount, summaryByTask, showExp, showRev, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostWithCallbacks(projectID: string | null, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showExp: boolean | undefined, showRev: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Costs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showExp === null)
            throw new Error("The parameter 'showExp' cannot be null.");
        else if (showExp !== undefined)
            url_ += "showExp=" + encodeURIComponent("" + showExp) + "&";
        if (showRev === null)
            throw new Error("The parameter 'showRev' cannot be null.");
        else if (showRev !== undefined)
            url_ += "showRev=" + encodeURIComponent("" + showRev) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectCost(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCost(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns one to three rows to summarize project costs summarized by Account and or Task.  The task_desk and acct fields are set to idenitify the Expense, Revenue and Margin in the result set. The Revenue and Margin rows return the values (revnue and expense margin) in the expense fields
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Category
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showExp (optional) Include Expenses
     * @param showRev (optional) Include Revenue (only if summaryByAccount)
     * @param showUnits (optional) Return Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCostFooters(projectID: string | null, summaryByAccount?: boolean | undefined, summaryByTask?: boolean | undefined, showExp?: boolean | undefined, showRev?: boolean | undefined, showUnits?: boolean | undefined, showThousands?: boolean | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectCostFootersWithCallbacks(projectID, summaryByAccount, summaryByTask, showExp, showRev, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostFootersWithCallbacks(projectID: string | null, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showExp: boolean | undefined, showRev: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/CostSummary?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showExp === null)
            throw new Error("The parameter 'showExp' cannot be null.");
        else if (showExp !== undefined)
            url_ += "showExp=" + encodeURIComponent("" + showExp) + "&";
        if (showRev === null)
            throw new Error("The parameter 'showRev' cannot be null.");
        else if (showRev !== undefined)
            url_ += "showRev=" + encodeURIComponent("" + showRev) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostFootersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectCostFooters(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostFooters(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns recent weather reading at the specified project site
     * @param projectID Full Project ID
     */
    getProjectWeatherReading(projectID: string | null) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.getProjectWeatherReadingWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherReadingWithCallbacks(projectID: string | null, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherReading";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherReadingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectWeatherReading(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherReading(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns history of weather readings at the specified project site INCOMPLETE
     * @param projectID Full Project ID
     */
    getProjectWeatherHistory(projectID: string | null) {
        return new Promise<WeatherAtLocation[] | null>((resolve, reject) => {
            this.getProjectWeatherHistoryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherHistoryWithCallbacks(projectID: string | null, onSuccess?: (result: WeatherAtLocation[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherHistory";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectWeatherHistory(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherHistory(xhr: any): WeatherAtLocation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAtLocation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns current note for the specified project
     * @param projectID Full Project ID
     */
    getProjectNote(projectID: string | null) {
        return new Promise<string | null>((resolve, reject) => {
            this.getProjectNoteWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNoteWithCallbacks(projectID: string | null, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectNote(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNote(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Sets project note INCOMPLETE!!!
     * @param projectID Full Project ID
     */
    newProjectNote(projectID: string | null, newNote: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.newProjectNoteWithCallbacks(projectID, newNote, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private newProjectNoteWithCallbacks(projectID: string | null, newNote: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newNote);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processNewProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processNewProjectNote(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processNewProjectNote(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns all notes for the specified project
     * @param projectID Full Project ID
     */
    getProjectNotes(projectID: string | null) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getProjectNotesWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNotesWithCallbacks(projectID: string | null, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Notes";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNotesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectNotes(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNotes(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns transactions that detail costs on the project
     * @param projectID Full Project ID
     * @param forWBS (optional) Cost Code Like
     * @param forAccount (optional) Account Category
     * @param forAccountType (optional) Account Category Type (RV,EX,%)
     * @param forAccountClass (optional) Account Category Class (L,LB,M,O,P)
     * @param forPeriod (optional) Fiscal Period
     * @param fromDate (optional) From Date
     * @param thruDate (optional) Thru Date
     * @param refDMK (optional) Reference Document
     * @param refVendor (optional) Reference Vendor ID (or Contact Key)
     */
    getProjectCostTransactions(projectID: string | null, forWBS?: string | null | undefined, forAccount?: string | null | undefined, forAccountType?: string | null | undefined, forAccountClass?: string | null | undefined, forPeriod?: string | null | undefined, fromDate?: string | null | undefined, thruDate?: string | null | undefined, refDMK?: string | null | undefined, refVendor?: string | null | undefined) {
        return new Promise<ProjectTranDetail[] | null>((resolve, reject) => {
            this.getProjectCostTransactionsWithCallbacks(projectID, forWBS, forAccount, forAccountType, forAccountClass, forPeriod, fromDate, thruDate, refDMK, refVendor, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostTransactionsWithCallbacks(projectID: string | null, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined, onSuccess?: (result: ProjectTranDetail[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cost/transactions?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forWBS !== undefined && forWBS !== null)
            url_ += "forWBS=" + encodeURIComponent("" + forWBS) + "&";
        if (forAccount !== undefined && forAccount !== null)
            url_ += "forAccount=" + encodeURIComponent("" + forAccount) + "&";
        if (forAccountType !== undefined && forAccountType !== null)
            url_ += "forAccountType=" + encodeURIComponent("" + forAccountType) + "&";
        if (forAccountClass !== undefined && forAccountClass !== null)
            url_ += "forAccountClass=" + encodeURIComponent("" + forAccountClass) + "&";
        if (forPeriod !== undefined && forPeriod !== null)
            url_ += "forPeriod=" + encodeURIComponent("" + forPeriod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (thruDate !== undefined && thruDate !== null)
            url_ += "thruDate=" + encodeURIComponent("" + thruDate) + "&";
        if (refDMK !== undefined && refDMK !== null)
            url_ += "refDMK=" + encodeURIComponent("" + refDMK) + "&";
        if (refVendor !== undefined && refVendor !== null)
            url_ += "refVendor=" + encodeURIComponent("" + refVendor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostTransactionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectCostTransactions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostTransactions(xhr: any): ProjectTranDetail[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTranDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns Committed Amounts   on the project
     * @param projectID Full Project ID
     * @param forWBS (optional) Cost Code Like
     * @param forAccount (optional) Account Category
     * @param forAccountType (optional) Account Category Type (RV,EX,%)
     * @param forAccountClass (optional) Account Category Class (L,LB,M,O,P)
     * @param forPeriod (optional) Fiscal Period
     */
    getProjectCommittedCosts(projectID: string | null, forWBS?: string | null | undefined, forAccount?: string | null | undefined, forAccountType?: string | null | undefined, forAccountClass?: string | null | undefined, forPeriod?: string | null | undefined) {
        return new Promise<ProjectCommitmentDetail[] | null>((resolve, reject) => {
            this.getProjectCommittedCostsWithCallbacks(projectID, forWBS, forAccount, forAccountType, forAccountClass, forPeriod, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCommittedCostsWithCallbacks(projectID: string | null, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, onSuccess?: (result: ProjectCommitmentDetail[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cost/committed?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forWBS !== undefined && forWBS !== null)
            url_ += "forWBS=" + encodeURIComponent("" + forWBS) + "&";
        if (forAccount !== undefined && forAccount !== null)
            url_ += "forAccount=" + encodeURIComponent("" + forAccount) + "&";
        if (forAccountType !== undefined && forAccountType !== null)
            url_ += "forAccountType=" + encodeURIComponent("" + forAccountType) + "&";
        if (forAccountClass !== undefined && forAccountClass !== null)
            url_ += "forAccountClass=" + encodeURIComponent("" + forAccountClass) + "&";
        if (forPeriod !== undefined && forPeriod !== null)
            url_ += "forPeriod=" + encodeURIComponent("" + forPeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCommittedCostsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCommittedCostsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCommittedCostsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectCommittedCosts(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCommittedCosts(xhr: any): ProjectCommitmentDetail[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectCommitmentDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AccountClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Authenticates a session and generates a FormsAuthenticationTicket and cookie
     */
    postLogin(credentials: SiteLogin) {
        return new Promise<string | null>((resolve, reject) => {
            this.postLoginWithCallbacks(credentials, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postLoginWithCallbacks(credentials: SiteLogin, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostLoginWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostLogin(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostLogin(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Unusable credentials with redirect to login ", status, _responseText, _headers, result302);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not allowed now (see message for issue) ", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Backend failure", status, _responseText, _headers, result500);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Not allowed now (already authenticated?)", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general information about the Authenticated user
     */
    getUserData() {
        return new Promise<CurrentUser | null>((resolve, reject) => {
            this.getUserDataWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserDataWithCallbacks(onSuccess?: (result: CurrentUser | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetUserData(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserData(xhr: any): CurrentUser | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUser.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Digest an identity from an MSAL token
     * @param entraID full oid.tid
     * @param nonce nonce
     * @param token token
     */
    shareMSALAuth(entraID: string | null, nonce: string, token: any) {
        return new Promise<string | null>((resolve, reject) => {
            this.shareMSALAuthWithCallbacks(entraID, nonce, token, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private shareMSALAuthWithCallbacks(entraID: string | null, nonce: string, token: any, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/account/msalauth/{entraID}?";
        if (entraID === undefined || entraID === null)
            throw new Error("The parameter 'entraID' must be defined.");
        url_ = url_.replace("{entraID}", encodeURIComponent("" + entraID));
        if (nonce === undefined || nonce === null)
            throw new Error("The parameter 'nonce' must be defined and cannot be null.");
        else
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processShareMSALAuthWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processShareMSALAuthWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processShareMSALAuthWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processShareMSALAuth(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processShareMSALAuth(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not allowed now (see message for issue) ", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Not allowed now (already authenticated?)", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Ugh", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Digest an identity from an Google token
     * @param subId google nonvolatile id
     * @param nonce nonce
     * @param token token
     */
    shareGoogleAuth(subId: string | null, nonce: string, token: any) {
        return new Promise<string | null>((resolve, reject) => {
            this.shareGoogleAuthWithCallbacks(subId, nonce, token, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private shareGoogleAuthWithCallbacks(subId: string | null, nonce: string, token: any, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/account/google/{subId}?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId));
        if (nonce === undefined || nonce === null)
            throw new Error("The parameter 'nonce' must be defined and cannot be null.");
        else
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processShareGoogleAuthWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processShareGoogleAuthWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processShareGoogleAuthWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processShareGoogleAuth(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processShareGoogleAuth(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not allowed now (see message for issue) ", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Not allowed now (already authenticated?)", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Ugh", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns true
     */
    hasSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.hasSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private hasSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/account/session";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processHasSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processHasSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processHasSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processHasSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processHasSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns information about password composition
     */
    getPasswordOptions() {
        return new Promise<PasswordConfiguredOptions | null>((resolve, reject) => {
            this.getPasswordOptionsWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getPasswordOptionsWithCallbacks(onSuccess?: (result: PasswordConfiguredOptions | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/PasswordOptions";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetPasswordOptionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetPasswordOptionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetPasswordOptionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetPasswordOptions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetPasswordOptions(xhr: any): PasswordConfiguredOptions | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PasswordConfiguredOptions.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetEndOfSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns authorization flags for specified demand if they match or exceed the request
     * @param demand Demand Context
     */
    getAccessAllows(demand: PermissionContext) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getAccessAllowsWithCallbacks(demand, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getAccessAllowsWithCallbacks(demand: PermissionContext, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/account/allows";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(demand);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetAccessAllowsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAccessAllowsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetAccessAllowsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetAccessAllows(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetAccessAllows(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AlertsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns alert items for a specified user
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserAlertList(forUserKey: string) {
        return new Promise<UserAlert[] | null>((resolve, reject) => {
            this.getUserAlertListWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserAlertListWithCallbacks(forUserKey: string, onSuccess?: (result: UserAlert[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserAlertListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetUserAlertList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserAlertList(xhr: any): UserAlert[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("user not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("You are not allowed to proxy for this user", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAlert.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates and stores an alert
     * @param theAlert Model with new alert. Specify AlertText, Description.  UserKey, DocMasterKey, Project, Source, SourceKey and Info1 are optional;
     */
    createAlert(theAlert: UserAlert) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.createAlertWithCallbacks(theAlert, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createAlertWithCallbacks(theAlert: UserAlert, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(theAlert);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateAlert(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("not allowed now", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("internal failure", status, _responseText, _headers, result409);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns changed alert items for a specified user
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param dataSummary KVP of current row keys (AlertKey) and eTags
     */
    getUserAlertChangeList(forUserKey: string, dataSummary: CurrentDataSummary[]) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getUserAlertChangeListWithCallbacks(forUserKey, dataSummary, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserAlertChangeListWithCallbacks(forUserKey: string, dataSummary: CurrentDataSummary[], onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/{forUserKey}/changes";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined.");
        url_ = url_.replace("{forUserKey}", encodeURIComponent("" + forUserKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataSummary);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserAlertChangeListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserAlertChangeListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserAlertChangeListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetUserAlertChangeList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserAlertChangeList(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("user not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("You are not allowed to proxy for this user", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes all alert item for the specified user
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAllAlerts(forUserKey?: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAllAlertsWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAllAlertsWithCallbacks(forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/all?";
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAllAlertsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteAllAlerts(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAllAlerts(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("not allowed now", status, _responseText, _headers, result400);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("key required", status, _responseText, _headers, result406);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes a specific alert item for the specified user
     * @param id Alert Key
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAlert(id: string | null, forUserKey?: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAlertWithCallbacks(id, forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAlertWithCallbacks(id: string | null, forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteAlert(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("not allowed now", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("internal failure", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("key not found", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("key required", status, _responseText, _headers, result406);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class CatalogClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns a list of files or documents in the specified location
     * @param folderDesignation Catalog Folder ID (GUID or root)
     * @param catalogFilters Additional Filters, including ProjectLike, TitleLike (filename), ContainsText, HasHash, DocNoLike, ForDocType, PrimaryDateRange, RefDateRange; seldom used: UserKey, FileKey, DocMasterKey (attached to), MaxItems, TimeoutFactor
     */
    getFolderContents(folderDesignation: string | null, catalogFilters: QueryFilters) {
        return new Promise<FileInformation[] | null>((resolve, reject) => {
            this.getFolderContentsWithCallbacks(folderDesignation, catalogFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFolderContentsWithCallbacks(folderDesignation: string | null, catalogFilters: QueryFilters, onSuccess?: (result: FileInformation[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderDesignation}/contents";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(catalogFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFolderContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderContentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFolderContents(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFolderContents(xhr: any): FileInformation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileInformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns settings for a preset search
     * @param setID Set ID
     */
    getPresetSearch(setID: string | null) {
        return new Promise<CatalogPreset | null>((resolve, reject) => {
            this.getPresetSearchWithCallbacks(setID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getPresetSearchWithCallbacks(setID: string | null, onSuccess?: (result: CatalogPreset | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/presets/{setID}";
        if (setID === undefined || setID === null)
            throw new Error("The parameter 'setID' must be defined.");
        url_ = url_.replace("{setID}", encodeURIComponent("" + setID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetPresetSearchWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetPresetSearchWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetPresetSearchWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetPresetSearch(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetPresetSearch(xhr: any): CatalogPreset | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CatalogPreset.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list of files and folders that match the criteria
     * @param folderDesignation Catalog Folder ID (GUID or ROOT)
     * @param catalogFilters Additional Filters, including ProjectLike, TitleLike (filename), ContainsText, HasHash, DocNoLike, ForDocType, PrimaryDateRange, RefDateRange; seldom used: UserKey, FileKey, DocMasterKey (attached to), MaxItems, TimeoutFactor
     */
    searchContents(folderDesignation: string | null, catalogFilters: QueryFilters) {
        return new Promise<FileInformation[] | null>((resolve, reject) => {
            this.searchContentsWithCallbacks(folderDesignation, catalogFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private searchContentsWithCallbacks(folderDesignation: string | null, catalogFilters: QueryFilters, onSuccess?: (result: FileInformation[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/search/{folderDesignation}/contents";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(catalogFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processSearchContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSearchContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processSearchContentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processSearchContents(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processSearchContents(xhr: any): FileInformation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("catalogFilters.TitleLike requires a value", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileInformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns changes to the list of files and folders that match the criteria
     * @param folderDesignation Catalog Folder ID (GUID or ROOT)
     * @param catalogFilters ClientDataSummary (of FileKey and eTags) and Additional Filters, including ProjectLike, TitleLike (filename), ContainsText, HasHash, DocNoLike, ForDocType, PrimaryDateRange, RefDateRange; seldom used: UserKey, FileKey, DocMasterKey (attached to), MaxItems, TimeoutFactor
     */
    getChangedSearchContents(folderDesignation: string | null, catalogFilters: QueryFilters) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedSearchContentsWithCallbacks(folderDesignation, catalogFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedSearchContentsWithCallbacks(folderDesignation: string | null, catalogFilters: QueryFilters, onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/search/{folderDesignation}/changes";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(catalogFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedSearchContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedSearchContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedSearchContentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetChangedSearchContents(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedSearchContents(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("catalogFilters.TitleLike requires a value", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list of files in the specified location
     * @param folderDesignation Catalog Folder ID (GUID or root)
     * @param catalogFilters ClientDataSummary (of FileKey and eTags) and Additional Filters, including ProjectLike, TitleLike (filename), ContainsText, HasHash, DocNoLike, ForDocType, PrimaryDateRange, RefDateRange; seldom used: UserKey, FileKey, DocMasterKey (attached to), MaxItems, TimeoutFactor
     */
    getChangedFolderContents(folderDesignation: string | null, catalogFilters: QueryFilters) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedFolderContentsWithCallbacks(folderDesignation, catalogFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedFolderContentsWithCallbacks(folderDesignation: string | null, catalogFilters: QueryFilters, onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderDesignation}/changes";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(catalogFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedFolderContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedFolderContentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedFolderContentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetChangedFolderContents(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedFolderContents(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the tree Of folders
     */
    getFolderTree() {
        return new Promise<FileInformation[] | null>((resolve, reject) => {
            this.getFolderTreeWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFolderTreeWithCallbacks(onSuccess?: (result: FileInformation[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/tree";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFolderTreeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderTreeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderTreeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFolderTree(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFolderTree(xhr: any): FileInformation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileInformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the fake utilization stats
     */
    getStats() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getStatsWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getStatsWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/stats";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetStatsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetStatsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetStatsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetStats(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetStats(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the name Of the root folder
     */
    getRootFolderName() {
        return new Promise<any>((resolve, reject) => {
            this.getRootFolderNameWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRootFolderNameWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/root";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRootFolderNameWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRootFolderNameWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRootFolderNameWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRootFolderName(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRootFolderName(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns URI for appropriate icon
     * @param fileType File type such As PDF, DOCX, etc
     * @param iconSize (optional) 16,20,24,32 etc; small(20); big(32)
     */
    getIconForType(fileType: string | null, iconSize?: string | null | undefined) {
        return new Promise<any>((resolve, reject) => {
            this.getIconForTypeWithCallbacks(fileType, iconSize, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getIconForTypeWithCallbacks(fileType: string | null, iconSize: string | null | undefined, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/icon/{fileType}?";
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined.");
        url_ = url_.replace("{fileType}", encodeURIComponent("" + fileType));
        if (iconSize !== undefined && iconSize !== null)
            url_ += "iconSize=" + encodeURIComponent("" + iconSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetIconForTypeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetIconForTypeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetIconForTypeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetIconForType(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetIconForType(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns URI for appropriate icon for each file type
     * @param iconSize (optional) 16,20,24,32 etc; small(20); big(32)
     * @param eTag (optional) Returns nothing if eTag matches supplied eTag
     */
    getIconListByType(iconSize?: string | null | undefined, eTag?: string | null | undefined) {
        return new Promise<any>((resolve, reject) => {
            this.getIconListByTypeWithCallbacks(iconSize, eTag, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getIconListByTypeWithCallbacks(iconSize: string | null | undefined, eTag: string | null | undefined, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/icon/list?";
        if (iconSize !== undefined && iconSize !== null)
            url_ += "iconSize=" + encodeURIComponent("" + iconSize) + "&";
        if (eTag !== undefined && eTag !== null)
            url_ += "eTag=" + encodeURIComponent("" + eTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetIconListByTypeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetIconListByTypeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetIconListByTypeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetIconListByType(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetIconListByType(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result304 = resultData304 !== undefined ? resultData304 : <any>null;
    
            return throwException("No changes", status, _responseText, _headers, result304);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the meta data For a specific file utilization stats
     * @param fileKey Catalog File Key
     */
    getMeta(fileKey: string) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.getMetaWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMetaWithCallbacks(fileKey: string, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/meta";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMetaWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetMeta(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMeta(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list Of folders In the specified location
     * @param folderDesignation Catalog Folder ID (GUID Or root)
     */
    getFolderChildren(folderDesignation: string | null) {
        return new Promise<FileInformation[] | null>((resolve, reject) => {
            this.getFolderChildrenWithCallbacks(folderDesignation, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFolderChildrenWithCallbacks(folderDesignation: string | null, onSuccess?: (result: FileInformation[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderDesignation}/children";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFolderChildrenWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderChildrenWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderChildrenWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFolderChildren(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFolderChildren(xhr: any): FileInformation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileInformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a history Of access To the specified ID
     * @param fileKey Catalog File Key
     */
    getCatalogAccessHistory(fileKey: string) {
        return new Promise<FileAccessHistory[] | null>((resolve, reject) => {
            this.getCatalogAccessHistoryWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogAccessHistoryWithCallbacks(fileKey: string, onSuccess?: (result: FileAccessHistory[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/AccessHistory";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogAccessHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCatalogAccessHistory(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogAccessHistory(xhr: any): FileAccessHistory[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileAccessHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list Of versions For the specified ID
     * @param fileKey Catalog File Key
     */
    getCatalogVersions(fileKey: string) {
        return new Promise<FileVersion[] | null>((resolve, reject) => {
            this.getCatalogVersionsWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogVersionsWithCallbacks(fileKey: string, onSuccess?: (result: FileVersion[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/versions";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogVersionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCatalogVersions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogVersions(xhr: any): FileVersion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileVersion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Changes share state of file (check in/out, lock, etc
     * @param fileKey Catalog File Key
     * @param newStatus New Status O(ut);L(ock);U(nlock);I(n);X(cancel);SYS
     * @param expires (optional) When a checkout or lock expires
     */
    updateFileAccess(fileKey: string, newStatus: string | null, expires?: Date | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.updateFileAccessWithCallbacks(fileKey, newStatus, expires, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateFileAccessWithCallbacks(fileKey: string, newStatus: string | null, expires: Date | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/control?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (newStatus === undefined)
            throw new Error("The parameter 'newStatus' must be defined.");
        else if(newStatus !== null)
            url_ += "newStatus=" + encodeURIComponent("" + newStatus) + "&";
        if (expires === null)
            throw new Error("The parameter 'expires' cannot be null.");
        else if (expires !== undefined)
            url_ += "expires=" + encodeURIComponent(expires ? "" + expires.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateFileAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateFileAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateFileAccessWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateFileAccess(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateFileAccess(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a copy Of the specified file
     * @param fileKey Catalog File Key
     */
    copyFile(fileKey: string) {
        return new Promise<FileVersion | null>((resolve, reject) => {
            this.copyFileWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private copyFileWithCallbacks(fileKey: string, onSuccess?: (result: FileVersion | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/copy";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCopyFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCopyFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCopyFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCopyFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCopyFile(xhr: any): FileVersion | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = xhr.responseText;
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result501 = resultData501 !== undefined ? resultData501 : <any>null;
    
            return throwException("Feature Not implemented", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileVersion.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a New empty file
     * @param fileKey Parent Folder Key
     * @param fileName Parent Folder Key
     */
    addFileToFolder(fileKey: string, fileName: string | null) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.addFileToFolderWithCallbacks(fileKey, fileName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addFileToFolderWithCallbacks(fileKey: string, fileName: string | null, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{fileKey}/file/{fileName}";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddFileToFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddFileToFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddFileToFolderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddFileToFolder(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddFileToFolder(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = xhr.responseText;
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result501 = resultData501 !== undefined ? resultData501 : <any>null;
    
            return throwException("Feature Not Implemented", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Moves a file Or folder
     * @param folderKey Target Folder Key
     * @param existingKey Existing file Or folder key
     */
    moveIntoFolder(folderKey: string, existingKey: string) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.moveIntoFolderWithCallbacks(folderKey, existingKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private moveIntoFolderWithCallbacks(folderKey: string, existingKey: string, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderKey}/for/{existingKey}";
        if (folderKey === undefined || folderKey === null)
            throw new Error("The parameter 'folderKey' must be defined.");
        url_ = url_.replace("{folderKey}", encodeURIComponent("" + folderKey));
        if (existingKey === undefined || existingKey === null)
            throw new Error("The parameter 'existingKey' must be defined.");
        url_ = url_.replace("{existingKey}", encodeURIComponent("" + existingKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMoveIntoFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMoveIntoFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMoveIntoFolderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processMoveIntoFolder(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMoveIntoFolder(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = xhr.responseText;
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result501 = resultData501 !== undefined ? resultData501 : <any>null;
    
            return throwException("Feature Not Implemented", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates a New folder In the specified folder
     * @param folderDesignation Catalog Folder Key
     * @param folderName New Folder Name
     * @param newContainerKey (optional) Optional New Folder Key
     */
    addFolder(folderDesignation: string | null, folderName: string | null, newContainerKey?: string | null | undefined) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.addFolderWithCallbacks(folderDesignation, folderName, newContainerKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addFolderWithCallbacks(folderDesignation: string | null, folderName: string | null, newContainerKey: string | null | undefined, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderDesignation}/{folderName}?";
        if (folderDesignation === undefined || folderDesignation === null)
            throw new Error("The parameter 'folderDesignation' must be defined.");
        url_ = url_.replace("{folderDesignation}", encodeURIComponent("" + folderDesignation));
        if (folderName === undefined || folderName === null)
            throw new Error("The parameter 'folderName' must be defined.");
        url_ = url_.replace("{folderName}", encodeURIComponent("" + folderName));
        if (newContainerKey !== undefined && newContainerKey !== null)
            url_ += "newContainerKey=" + encodeURIComponent("" + newContainerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddFolderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddFolder(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddFolder(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = xhr.responseText;
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result501 = resultData501 !== undefined ? resultData501 : <any>null;
    
            return throwException("Feature Not Implemented", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Gets FileInformation for the specified Object
     * @param objectKey Catalog Object Key (can be a file Or folder key)
     */
    getObjectMeta(objectKey: string) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.getObjectMetaWithCallbacks(objectKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getObjectMetaWithCallbacks(objectKey: string, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/object/{objectKey}";
        if (objectKey === undefined || objectKey === null)
            throw new Error("The parameter 'objectKey' must be defined.");
        url_ = url_.replace("{objectKey}", encodeURIComponent("" + objectKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetObjectMetaWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetObjectMeta(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetObjectMeta(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the specified Object
     * @param objectKey Catalog Object Key (can be a file Or folder key)
     */
    deleteObject(objectKey: string) {
        return new Promise<any>((resolve, reject) => {
            this.deleteObjectWithCallbacks(objectKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteObjectWithCallbacks(objectKey: string, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/object/{objectKey}";
        if (objectKey === undefined || objectKey === null)
            throw new Error("The parameter 'objectKey' must be defined.");
        url_ = url_.replace("{objectKey}", encodeURIComponent("" + objectKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteObjectWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteObjectWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteObjectWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteObject(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteObject(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the meta properties Of the specified catalog Object, either file Or folder
     * @param newData New Object Meta Data, must include key
     */
    updateObjectMeta(newData: FileInformation) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.updateObjectMetaWithCallbacks(newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateObjectMetaWithCallbacks(newData: FileInformation, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/object";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateObjectMetaWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateObjectMeta(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateObjectMeta(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request Not consistent", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the specified entry on a catalog object
     * @param key File or Folder Key
     * @param fieldName Field Name
     * @param newValue Replacement Value
     */
    patchObjectMeta(key: string, fieldName: string | null, newValue: string) {
        return new Promise<any>((resolve, reject) => {
            this.patchObjectMetaWithCallbacks(key, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchObjectMetaWithCallbacks(key: string, fieldName: string | null, newValue: string, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/object/{key}/{fieldName}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchObjectMetaWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchObjectMetaWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchObjectMeta(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchObjectMeta(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified field not allowed ", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the specified folder
     * @param folderKey Catalog Folder Key
     */
    deleteFolder(folderKey: string) {
        return new Promise<any>((resolve, reject) => {
            this.deleteFolderWithCallbacks(folderKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteFolderWithCallbacks(folderKey: string, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderKey}";
        if (folderKey === undefined || folderKey === null)
            throw new Error("The parameter 'folderKey' must be defined.");
        url_ = url_.replace("{folderKey}", encodeURIComponent("" + folderKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteFolderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteFolderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteFolder(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteFolder(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a FileInformation model for the specified folder
     * @param folderKey Catalog Folder Key
     */
    getFolderInfo(folderKey: string) {
        return new Promise<FileInformation | null>((resolve, reject) => {
            this.getFolderInfoWithCallbacks(folderKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFolderInfoWithCallbacks(folderKey: string, onSuccess?: (result: FileInformation | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/folder/{folderKey}";
        if (folderKey === undefined || folderKey === null)
            throw new Error("The parameter 'folderKey' must be defined.");
        url_ = url_.replace("{folderKey}", encodeURIComponent("" + folderKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFolderInfoWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderInfoWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderInfoWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFolderInfo(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFolderInfo(xhr: any): FileInformation | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileInformation.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a redirect To load Or download the requested file
     * @param fileKey Catalog File Key
     * @param fileRev (optional) Specific Revision
     * @param withContentDisposition (optional) True For download (content-disposition), False For plain
     */
    getFile(fileKey: string, fileRev?: number | undefined, withContentDisposition?: boolean | undefined) {
        return new Promise<RedirectResult | null>((resolve, reject) => {
            this.getFileWithCallbacks(fileKey, fileRev, withContentDisposition, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFileWithCallbacks(fileKey: string, fileRev: number | undefined, withContentDisposition: boolean | undefined, onSuccess?: (result: RedirectResult | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/file?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (fileRev === null)
            throw new Error("The parameter 'fileRev' cannot be null.");
        else if (fileRev !== undefined)
            url_ += "fileRev=" + encodeURIComponent("" + fileRev) + "&";
        if (withContentDisposition === null)
            throw new Error("The parameter 'withContentDisposition' cannot be null.");
        else if (withContentDisposition !== undefined)
            url_ += "withContentDisposition=" + encodeURIComponent("" + withContentDisposition) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFile(xhr: any): RedirectResult | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RedirectResult.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a URI to load Or download the requested file
     * @param fileKey Catalog File Key
     * @param fileRev (optional) Specific Revision
     * @param withContentDisposition (optional) True For download (content-disposition), False For plain
     */
    getFileURL(fileKey: string, fileRev?: number | undefined, withContentDisposition?: boolean | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getFileURLWithCallbacks(fileKey, fileRev, withContentDisposition, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFileURLWithCallbacks(fileKey: string, fileRev: number | undefined, withContentDisposition: boolean | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/file/url?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (fileRev === null)
            throw new Error("The parameter 'fileRev' cannot be null.");
        else if (fileRev !== undefined)
            url_ += "fileRev=" + encodeURIComponent("" + fileRev) + "&";
        if (withContentDisposition === null)
            throw new Error("The parameter 'withContentDisposition' cannot be null.");
        else if (withContentDisposition !== undefined)
            url_ += "withContentDisposition=" + encodeURIComponent("" + withContentDisposition) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFileURLWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFileURLWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFileURLWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFileURL(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFileURL(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns key to a document intended to route this file for approvals
     * @param fileKey Catalog File Key
     */
    getFileRouter(fileKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.getFileRouterWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFileRouterWithCallbacks(fileKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/router";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFileRouterWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFileRouterWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFileRouterWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFileRouter(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFileRouter(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a redirect To load Or download the requested file
     * @param fileKey Catalog File Key
     * @param width Width
     * @param height Height; either width or height can be zero for a proportional aspect ratio
     * @param fileRev (optional) Specific Revision
     */
    getFilePreview(fileKey: string, width: number, height: number, fileRev?: number | undefined) {
        return new Promise<RedirectResult | null>((resolve, reject) => {
            this.getFilePreviewWithCallbacks(fileKey, width, height, fileRev, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFilePreviewWithCallbacks(fileKey: string, width: number, height: number, fileRev: number | undefined, onSuccess?: (result: RedirectResult | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/preview?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined and cannot be null.");
        else
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined and cannot be null.");
        else
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (fileRev === null)
            throw new Error("The parameter 'fileRev' cannot be null.");
        else if (fileRev !== undefined)
            url_ += "fileRev=" + encodeURIComponent("" + fileRev) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFilePreviewWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFilePreviewWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFilePreviewWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFilePreview(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFilePreview(xhr: any): RedirectResult | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RedirectResult.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a URI to download the requested file preview
     * @param fileKey Catalog File Key
     * @param width Width
     * @param height Height; either width or height can be zero for a proportional aspect ratio
     * @param fileRev (optional) Specific Revision
     */
    getFilePreviewURL(fileKey: string, width: number, height: number, fileRev?: number | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getFilePreviewURLWithCallbacks(fileKey, width, height, fileRev, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFilePreviewURLWithCallbacks(fileKey: string, width: number, height: number, fileRev: number | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{fileKey}/preview/url?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined.");
        url_ = url_.replace("{fileKey}", encodeURIComponent("" + fileKey));
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined and cannot be null.");
        else
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined and cannot be null.");
        else
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (fileRev === null)
            throw new Error("The parameter 'fileRev' cannot be null.");
        else if (fileRev !== undefined)
            url_ += "fileRev=" + encodeURIComponent("" + fileRev) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFilePreviewURLWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFilePreviewURLWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFilePreviewURLWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFilePreviewURL(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFilePreviewURL(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated Or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document Not found, Or Not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a key for a file upload stream.  You can discard the key.  The meta data is held in the user session based on a hash of the file name
     * @param fileInfo meta data
     */
    beginUpload(fileInfo: FileInformation) {
        return new Promise<{ [key: string]: string; } | null>((resolve, reject) => {
            this.beginUploadWithCallbacks(fileInfo, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private beginUploadWithCallbacks(fileInfo: FileInformation, onSuccess?: (result: { [key: string]: string; } | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/stream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileInfo);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processBeginUploadWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processBeginUploadWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processBeginUploadWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processBeginUpload(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processBeginUpload(xhr: any): { [key: string]: string; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Accepts file upload in chunks.  Compatible with https://github.com/blueimp/jQuery-File-Upload
     */
    uploadChunk() {
        return new Promise<XferFilesStatus[] | null>((resolve, reject) => {
            this.uploadChunkWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private uploadChunkWithCallbacks(onSuccess?: (result: XferFilesStatus[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/stream/chunk";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUploadChunkWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUploadChunkWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUploadChunkWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUploadChunk(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUploadChunk(xhr: any): XferFilesStatus[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Not a valid request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(XferFilesStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Accepts meta data and a small file upload in a single request
     */
    uploadFile() {
        return new Promise<XferFilesStatus | null>((resolve, reject) => {
            this.uploadFileWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private uploadFileWithCallbacks(onSuccess?: (result: XferFilesStatus | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/upload";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUploadFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUploadFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUploadFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUploadFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUploadFile(xhr: any): XferFilesStatus | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result401);

        } else if (status === 415) {
            const _responseText = xhr.responseText;
            let result415: any = null;
            let resultData415 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result415 = resultData415 !== undefined ? resultData415 : <any>null;
    
            return throwException("Requires Multipart Content, meta data then file data", status, _responseText, _headers, result415);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? XferFilesStatus.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the specified file
     * @param iD Catalog File Key
     * @param fileRev (optional) Specific Revision or zero (default) to delete the file
     */
    deleteFile(iD: string, fileRev?: number | undefined) {
        return new Promise<any>((resolve, reject) => {
            this.deleteFileWithCallbacks(iD, fileRev, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteFileWithCallbacks(iD: string, fileRev: number | undefined, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}?";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        if (fileRev === null)
            throw new Error("The parameter 'fileRev' cannot be null.");
        else if (fileRev !== undefined)
            url_ += "fileRev=" + encodeURIComponent("" + fileRev) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteFile(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Fetch!", status, _responseText, _headers, result302);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectDocListClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns a summary of document processes on a project
     * @param projectID Full Project ID
     */
    getProjectDocSummary(projectID: string | null) {
        return new Promise<TypeSummary[] | null>((resolve, reject) => {
            this.getProjectDocSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocSummaryWithCallbacks(projectID: string | null, onSuccess?: (result: TypeSummary[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/TypeSummary";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectDocSummary(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocSummary(xhr: any): TypeSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("You do not have the required Permission", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns full list of documents on a project that match the requested document type
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     */
    getProjectDocList(projectID: string | null, forDocType: string) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.getProjectDocListWithCallbacks(projectID, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocListWithCallbacks(projectID: string | null, forDocType: string, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectDocList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match filters <b>INCOMPLETE</b>
     */
    matchingProjectDocList(projectID: string | null, usingFilters: QueryFilters) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.matchingProjectDocListWithCallbacks(projectID, usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingProjectDocListWithCallbacks(projectID: string | null, usingFilters: QueryFilters, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processMatchingProjectDocList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents data that has changed
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     * @param dataSummary KVP of current row keys and etags
     */
    getChangedDocList(projectID: string | null, forDocType: string, dataSummary: CurrentDataSummary[]) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedDocListWithCallbacks(projectID, forDocType, dataSummary, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedDocListWithCallbacks(projectID: string | null, forDocType: string, dataSummary: CurrentDataSummary[], onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs/changes?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataSummary);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetChangedDocList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedDocList(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ExcelToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns a financial snapshot
     * @param id Key of snapshot document
     */
    getSnapshot(id: string | null) {
        return new Promise<ProjectSnapshot[] | null>((resolve, reject) => {
            this.getSnapshotWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSnapshotWithCallbacks(id: string | null, onSuccess?: (result: ProjectSnapshot[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/bfa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSnapshotWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSnapshotWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSnapshotWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSnapshot(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSnapshot(xhr: any): ProjectSnapshot[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSnapshot.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns line by line changes since the specified financial snapshot
     * @param id Key of snapshot document
     */
    getBFAAChanges(id: string | null) {
        return new Promise<ProjectSnapshotDelta[] | null>((resolve, reject) => {
            this.getBFAAChangesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getBFAAChangesWithCallbacks(id: string | null, onSuccess?: (result: ProjectSnapshotDelta[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/bfa/{id}/changes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetBFAAChangesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetBFAAChangesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetBFAAChangesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetBFAAChanges(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetBFAAChanges(xhr: any): ProjectSnapshotDelta[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSnapshotDelta.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns line by line changes since the specified financial snapshot
     * @param id Key of snapshot document
     */
    applyBFAAChangesToPTD(id: string | null) {
        return new Promise<ProjectSnapshotDelta[] | null>((resolve, reject) => {
            this.applyBFAAChangesToPTDWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private applyBFAAChangesToPTDWithCallbacks(id: string | null, onSuccess?: (result: ProjectSnapshotDelta[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/bfa/{id}/ptd";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processApplyBFAAChangesToPTDWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processApplyBFAAChangesToPTDWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processApplyBFAAChangesToPTDWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processApplyBFAAChangesToPTD(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processApplyBFAAChangesToPTD(xhr: any): ProjectSnapshotDelta[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSnapshotDelta.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general context information
     * @param id Key of BFA document or project ID
     */
    getBFAAbstract(id: string | null) {
        return new Promise<BFAAbstract | null>((resolve, reject) => {
            this.getBFAAbstractWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getBFAAbstractWithCallbacks(id: string | null, onSuccess?: (result: BFAAbstract | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/bfa/{id}/abstract";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetBFAAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetBFAAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetBFAAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetBFAAbstract(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetBFAAbstract(xhr: any): BFAAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BFAAbstract.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general context information
     * @param id Key of SOV document
     */
    getSOVAbstract(id: string) {
        return new Promise<SOVAbstract | null>((resolve, reject) => {
            this.getSOVAbstractWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSOVAbstractWithCallbacks(id: string, onSuccess?: (result: SOVAbstract | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/sov/{id}/abstract";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSOVAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSOVAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSOVAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSOVAbstract(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSOVAbstract(xhr: any): SOVAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SOVAbstract.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general context information
     * @param id Key of Period Distribution document
     */
    getPeriodDistribAbstract(id: string) {
        return new Promise<PeriodDistributionAbstract | null>((resolve, reject) => {
            this.getPeriodDistribAbstractWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getPeriodDistribAbstractWithCallbacks(id: string, onSuccess?: (result: PeriodDistributionAbstract | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/distribution/{id}/abstract";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetPeriodDistribAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetPeriodDistribAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetPeriodDistribAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetPeriodDistribAbstract(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetPeriodDistribAbstract(xhr: any): PeriodDistributionAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PeriodDistributionAbstract.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns List of Vendor Names and amounts, enumerating vendors paid on the project during the specified date range
     * @param id Key of SOV document
     * @param startDate (optional) Start of date range for vendor payment amounts
     * @param endDate (optional) End of date range for vendor payment amounts
     */
    createVendorWaiversForSOV(id: string, startDate?: Date | undefined, endDate?: Date | undefined) {
        return new Promise<{ [key: string]: string; } | null>((resolve, reject) => {
            this.createVendorWaiversForSOVWithCallbacks(id, startDate, endDate, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createVendorWaiversForSOVWithCallbacks(id: string, startDate: Date | undefined, endDate: Date | undefined, onSuccess?: (result: { [key: string]: string; } | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/sov/waivers/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateVendorWaiversForSOVWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateVendorWaiversForSOVWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateVendorWaiversForSOVWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateVendorWaiversForSOV(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateVendorWaiversForSOV(xhr: any): { [key: string]: string; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request not valid", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a background task ID
     * @param exportFrom part name for export
     * @param exportRequest specifics for export requested
     */
    postExcelExport(exportFrom: string | null, exportRequest: ExportRequest) {
        return new Promise<string>((resolve, reject) => {
            this.postExcelExportWithCallbacks(exportFrom, exportRequest, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postExcelExportWithCallbacks(exportFrom: string | null, exportRequest: ExportRequest, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/export/{exportFrom}";
        if (exportFrom === undefined || exportFrom === null)
            throw new Error("The parameter 'exportFrom' must be defined.");
        url_ = url_.replace("{exportFrom}", encodeURIComponent("" + exportFrom));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(exportRequest);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostExcelExportWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostExcelExportWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostExcelExportWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostExcelExport(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostExcelExport(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a background task ID
     * @param templateID Template ID
     * @param dataContext Data Context
     */
    getCobraExport(templateID: string | null, dataContext: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.getCobraExportWithCallbacks(templateID, dataContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCobraExportWithCallbacks(templateID: string | null, dataContext: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/export/cobra?";
        if (templateID === undefined)
            throw new Error("The parameter 'templateID' must be defined.");
        else if(templateID !== null)
            url_ += "templateID=" + encodeURIComponent("" + templateID) + "&";
        if (dataContext === undefined)
            throw new Error("The parameter 'dataContext' must be defined.");
        else if(dataContext !== null)
            url_ += "dataContext=" + encodeURIComponent("" + dataContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCobraExportWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCobraExportWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCobraExportWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCobraExport(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCobraExport(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a background task ID
     * @param fileKey Catalog File Key
     */
    postContactImport(fileKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.postContactImportWithCallbacks(fileKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postContactImportWithCallbacks(fileKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/import/contacts?";
        if (fileKey === undefined || fileKey === null)
            throw new Error("The parameter 'fileKey' must be defined and cannot be null.");
        else
            url_ += "fileKey=" + encodeURIComponent("" + fileKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostContactImportWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostContactImportWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostContactImportWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostContactImport(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostContactImport(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("id not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UICFGClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param partName Part Name
     * @param forDocType (optional) optional document type (GUID format)
     * @param forProject (optional) specific project ID
     * @param forContext (optional) optional context (subtype, container, etc)
     */
    getLiveDisplay(partName: string | null, forDocType?: string | null | undefined, forProject?: string | null | undefined, forContext?: string | null | undefined) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLiveDisplayWithCallbacks(partName, forDocType, forProject, forContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLiveDisplayWithCallbacks(partName: string | null, forDocType: string | null | undefined, forProject: string | null | undefined, forContext: string | null | undefined, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/live/{partName}?";
        if (partName === undefined || partName === null)
            throw new Error("The parameter 'partName' must be defined.");
        url_ = url_.replace("{partName}", encodeURIComponent("" + partName));
        if (forDocType !== undefined && forDocType !== null)
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        if (forProject !== undefined && forProject !== null)
            url_ += "forProject=" + encodeURIComponent("" + forProject) + "&";
        if (forContext !== undefined && forContext !== null)
            url_ += "forContext=" + encodeURIComponent("" + forContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLiveDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetLiveDisplay(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLiveDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Store updated UI CFG data for the specified part
     * @param partName Part Name
     * @param forDocType document type (GUID format Or 1)
     * @param forContext context (subtype, container, etc, Or 0)
     * @param cFGData CFG Records
     */
    storePartUICFG(partName: string | null, forDocType: string | null, forContext: string | null, cFGData: UIDisplayConfig[]) {
        return new Promise<void>((resolve, reject) => {
            this.storePartUICFGWithCallbacks(partName, forDocType, forContext, cFGData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private storePartUICFGWithCallbacks(partName: string | null, forDocType: string | null, forContext: string | null, cFGData: UIDisplayConfig[], onSuccess?: (result: void) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/live/{partName}/{forDocType}/{forContext}";
        if (partName === undefined || partName === null)
            throw new Error("The parameter 'partName' must be defined.");
        url_ = url_.replace("{partName}", encodeURIComponent("" + partName));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined.");
        url_ = url_.replace("{forDocType}", encodeURIComponent("" + forDocType));
        if (forContext === undefined || forContext === null)
            throw new Error("The parameter 'forContext' must be defined.");
        url_ = url_.replace("{forContext}", encodeURIComponent("" + forContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cFGData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
            }
        }).done((_data, _textStatus, xhr) => {
            this.processStorePartUICFGWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processStorePartUICFGWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processStorePartUICFGWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processStorePartUICFG(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processStorePartUICFG(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("internal failure", status, _responseText, _headers, result500);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("lacks permission", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Returns Live UI CFG data for this user for the requested lookup
     * @param lookupName Lookup Name
     */
    getLookupDisplay(lookupName: string | null) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLookupDisplayWithCallbacks(lookupName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupDisplayWithCallbacks(lookupName: string | null, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/lookup/{lookupName}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetLookupDisplay(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResult(ruleName: string | null, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: string | null | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getRuleResultWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultWithCallbacks(ruleName: string | null, testValue: string | null, filterValue: string | null | undefined, defaultValue: string | null | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/string?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue !== undefined && defaultValue !== null)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRuleResult(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResult(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResultAsBoolean(ruleName: string | null, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: boolean | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.getRuleResultAsBooleanWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultAsBooleanWithCallbacks(ruleName: string | null, testValue: string | null, filterValue: string | null | undefined, defaultValue: boolean | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/boolean?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue === null)
            throw new Error("The parameter 'defaultValue' cannot be null.");
        else if (defaultValue !== undefined)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultAsBooleanWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultAsBooleanWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultAsBooleanWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRuleResultAsBoolean(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResultAsBoolean(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResultAsNumber(ruleName: string | null, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: number | undefined) {
        return new Promise<number>((resolve, reject) => {
            this.getRuleResultAsNumberWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultAsNumberWithCallbacks(ruleName: string | null, testValue: string | null, filterValue: string | null | undefined, defaultValue: number | undefined, onSuccess?: (result: number) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/integer?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue === null)
            throw new Error("The parameter 'defaultValue' cannot be null.");
        else if (defaultValue !== undefined)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultAsNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultAsNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultAsNumberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRuleResultAsNumber(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResultAsNumber(xhr: any): number | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class LookupClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param filterValues Optional nvp list of filter and dependsOn values
     */
    getLookupResultAll(lookupName: string | null, dataContext: string | null, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultAllWithCallbacks(lookupName, dataContext, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultAllWithCallbacks(lookupName: string | null, dataContext: string | null, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetLookupResultAll(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResultAll(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Specified context not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns result of query given specified context
     * @param dataContext Data Set ID or 1
     * @param project Project ID (or 0 for none; 1 for from context)
     * @param id GUID key or 0 for none; 1 for from context
     * @param dtk (optional) GUID process type or omit or 0 for none; 1 from context
     * @param depends1 (optional) optional additional context for query
     * @param depends2 (optional) Optional additional context for query
     * @param depends3 (optional) Optional additional context for query
     * @param depends4 (optional) Optional additional context for query
     */
    getQueryResult(queryName: string | null, dataContext: string | null, project: string | null, id: string | null, dtk?: string | null | undefined, depends1?: string | null | undefined, depends2?: string | null | undefined, depends3?: string | null | undefined, depends4?: string | null | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getQueryResultWithCallbacks(queryName, dataContext, project, id, dtk, depends1, depends2, depends3, depends4, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getQueryResultWithCallbacks(queryName: string | null, dataContext: string | null, project: string | null, id: string | null, dtk: string | null | undefined, depends1: string | null | undefined, depends2: string | null | undefined, depends3: string | null | undefined, depends4: string | null | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/query/{queryName}/{dataContext}/{project}/{id}?";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (project === undefined || project === null)
            throw new Error("The parameter 'project' must be defined.");
        url_ = url_.replace("{project}", encodeURIComponent("" + project));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dtk !== undefined && dtk !== null)
            url_ += "dtk=" + encodeURIComponent("" + dtk) + "&";
        if (depends1 !== undefined && depends1 !== null)
            url_ += "depends1=" + encodeURIComponent("" + depends1) + "&";
        if (depends2 !== undefined && depends2 !== null)
            url_ += "depends2=" + encodeURIComponent("" + depends2) + "&";
        if (depends3 !== undefined && depends3 !== null)
            url_ += "depends3=" + encodeURIComponent("" + depends3) + "&";
        if (depends4 !== undefined && depends4 !== null)
            url_ += "depends4=" + encodeURIComponent("" + depends4) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetQueryResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetQueryResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetQueryResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetQueryResult(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetQueryResult(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns result of query given specified context
     * @param dataContext Data Set ID or 1
     * @param queryContext ProjectLike (or 0 for none; 1 for from context; or specific); depends1-4
     * @param id (optional) GUID key or 0 for none; 1 for from context
     * @param dtk (optional) GUID process type or omit or 0 for none; 1 from context
     */
    getQueryResultWithContext(queryName: string | null, dataContext: string | null, queryContext: QueryFilters, id?: string | null | undefined, dtk?: string | null | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getQueryResultWithContextWithCallbacks(queryName, dataContext, queryContext, id, dtk, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getQueryResultWithContextWithCallbacks(queryName: string | null, dataContext: string | null, queryContext: QueryFilters, id: string | null | undefined, dtk: string | null | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/query/{queryName}/{dataContext}?";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (dtk !== undefined && dtk !== null)
            url_ += "dtk=" + encodeURIComponent("" + dtk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryContext);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetQueryResultWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetQueryResultWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetQueryResultWithContextWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetQueryResultWithContext(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetQueryResultWithContext(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Query Failed", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of prior values for this field
     * @param dataMember Name of table
     * @param dataField Name of field
     * @param rowKey PK identifier of specific record
     * @param sinceWhen (optional) Optional date since when data should be returned
     */
    getFieldHistory(dataMember: string | null, dataField: string | null, rowKey: string, sinceWhen?: Date | undefined) {
        return new Promise<FieldAudit[] | null>((resolve, reject) => {
            this.getFieldHistoryWithCallbacks(dataMember, dataField, rowKey, sinceWhen, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getFieldHistoryWithCallbacks(dataMember: string | null, dataField: string | null, rowKey: string, sinceWhen: Date | undefined, onSuccess?: (result: FieldAudit[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/history/{dataMember}/{dataField}/{rowKey}?";
        if (dataMember === undefined || dataMember === null)
            throw new Error("The parameter 'dataMember' must be defined.");
        url_ = url_.replace("{dataMember}", encodeURIComponent("" + dataMember));
        if (dataField === undefined || dataField === null)
            throw new Error("The parameter 'dataField' must be defined.");
        url_ = url_.replace("{dataField}", encodeURIComponent("" + dataField));
        if (rowKey === undefined || rowKey === null)
            throw new Error("The parameter 'rowKey' must be defined.");
        url_ = url_.replace("{rowKey}", encodeURIComponent("" + rowKey));
        if (sinceWhen === null)
            throw new Error("The parameter 'sinceWhen' cannot be null.");
        else if (sinceWhen !== undefined)
            url_ += "sinceWhen=" + encodeURIComponent(sinceWhen ? "" + sinceWhen.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetFieldHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFieldHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetFieldHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetFieldHistory(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetFieldHistory(xhr: any): FieldAudit[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldAudit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of alerts that are recorded about the specified source key
     * @param key PK identifier of specific source key
     */
    getAlertsForSourceKey(key: string) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getAlertsForSourceKeyWithCallbacks(key, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getAlertsForSourceKeyWithCallbacks(key: string, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/alerts/source/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetAlertsForSourceKeyWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAlertsForSourceKeyWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetAlertsForSourceKeyWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetAlertsForSourceKey(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetAlertsForSourceKey(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param term (optional) Optional Partial match term to filter suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestionsAll(lookupName: string | null, dataContext: string | null, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsAllWithCallbacks(lookupName, dataContext, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsAllWithCallbacks(lookupName: string | null, dataContext: string | null, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSuggestionsAll(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsAll(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to filter suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions(lookupName: string | null, dataContext: string | null, depends1: string | null, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithCallbacks(lookupName, dataContext, depends1, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithCallbacks(lookupName: string | null, dataContext: string | null, depends1: string | null, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSuggestions(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to filter suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions2(lookupName: string | null, dataContext: string | null, depends1: string | null, depends2: string | null, depends3: string | null, depends4: string | null, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions2WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions2WithCallbacks(lookupName: string | null, dataContext: string | null, depends1: string | null, depends2: string | null, depends3: string | null, depends4: string | null, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSuggestions2(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions2(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param sessionContext Session Context for Suggestions, use 1 for default
     * @param searchContext Search Context for Suggestions (depends on list, seed, limit)
     */
    getSuggestionsWithContext(lookupName: string | null, sessionContext: string | null, searchContext: QueryFilters) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithContextWithCallbacks(lookupName, sessionContext, searchContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithContextWithCallbacks(lookupName: string | null, sessionContext: string | null, searchContext: QueryFilters, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{sessionContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (sessionContext === undefined || sessionContext === null)
            throw new Error("The parameter 'sessionContext' must be defined.");
        url_ = url_.replace("{sessionContext}", encodeURIComponent("" + sessionContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchContext);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithContextWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSuggestionsWithContext(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsWithContext(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a single viewable/printable value matching the request.  Use 'empty' to include a blank depends-on value.
     * @param displayName Name of Display Rule
     * @param valueFor Value to be described {MatchingSeed:'pv',DependsOn:['1','2','3','4']}
     * @param dataContext (optional) Context for Suggestions, use 1 for default
     */
    getDisplayableValue(displayName: string | null, valueFor: DVRequest, dataContext?: string | null | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDisplayableValueWithCallbacks(displayName, valueFor, dataContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayableValueWithCallbacks(displayName: string | null, valueFor: DVRequest, dataContext: string | null | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}?";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext !== undefined && dataContext !== null)
            url_ += "dataContext=" + encodeURIComponent("" + dataContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(valueFor);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayableValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayableValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayableValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDisplayableValue(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayableValue(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Requested context not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Flushes viewable/printable value from cache forcing refresh on next request
     * @param displayName Name of Display Rule
     * @param valueFor Value to be re-described {MatchingSeed:'pv',DependsOn:['1','2','3','4']}
     * @param dataContext (optional) Context, use 1 for default
     */
    removeDisplayableValue(displayName: string | null, valueFor: DVRequest, dataContext?: string | null | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.removeDisplayableValueWithCallbacks(displayName, valueFor, dataContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private removeDisplayableValueWithCallbacks(displayName: string | null, valueFor: DVRequest, dataContext: string | null | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}?";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext !== undefined && dataContext !== null)
            url_ += "dataContext=" + encodeURIComponent("" + dataContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(valueFor);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processRemoveDisplayableValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRemoveDisplayableValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processRemoveDisplayableValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processRemoveDisplayableValue(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processRemoveDisplayableValue(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Requested context not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns set of viewable/printable values
     * @param dvRequests List of requests
     */
    getDisplayValueCollection(dvRequests: DVRequest[]) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getDisplayValueCollectionWithCallbacks(dvRequests, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayValueCollectionWithCallbacks(dvRequests: DVRequest[], onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/collection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dvRequests);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayValueCollectionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayValueCollectionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayValueCollectionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetDisplayValueCollection(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayValueCollection(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Requested context not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Malformed request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of choices for a specified context
     * @param setName Name of Code Set
     * @param forDocType Document / Process Context for choices, use 1 for default
     */
    getCodeChoices(setName: string | null, forDocType: string | null) {
        return new Promise<CodeChoice[] | null>((resolve, reject) => {
            this.getCodeChoicesWithCallbacks(setName, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCodeChoicesWithCallbacks(setName: string | null, forDocType: string | null, onSuccess?: (result: CodeChoice[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/choices/{setName}/{forDocType}";
        if (setName === undefined || setName === null)
            throw new Error("The parameter 'setName' must be defined.");
        url_ = url_.replace("{setName}", encodeURIComponent("" + setName));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined.");
        url_ = url_.replace("{forDocType}", encodeURIComponent("" + forDocType));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCodeChoicesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCodeChoices(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCodeChoices(xhr: any): CodeChoice[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeChoice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class XTSClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns list of peer tasks
     */
    getXTSQueue() {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getXTSQueueWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getXTSQueueWithCallbacks(onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/queue";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetXTSQueueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetXTSQueueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetXTSQueueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetXTSQueue(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetXTSQueue(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes a task
     */
    deleteXTSAction(actionKey: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteXTSActionWithCallbacks(actionKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteXTSActionWithCallbacks(actionKey: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/queue/{actionKey}";
        if (actionKey === undefined || actionKey === null)
            throw new Error("The parameter 'actionKey' must be defined.");
        url_ = url_.replace("{actionKey}", encodeURIComponent("" + actionKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteXTSActionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteXTSActionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteXTSActionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteXTSAction(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteXTSAction(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not configured", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Task not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Requests task to be run soon
     */
    rushXTSAction(actionKey: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.rushXTSActionWithCallbacks(actionKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private rushXTSActionWithCallbacks(actionKey: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/queue/{actionKey}";
        if (actionKey === undefined || actionKey === null)
            throw new Error("The parameter 'actionKey' must be defined.");
        url_ = url_.replace("{actionKey}", encodeURIComponent("" + actionKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processRushXTSActionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRushXTSActionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processRushXTSActionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processRushXTSAction(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processRushXTSAction(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not configured", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Task not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns state of ATC Service for ERP Actions
     */
    getXTSState() {
        return new Promise<string | null>((resolve, reject) => {
            this.getXTSStateWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getXTSStateWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/state";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetXTSStateWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetXTSStateWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetXTSStateWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetXTSState(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetXTSState(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of pending routing including outbound email and workflow
     */
    getRouteQueue() {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getRouteQueueWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRouteQueueWithCallbacks(onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/routing/queue";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRouteQueueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRouteQueueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRouteQueueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRouteQueue(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRouteQueue(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns point in time state of ATC routing
     */
    getRouteState() {
        return new Promise<string | null>((resolve, reject) => {
            this.getRouteStateWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRouteStateWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/routing/state";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRouteStateWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRouteStateWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRouteStateWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRouteState(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRouteState(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Receives a push notification from peer
     */
    xTSInbound(peer: string | null, peerVersion: string | null) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.xTSInboundWithCallbacks(peer, peerVersion, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private xTSInboundWithCallbacks(peer: string | null, peerVersion: string | null, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/inbound/{peer}/{peerVersion}";
        if (peer === undefined || peer === null)
            throw new Error("The parameter 'peer' must be defined.");
        url_ = url_.replace("{peer}", encodeURIComponent("" + peer));
        if (peerVersion === undefined || peerVersion === null)
            throw new Error("The parameter 'peerVersion' must be defined.");
        url_ = url_.replace("{peerVersion}", encodeURIComponent("" + peerVersion));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processXTSInboundWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processXTSInboundWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processXTSInboundWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processXTSInbound(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processXTSInbound(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Peer and message (body) both required", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not a valid peer", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Receives a push notification from peer
     */
    cloudSyncChange(peerVersion: string | null, peerDrive: string | null, payload: CloudChange[]) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.cloudSyncChangeWithCallbacks(peerVersion, peerDrive, payload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private cloudSyncChangeWithCallbacks(peerVersion: string | null, peerDrive: string | null, payload: CloudChange[], onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/xts/inbound/cloudSync/{peerVersion}/peerDrive?";
        if (peerVersion === undefined || peerVersion === null)
            throw new Error("The parameter 'peerVersion' must be defined.");
        url_ = url_.replace("{peerVersion}", encodeURIComponent("" + peerVersion));
        if (peerDrive === undefined)
            throw new Error("The parameter 'peerDrive' must be defined.");
        else if(peerDrive !== null)
            url_ += "peerDrive=" + encodeURIComponent("" + peerDrive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCloudSyncChangeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCloudSyncChangeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCloudSyncChangeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCloudSyncChange(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCloudSyncChange(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Peer and message (body) both required", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not a valid peer", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectKPIClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns list of KPI facts for the specified project
     * @param projectID Full Project ID
     */
    getProjectKPIFacts(projectID: string | null) {
        return new Promise<ProjKPIFact[] | null>((resolve, reject) => {
            this.getProjectKPIFactsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectKPIFactsWithCallbacks(projectID: string | null, onSuccess?: (result: ProjKPIFact[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/KPI";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectKPIFactsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectKPIFacts(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectKPIFacts(xhr: any): ProjKPIFact[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Access denied", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjKPIFact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectTeamClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns members of the specified project team
     * @param projectID Full Project ID
     * @param includeHidden True to include hidden team members
     */
    getProjectTeamList(projectID: string | null, includeHidden: boolean) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.getProjectTeamListWithCallbacks(projectID, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectTeamListWithCallbacks(projectID: string | null, includeHidden: boolean, onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectTeamListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectTeamList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectTeamList(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Lacks permission to see hidden team members", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds new team member(s) to the specified project.  Send collection of ProjectTeamMember, only value required is UserKey
     */
    addProjectTeamMembers(projectID: string | null, newUserData: ProjectTeamMember[]) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.addProjectTeamMembersWithCallbacks(projectID, newUserData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addProjectTeamMembersWithCallbacks(projectID: string | null, newUserData: ProjectTeamMember[], onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddProjectTeamMembersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddProjectTeamMembersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddProjectTeamMembersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddProjectTeamMembers(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddProjectTeamMembers(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the team member on the specified project
     * @param projectID Full Project ID
     * @param teamMemberKey Team Member Key (not the User Key)
     * @return Specified team member not found
     */
    deleteTeamMember(projectID: string | null, teamMemberKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteTeamMemberWithCallbacks(projectID, teamMemberKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteTeamMemberWithCallbacks(projectID: string | null, teamMemberKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{teamMemberKey}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (teamMemberKey === undefined || teamMemberKey === null)
            throw new Error("The parameter 'teamMemberKey' must be defined.");
        url_ = url_.replace("{teamMemberKey}", encodeURIComponent("" + teamMemberKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteTeamMember(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the team member on the specified project
     * @param projectID Project ID
     * @param teamMemberKey ID of team member entity to replace, not the UserKey.  When empty, taken from newData.UserProjectKey!
     * @param newData updated data for this entity
     * @return Specified team member not found
     */
    updateTeamMember(projectID: string | null, teamMemberKey: string, newData: ProjectTeamMember) {
        return new Promise<string>((resolve, reject) => {
            this.updateTeamMemberWithCallbacks(projectID, teamMemberKey, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateTeamMemberWithCallbacks(projectID: string | null, teamMemberKey: string, newData: ProjectTeamMember, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{teamMemberKey}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (teamMemberKey === undefined || teamMemberKey === null)
            throw new Error("The parameter 'teamMemberKey' must be defined.");
        url_ = url_.replace("{teamMemberKey}", encodeURIComponent("" + teamMemberKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateTeamMember(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Attempted to change read only data", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the team member on the specified project
     * @param projectID Project ID
     * @param userProjectTeamKey Key for Team Member Row
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified team member not found
     */
    patchProjectTeam(projectID: string | null, userProjectTeamKey: string, fieldName: string | null, newValue: string) {
        return new Promise<string>((resolve, reject) => {
            this.patchProjectTeamWithCallbacks(projectID, userProjectTeamKey, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchProjectTeamWithCallbacks(projectID: string | null, userProjectTeamKey: string, fieldName: string | null, newValue: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{userProjectTeamKey}/{fieldName}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (userProjectTeamKey === undefined || userProjectTeamKey === null)
            throw new Error("The parameter 'userProjectTeamKey' must be defined.");
        url_ = url_.replace("{userProjectTeamKey}", encodeURIComponent("" + userProjectTeamKey));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchProjectTeamWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchProjectTeamWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchProjectTeamWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchProjectTeam(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchProjectTeam(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified field invalid for team member", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Replaces the specified team member on a given project or projects that match the scope
     * @param projectID Project ID
     * @param fromUser ID of team member to replace
     * @param toUser ID of new team member
     * @param scope A project id mask or % for all
     * @return Specified team member not found
     */
    replaceTeamMember(projectID: string | null, fromUser: string, toUser: string, scope: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.replaceTeamMemberWithCallbacks(projectID, fromUser, toUser, scope, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private replaceTeamMemberWithCallbacks(projectID: string | null, fromUser: string, toUser: string, scope: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{fromUser}/{toUser}/{scope}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (fromUser === undefined || fromUser === null)
            throw new Error("The parameter 'fromUser' must be defined.");
        url_ = url_.replace("{fromUser}", encodeURIComponent("" + fromUser));
        if (toUser === undefined || toUser === null)
            throw new Error("The parameter 'toUser' must be defined.");
        url_ = url_.replace("{toUser}", encodeURIComponent("" + toUser));
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReplaceTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReplaceTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReplaceTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processReplaceTeamMember(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReplaceTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the update", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns projects that match User and hidden filter
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param includeHidden True to include hidden projects in the result
     */
    getList(forUserKey: string, includeHidden: boolean) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getListWithCallbacks(forUserKey, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getListWithCallbacks(forUserKey: string, includeHidden: boolean, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that match User, Program, hidden filter
     */
    getMatchingList(usingFilters: QueryFilters) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getMatchingListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingListWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetMatchingList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project list data that has changed
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param includeHidden True to include hidden projects in the result
     * @param dataSummary KVP of current row keys (UserProjectKey) and etags
     */
    getChangedProjectItems(forUserKey: string, includeHidden: boolean, dataSummary: CurrentDataSummary[]) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedProjectItemsWithCallbacks(forUserKey, includeHidden, dataSummary, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedProjectItemsWithCallbacks(forUserKey: string, includeHidden: boolean, dataSummary: CurrentDataSummary[], onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects/changes?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataSummary);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedProjectItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedProjectItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedProjectItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetChangedProjectItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedProjectItems(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Requests executive summary data matching filters.  Use SessionController to check task and retrieve result
     */
    exportExecutiveData(usingFilters: QueryFilters) {
        return new Promise<string>((resolve, reject) => {
            this.exportExecutiveDataWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private exportExecutiveDataWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects/executive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processExportExecutiveDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processExportExecutiveDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processExportExecutiveDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processExportExecutiveData(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processExportExecutiveData(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the specified entry on the user project list
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param projectID Project ID or UserProjectKey
     * @param fieldName Field Name
     * @param newValue Replacement Value
     */
    patchUserProjectList(forUserKey: string, projectID: string | null, fieldName: string | null, newValue: string | null) {
        return new Promise<any>((resolve, reject) => {
            this.patchUserProjectListWithCallbacks(forUserKey, projectID, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserProjectListWithCallbacks(forUserKey: string, projectID: string | null, fieldName: string | null, newValue: string | null, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects/list/{forUserKey}/{projectID}/{fieldName}?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined.");
        url_ = url_.replace("{forUserKey}", encodeURIComponent("" + forUserKey));
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserProjectListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserProjectListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserProjectListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchUserProjectList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserProjectList(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Specified field invalid ", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class SessionClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns nice fresh GUID(s) / UUID
     * @param count Number of GUIDs to return, max is 9
     */
    getNewGuid(count: number) {
        return new Promise<string[] | null>((resolve, reject) => {
            this.getNewGuidWithCallbacks(count, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getNewGuidWithCallbacks(count: number, onSuccess?: (result: string[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/guid/{count}";
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetNewGuidWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetNewGuidWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetNewGuidWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetNewGuid(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetNewGuid(xhr: any): string[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of documents recently accessed by this user
     */
    getRecentDocs() {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getRecentDocsWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRecentDocsWithCallbacks(onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/recent/docs";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRecentDocsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRecentDocsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRecentDocsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRecentDocs(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRecentDocs(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of reports of report groups accessible to this user
     */
    getReportMenu(groupId: string | null) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getReportMenuWithCallbacks(groupId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getReportMenuWithCallbacks(groupId: string | null, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/reports/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetReportMenuWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetReportMenuWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetReportMenuWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetReportMenu(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetReportMenu(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of reports of report groups accessible to this user
     */
    getMenu(menuId: string | null) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getMenuWithCallbacks(menuId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMenuWithCallbacks(menuId: string | null, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/menu/{menuId}";
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined.");
        url_ = url_.replace("{menuId}", encodeURIComponent("" + menuId));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMenuWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMenuWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMenuWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetMenu(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMenu(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Menu ID Not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * returns magic number that allows client to know if its nonvolatile data is up-to-date
     */
    getLVDataMagicNumber() {
        return new Promise<string | null>((resolve, reject) => {
            this.getLVDataMagicNumberWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLVDataMagicNumberWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/nonvolatile/eTag";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLVDataMagicNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLVDataMagicNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLVDataMagicNumberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetLVDataMagicNumber(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLVDataMagicNumber(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * returns true if user has document open in this session
     * @param id key of document
     */
    getUsingThisDocument(id: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.getUsingThisDocumentWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUsingThisDocumentWithCallbacks(id: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/using/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUsingThisDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUsingThisDocumentWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUsingThisDocumentWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetUsingThisDocument(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUsingThisDocument(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns this users permission flags for a specific capability and context.
     * @param ucModule ucModule (SYS, LIST, PAGE, PART, etc)
     * @param ucName ucName (substitute @ for slash and ! for periods)
     * @param projectID (optional) Project ID
     * @param documentType (optional) Document Type
     */
    getCapabilityPermits(ucModule: string | null, ucName: string | null, projectID?: string | null | undefined, documentType?: string | null | undefined) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getCapabilityPermitsWithCallbacks(ucModule, ucName, projectID, documentType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCapabilityPermitsWithCallbacks(ucModule: string | null, ucName: string | null, projectID: string | null | undefined, documentType: string | null | undefined, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/capability/{ucModule}/{ucName}?";
        if (ucModule === undefined || ucModule === null)
            throw new Error("The parameter 'ucModule' must be defined.");
        url_ = url_.replace("{ucModule}", encodeURIComponent("" + ucModule));
        if (ucName === undefined || ucName === null)
            throw new Error("The parameter 'ucName' must be defined.");
        url_ = url_.replace("{ucName}", encodeURIComponent("" + ucName));
        if (projectID !== undefined && projectID !== null)
            url_ += "projectID=" + encodeURIComponent("" + projectID) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCapabilityPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCapabilityPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCapabilityPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetCapabilityPermits(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCapabilityPermits(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a token that can be exchanged for the specific packet of information
     */
    createExchangeToken(tokenPayload: TokenRequest) {
        return new Promise<string | null>((resolve, reject) => {
            this.createExchangeTokenWithCallbacks(tokenPayload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createExchangeTokenWithCallbacks(tokenPayload: TokenRequest, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/exchangetoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tokenPayload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateExchangeTokenWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processCreateExchangeToken(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateExchangeToken(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request malformed", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Request inappropriate", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the token-specific packet of information with Auth, Session and Args encrypted
     */
    exchangeToken(token: string | null) {
        return new Promise<AuthenticationExchangeData | null>((resolve, reject) => {
            this.exchangeTokenWithCallbacks(token, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private exchangeTokenWithCallbacks(token: string | null, onSuccess?: (result: AuthenticationExchangeData | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/exchangetoken/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processExchangeTokenWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processExchangeToken(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processExchangeToken(xhr: any): AuthenticationExchangeData | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Request inappropriate", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticationExchangeData.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Sets the time offset for this session
     */
    postClientTime(timeNow: Date, tzOffset: number) {
        return new Promise<boolean>((resolve, reject) => {
            this.postClientTimeWithCallbacks(timeNow, tzOffset, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postClientTimeWithCallbacks(timeNow: Date, tzOffset: number, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/time?";
        if (timeNow === undefined || timeNow === null)
            throw new Error("The parameter 'timeNow' must be defined and cannot be null.");
        else
            url_ += "timeNow=" + encodeURIComponent(timeNow ? "" + timeNow.toISOString() : "") + "&";
        if (tzOffset === undefined || tzOffset === null)
            throw new Error("The parameter 'tzOffset' must be defined and cannot be null.");
        else
            url_ += "tzOffset=" + encodeURIComponent("" + tzOffset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostClientTimeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostClientTimeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostClientTimeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostClientTime(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostClientTime(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("Unusable credentials with redirect to login ", status, _responseText, _headers, result302);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Not allowed now (see message for issue) ", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Not allowed now (already authenticated?)", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions for a project
     * @param projectID Project ID
     */
    getProjectPermits(projectID: string | null) {
        return new Promise<UCPermitSet | null>((resolve, reject) => {
            this.getProjectPermitsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitsWithCallbacks(projectID: string | null, onSuccess?: (result: UCPermitSet | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/project/{projectID}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectPermits(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermits(xhr: any): UCPermitSet | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UCPermitSet.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns server version in major.minor.build.t
     */
    getVersion() {
        return new Promise<string | null>((resolve, reject) => {
            this.getVersionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getVersionWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/version";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetVersionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetVersion(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetVersion(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Return cross request task state
     * @return task is done
     */
    getTaskState(taskID: string) {
        return new Promise<HttpResponseJsonContent>((resolve, reject) => {
            this.getTaskStateWithCallbacks(taskID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getTaskStateWithCallbacks(taskID: string, onSuccess?: (result: HttpResponseJsonContent) => void, onFail?: (exception: HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/task/{taskID}/state";
        if (taskID === undefined || taskID === null)
            throw new Error("The parameter 'taskID' must be defined.");
        url_ = url_.replace("{taskID}", encodeURIComponent("" + taskID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetTaskStateWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTaskStateWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetTaskStateWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetTaskState(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetTaskState(xhr: any): HttpResponseJsonContent | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HttpResponseJsonContent.fromJS(resultData200);
            return result200;

        } else if (status === 202) {
            const _responseText = xhr.responseText;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = HttpResponseJsonContent.fromJS(resultData202);
            return result202;

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = HttpResponseJsonContent.fromJS(resultData401);
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = HttpResponseJsonContent.fromJS(resultData404);
            return throwException("task not found", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = HttpResponseJsonContent.fromJS(resultData204);
            return result204;

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = HttpResponseJsonContent.fromJS(resultData500);
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Return cross request task result data as json
     */
    getTaskResult(taskID: string) {
        return new Promise<any>((resolve, reject) => {
            this.getTaskResultWithCallbacks(taskID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getTaskResultWithCallbacks(taskID: string, onSuccess?: (result: any) => void, onFail?: (exception: HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/task/{taskID}/data";
        if (taskID === undefined || taskID === null)
            throw new Error("The parameter 'taskID' must be defined.");
        url_ = url_.replace("{taskID}", encodeURIComponent("" + taskID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetTaskResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTaskResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetTaskResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetTaskResult(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetTaskResult(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = HttpResponseJsonContent.fromJS(resultData406);
            return throwException("task is running", status, _responseText, _headers, result406);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = HttpResponseJsonContent.fromJS(resultData401);
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = HttpResponseJsonContent.fromJS(resultData404);
            return throwException("task not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpResponseJsonContent.fromJS(resultData400);
            return throwException("no result", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = HttpResponseJsonContent.fromJS(resultData500);
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Return cross request result data as a file
     */
    getTaskFile(taskID: string) {
        return new Promise<Stream>((resolve, reject) => {
            this.getTaskFileWithCallbacks(taskID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getTaskFileWithCallbacks(taskID: string, onSuccess?: (result: Stream) => void, onFail?: (exception: HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | HttpResponseJsonContent | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/task/{taskID}/file";
        if (taskID === undefined || taskID === null)
            throw new Error("The parameter 'taskID' must be defined.");
        url_ = url_.replace("{taskID}", encodeURIComponent("" + taskID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetTaskFileWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTaskFileWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetTaskFileWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetTaskFile(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetTaskFile(xhr: any): Stream | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return result200;

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = HttpResponseJsonContent.fromJS(resultData406);
            return throwException("task is running", status, _responseText, _headers, result406);

        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = HttpResponseJsonContent.fromJS(resultData401);
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = HttpResponseJsonContent.fromJS(resultData404);
            return throwException("task not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpResponseJsonContent.fromJS(resultData400);
            return throwException("no stream", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = HttpResponseJsonContent.fromJS(resultData500);
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions by Module | Function
     * @param eTag (optional) Returns nothing if eTag matches supplied eTag
     */
    getProjectPermitNameMap(eTag?: string | null | undefined) {
        return new Promise<any>((resolve, reject) => {
            this.getProjectPermitNameMapWithCallbacks(eTag, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitNameMapWithCallbacks(eTag: string | null | undefined, onSuccess?: (result: any) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/map?";
        if (eTag !== undefined && eTag !== null)
            url_ += "eTag=" + encodeURIComponent("" + eTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitNameMapWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetProjectPermitNameMap(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermitNameMap(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result304 = resultData304 !== undefined ? resultData304 : <any>null;
    
            return throwException("This (fairly static) information matches the supplied eTag", status, _responseText, _headers, result304);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WCC Session data
     * @param context (optional) 
     */
    getWCC(context?: string | null | undefined) {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getWCCWithCallbacks(context, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getWCCWithCallbacks(context: string | null | undefined, onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/who?";
        if (context !== undefined && context !== null)
            url_ += "context=" + encodeURIComponent("" + context) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetWCCWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetWCC(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetWCC(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param forTabType (optional) optional tab type (project,other, other-user,blank for all)
     */
    getSessionTabs(forTabType?: string | null | undefined) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getSessionTabsWithCallbacks(forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabsWithCallbacks(forTabType: string | null | undefined, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSessionTabs(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds a tab to list of open tabs
     * @param tabKey tab key (perhaps project id or user key)
     * @param tabText tab text (displayed)
     * @param tabTip tab tip (display on mouse over)
     * @param tabAction tab action (must also be unique, so often includes tab key
     * @param forTabType (optional) optional tab type (project,other, otherUser)
     * @return User Tab collection not found
     */
    addSessionTab(tabKey: string | null, tabText: string | null, tabTip: string | null, tabAction: string | null, forTabType?: string | null | undefined) {
        return new Promise<string>((resolve, reject) => {
            this.addSessionTabWithCallbacks(tabKey, tabText, tabTip, tabAction, forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addSessionTabWithCallbacks(tabKey: string | null, tabText: string | null, tabTip: string | null, tabAction: string | null, forTabType: string | null | undefined, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (tabKey === undefined)
            throw new Error("The parameter 'tabKey' must be defined.");
        else if(tabKey !== null)
            url_ += "tabKey=" + encodeURIComponent("" + tabKey) + "&";
        if (tabText === undefined)
            throw new Error("The parameter 'tabText' must be defined.");
        else if(tabText !== null)
            url_ += "tabText=" + encodeURIComponent("" + tabText) + "&";
        if (tabTip === undefined)
            throw new Error("The parameter 'tabTip' must be defined.");
        else if(tabTip !== null)
            url_ += "tabTip=" + encodeURIComponent("" + tabTip) + "&";
        if (tabAction === undefined)
            throw new Error("The parameter 'tabAction' must be defined.");
        else if(tabAction !== null)
            url_ += "tabAction=" + encodeURIComponent("" + tabAction) + "&";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddSessionTabWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddSessionTab(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddSessionTab(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param tabKey Tab Key
     * @return No tabs (verify session)
     */
    deleteSessionTab(tabKey: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.deleteSessionTabWithCallbacks(tabKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteSessionTabWithCallbacks(tabKey: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (tabKey === undefined)
            throw new Error("The parameter 'tabKey' must be defined.");
        else if(tabKey !== null)
            url_ += "tabKey=" + encodeURIComponent("" + tabKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteSessionTabWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteSessionTab(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteSessionTab(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Tab not found", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns label and tip for new tab
     * @param id key for new tab, typically project id
     * @param forTabType (optional) optional tab type (project,other, otherUser,blank for all)
     */
    getSessionTabLabels(id: string | null, forTabType?: string | null | undefined) {
        return new Promise<TabDisplay | null>((resolve, reject) => {
            this.getSessionTabLabelsWithCallbacks(id, forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabLabelsWithCallbacks(id: string | null, forTabType: string | null | undefined, onSuccess?: (result: TabDisplay | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tab/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabLabelsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabLabelsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabLabelsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetSessionTabLabels(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabLabels(xhr: any): TabDisplay | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TabDisplay.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Releases document session by its session key
     * @param id Session Key
     * @return No session
     */
    deleteDocumentSession(id: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocumentSessionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocumentSessionWithCallbacks(id: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocumentSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocumentSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocumentSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteDocumentSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocumentSession(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("not found", status, _responseText, _headers, result404);

        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return result204;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Logs the posted data
     * @param logData Information To be logged
     */
    postToWebAppLog(logData: APIData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postToWebAppLogWithCallbacks(logData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postToWebAppLogWithCallbacks(logData: APIData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostToWebAppLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPostToWebAppLog(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostToWebAppLog(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Patches the value In the indicated resource
     * @param tableName Table Name (data layer, not native SQL)
     * @param fieldName field
     * @param changeData Change information
     */
    patchFieldValue(tableName: string | null, fieldName: string | null, changeData: PDSData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchFieldValueWithCallbacks(tableName, fieldName, changeData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchFieldValueWithCallbacks(tableName: string | null, fieldName: string | null, changeData: PDSData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/value/{tableName}/{fieldName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchFieldValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchFieldValue(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchFieldValue(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request missing required information", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Request inappropriate", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetEndOfSession(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes a specific users session
     */
    deleteSessionById(userKey: string, sessionID: string | null) {
        return new Promise<boolean>((resolve, reject) => {
            this.deleteSessionByIdWithCallbacks(userKey, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteSessionByIdWithCallbacks(userKey: string, sessionID: string | null, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/{userKey}/{sessionID}";
        if (userKey === undefined || userKey === null)
            throw new Error("The parameter 'userKey' must be defined.");
        url_ = url_.replace("{userKey}", encodeURIComponent("" + userKey));
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteSessionByIdWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteSessionByIdWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteSessionByIdWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processDeleteSessionById(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteSessionById(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Authentication required", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result403);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Cannot flush your own session", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Admin Required", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ContactClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns contacts that match filters
     * @param usingFilters Search Criteria
     */
    matchingContactList(usingFilters: ContactFilters) {
        return new Promise<ContactSummary[] | null>((resolve, reject) => {
            this.matchingContactListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingContactListWithCallbacks(usingFilters: ContactFilters, onSuccess?: (result: ContactSummary[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingContactListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processMatchingContactList(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingContactList(xhr: any): ContactSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the contact
     * @param id Contact Key
     */
    getContact(id: string) {
        return new Promise<Contact | null>((resolve, reject) => {
            this.getContactWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getContactWithCallbacks(id: string, onSuccess?: (result: Contact | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetContact(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetContact(xhr: any): Contact | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the contact
     * @param id Contact Key
     * @param newData Replacement Data
     * @param project (optional) Optional Project Context
     */
    updateContact(id: string, newData: Contact, project?: string | null | undefined) {
        return new Promise<any>((resolve, reject) => {
            this.updateContactWithCallbacks(id, newData, project, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateContactWithCallbacks(id: string, newData: Contact, project: string | null | undefined, onSuccess?: (result: any) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (project !== undefined && project !== null)
            url_ += "project=" + encodeURIComponent("" + project) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processUpdateContact(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateContact(xhr: any): any | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Failed", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds the contact
     * @param newData Contact Data
     * @param project (optional) Optional Project Contact
     * @param isCompany (optional) Optional is Primary Company Contact
     */
    addContact(newData: Contact, project?: string | null | undefined, isCompany?: boolean | undefined) {
        return new Promise<Contact | null>((resolve, reject) => {
            this.addContactWithCallbacks(newData, project, isCompany, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addContactWithCallbacks(newData: Contact, project: string | null | undefined, isCompany: boolean | undefined, onSuccess?: (result: Contact | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact?";
        if (project !== undefined && project !== null)
            url_ += "project=" + encodeURIComponent("" + project) + "&";
        if (isCompany === null)
            throw new Error("The parameter 'isCompany' cannot be null.");
        else if (isCompany !== undefined)
            url_ += "isCompany=" + encodeURIComponent("" + isCompany) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processAddContact(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddContact(xhr: any): Contact | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not allowed", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Failed", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ActionItemsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2023/SFPMS");
    }

    /**
     * Returns documents data that has changed
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param dataSummary KVP of current row keys (RouteID) and eTags
     */
    getChangedActionItems(forUserKey: string, dataSummary: CurrentDataSummary[]) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedActionItemsWithCallbacks(forUserKey, dataSummary, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedActionItemsWithCallbacks(forUserKey: string, dataSummary: CurrentDataSummary[], onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/changes?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataSummary);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetChangedActionItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedActionItems(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("user not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("You are not allowed to proxy for this user", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns action items for specified User
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserActionItems(forUserKey: string) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getUserActionItemsWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsWithCallbacks(forUserKey: string, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetUserActionItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItems(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("user not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("You are not allowed to proxy for this user", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns action items that match filters ProjectLike, TitleLike, ForDocType, FromDate, ThruDate, NewOnly
     */
    getMatchingUserActionItems(usingFilters: QueryFilters) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getMatchingUserActionItemsWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingUserActionItemsWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/matching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetMatchingUserActionItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingUserActionItems(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result403 = resultData403 !== undefined ? resultData403 : <any>null;
    
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("user not found, or not accessible", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("You are not allowed to proxy for this user", status, _responseText, _headers, result406);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Unexpected failure", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns an action item for the specified User
     * @param userID User Key or 1 for self
     * @param dtk Document Type
     * @param routeID Route ID (GUID)
     * @param projectLike Project ID or mask
     * @param titleLike (optional) Title Like (max 50)
     */
    getRouteActionInfo(userID: string | null, dtk: string, routeID: string, projectLike: string | null, titleLike?: string | null | undefined) {
        return new Promise<RouteActionInfo | null>((resolve, reject) => {
            this.getRouteActionInfoWithCallbacks(userID, dtk, routeID, projectLike, titleLike, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRouteActionInfoWithCallbacks(userID: string | null, dtk: string, routeID: string, projectLike: string | null, titleLike: string | null | undefined, onSuccess?: (result: RouteActionInfo | null) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{dtk}/{routeID}?";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (dtk === undefined || dtk === null)
            throw new Error("The parameter 'dtk' must be defined.");
        url_ = url_.replace("{dtk}", encodeURIComponent("" + dtk));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        if (projectLike === undefined)
            throw new Error("The parameter 'projectLike' must be defined.");
        else if(projectLike !== null)
            url_ += "projectLike=" + encodeURIComponent("" + projectLike) + "&";
        if (titleLike !== undefined && titleLike !== null)
            url_ += "titleLike=" + encodeURIComponent("" + titleLike) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRouteActionInfoWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRouteActionInfoWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRouteActionInfoWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processGetRouteActionInfo(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRouteActionInfo(xhr: any): RouteActionInfo | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("unusable credentials", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("internal failure", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Requested route not found", status, _responseText, _headers, result404);

        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result406 = resultData406 !== undefined ? resultData406 : <any>null;
    
            return throwException("Proxy denied", status, _responseText, _headers, result406);

        } else if (status === 503) {
            const _responseText = xhr.responseText;
            let result503: any = null;
            let resultData503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result503 = resultData503 !== undefined ? resultData503 : <any>null;
    
            return throwException("Try again after reauthentication", status, _responseText, _headers, result503);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RouteActionInfo.fromJS(resultData200) : <any>null;
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     * @param actionData action patch data
     * @param actionMode (optional) Mode is id,match,every
     */
    patchUserActionItems(userID: string | null, routeID: string, actionData: RouteActionData, actionMode?: string | null | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchUserActionItemsWithCallbacks(userID, routeID, actionData, actionMode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserActionItemsWithCallbacks(userID: string | null, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}?";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        if (actionMode !== undefined && actionMode !== null)
            url_ += "actionMode=" + encodeURIComponent("" + actionMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.transformResult(_url, xhr, (xhr) => this.processPatchUserActionItems(xhr));
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserActionItems(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Request missing required information", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Requested route not found!", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Request inappropriate", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;

        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

/** Comment about a topic */
export class Comment implements IComment {
    /** Key for this comment */
    DocCommentKey!: string;
    /** Key for the topic relating a group of comments */
    TopicKey!: string;
    /** Key for the author of this comment */
    FromUser!: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost?: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage?: number;
    /** When this comment was created (editable given sufficient permission) */
    Created?: Date;
    /** custom amount */
    csAmount?: number;
    /** custom amount */
    csValue?: number;
    /** custom quantity */
    csQty?: number;
    /** custom whole number */
    csNumber?: number;
    /** custom Boolean */
    csCheck?: boolean;
    /** custom Boolean */
    csFlag?: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocCommentKey = _data["DocCommentKey"];
            this.TopicKey = _data["TopicKey"];
            this.FromUser = _data["FromUser"];
            this.Note = _data["Note"];
            this.Cost = _data["Cost"];
            this.Stage = _data["Stage"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.DocCommentKey;
        data["TopicKey"] = this.TopicKey;
        data["FromUser"] = this.FromUser;
        data["Note"] = this.Note;
        data["Cost"] = this.Cost;
        data["Stage"] = this.Stage;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): Comment {
        const json = this.toJSON();
        let result = new Comment();
        result.init(json);
        return result;
    }
}

/** Comment about a topic */
export interface IComment {
    /** Key for this comment */
    DocCommentKey: string;
    /** Key for the topic relating a group of comments */
    TopicKey: string;
    /** Key for the author of this comment */
    FromUser: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost?: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage?: number;
    /** When this comment was created (editable given sufficient permission) */
    Created?: Date;
    /** custom amount */
    csAmount?: number;
    /** custom amount */
    csValue?: number;
    /** custom quantity */
    csQty?: number;
    /** custom whole number */
    csNumber?: number;
    /** custom Boolean */
    csCheck?: boolean;
    /** custom Boolean */
    csFlag?: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes a Menu or Action or Dialog Field */
export class MenuAction implements IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** optional argument */
    CommandArgument?: string | undefined;
    /** True if enabled */
    Enabled?: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits?: number | undefined;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string;
    /** Optional additional help information */
    InfoText?: string | undefined;
    /** Default value */
    DefaultValue?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits?: number | undefined;
    /** Controls order of choices within MenuID */
    MenuSeq?: number | undefined;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** list of actions for this element (if applicable) */
    Items?: MenuAction[] | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled?: boolean | undefined;
    /** eTag */
    ETag?: string;

    constructor(data?: IMenuAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.MenuID = _data["MenuID"];
            this.CommandName = _data["CommandName"];
            this.CommandArgument = _data["CommandArgument"];
            this.Enabled = _data["Enabled"];
            this.HasPermits = _data["HasPermits"];
            this.IconImageUrl = _data["IconImageUrl"];
            this.ItemText = _data["ItemText"];
            this.InfoText = _data["InfoText"];
            this.DefaultValue = _data["DefaultValue"];
            this.HRef = _data["HRef"];
            this.HrefTarget = _data["HrefTarget"];
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.NeedPermits = _data["NeedPermits"];
            this.MenuSeq = _data["MenuSeq"];
            this.Confirm = _data["Confirm"];
            if (Array.isArray(_data["Choices"])) {
                this.Choices = [] as any;
                for (let item of _data["Choices"])
                    this.Choices!.push(Suggestion.fromJS(item));
            }
            if (Array.isArray(_data["Items"])) {
                this.Items = [] as any;
                for (let item of _data["Items"])
                    this.Items!.push(MenuAction.fromJS(item));
            }
            this.HideifDisabled = _data["HideifDisabled"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): MenuAction {
        data = typeof data === 'object' ? data : {};
        let result = new MenuAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MenuID"] = this.MenuID;
        data["CommandName"] = this.CommandName;
        data["CommandArgument"] = this.CommandArgument;
        data["Enabled"] = this.Enabled;
        data["HasPermits"] = this.HasPermits;
        data["IconImageUrl"] = this.IconImageUrl;
        data["ItemText"] = this.ItemText;
        data["InfoText"] = this.InfoText;
        data["DefaultValue"] = this.DefaultValue;
        data["HRef"] = this.HRef;
        data["HrefTarget"] = this.HrefTarget;
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["NeedPermits"] = this.NeedPermits;
        data["MenuSeq"] = this.MenuSeq;
        data["Confirm"] = this.Confirm;
        if (Array.isArray(this.Choices)) {
            data["Choices"] = [];
            for (let item of this.Choices)
                data["Choices"].push(item.toJSON());
        }
        if (Array.isArray(this.Items)) {
            data["Items"] = [];
            for (let item of this.Items)
                data["Items"].push(item.toJSON());
        }
        data["HideifDisabled"] = this.HideifDisabled;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): MenuAction {
        const json = this.toJSON();
        let result = new MenuAction();
        result.init(json);
        return result;
    }
}

/** Describes a Menu or Action or Dialog Field */
export interface IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** optional argument */
    CommandArgument?: string | undefined;
    /** True if enabled */
    Enabled?: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits?: number | undefined;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string;
    /** Optional additional help information */
    InfoText?: string | undefined;
    /** Default value */
    DefaultValue?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits?: number | undefined;
    /** Controls order of choices within MenuID */
    MenuSeq?: number | undefined;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** list of actions for this element (if applicable) */
    Items?: MenuAction[] | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled?: boolean | undefined;
    /** eTag */
    ETag?: string;
}

/** Attributes describing a member of a project team */
export class Suggestion implements ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ISuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.value = _data["value"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): Suggestion {
        data = typeof data === 'object' ? data : {};
        let result = new Suggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["value"] = this.value;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): Suggestion {
        const json = this.toJSON();
        let result = new Suggestion();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocItemComment Condition */
export class DocItemComment implements IDocItemComment {
    /** key for this comment */
    DocCommentKey?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Free form */
    Note?: string | undefined;
    /** free form */
    Cost?: number;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom user */
    csValue?: number;
    /** for custom user */
    csQty?: number;
    /** for custom user */
    csNumber?: number;
    /** for custom use */
    csCheck?: boolean;
    /** for custom user */
    csFlag?: boolean;
    /** for custom user */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom user */
    csContactKey?: string;
    /** for custom user */
    csKey?: string;
    /** date, for custom use */
    csDate?: Date;
    /** for custom user */
    csWhen?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocItemComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocCommentKey = _data["DocCommentKey"];
            this.FromUser = _data["FromUser"];
            this.Note = _data["Note"];
            this.Cost = _data["Cost"];
            this.Stage = _data["Stage"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocItemComment {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.DocCommentKey;
        data["FromUser"] = this.FromUser;
        data["Note"] = this.Note;
        data["Cost"] = this.Cost;
        data["Stage"] = this.Stage;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocItemComment {
        const json = this.toJSON();
        let result = new DocItemComment();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemComment Condition */
export interface IDocItemComment {
    /** key for this comment */
    DocCommentKey?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Free form */
    Note?: string | undefined;
    /** free form */
    Cost?: number;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom user */
    csValue?: number;
    /** for custom user */
    csQty?: number;
    /** for custom user */
    csNumber?: number;
    /** for custom use */
    csCheck?: boolean;
    /** for custom user */
    csFlag?: boolean;
    /** for custom user */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom user */
    csContactKey?: string;
    /** for custom user */
    csKey?: string;
    /** date, for custom use */
    csDate?: Date;
    /** for custom user */
    csWhen?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** Defines a tab */
export class TabStripDetails implements ITabStripDetails {
    /** ID */
    TabId!: number;
    /** Key */
    TabKey!: string;
    /** Label */
    TabText?: string | undefined;
    /** Sequence */
    TabOrder?: number;
    /** Type */
    TabType?: string | undefined;
    /** semicolon separated list of roles or * */
    AuthorizedRoles?: string | undefined;
    /** URL */
    LinkURL?: string | undefined;
    /** tool tip */
    Tip?: string | undefined;
    /** visible when true */
    IsVisible?: boolean;

    constructor(data?: ITabStripDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.TabId = _data["TabId"];
            this.TabKey = _data["TabKey"];
            this.TabText = _data["TabText"];
            this.TabOrder = _data["TabOrder"];
            this.TabType = _data["TabType"];
            this.AuthorizedRoles = _data["AuthorizedRoles"];
            this.LinkURL = _data["LinkURL"];
            this.Tip = _data["Tip"];
            this.IsVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): TabStripDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TabStripDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TabId"] = this.TabId;
        data["TabKey"] = this.TabKey;
        data["TabText"] = this.TabText;
        data["TabOrder"] = this.TabOrder;
        data["TabType"] = this.TabType;
        data["AuthorizedRoles"] = this.AuthorizedRoles;
        data["LinkURL"] = this.LinkURL;
        data["Tip"] = this.Tip;
        data["IsVisible"] = this.IsVisible;
        return data;
    }

    clone(): TabStripDetails {
        const json = this.toJSON();
        let result = new TabStripDetails();
        result.init(json);
        return result;
    }
}

/** Defines a tab */
export interface ITabStripDetails {
    /** ID */
    TabId: number;
    /** Key */
    TabKey: string;
    /** Label */
    TabText?: string | undefined;
    /** Sequence */
    TabOrder?: number;
    /** Type */
    TabType?: string | undefined;
    /** semicolon separated list of roles or * */
    AuthorizedRoles?: string | undefined;
    /** URL */
    LinkURL?: string | undefined;
    /** tool tip */
    Tip?: string | undefined;
    /** visible when true */
    IsVisible?: boolean;
}

/** A change to a system field value */
export class DocAccessControl implements IDocAccessControl {
    /** Key of this item, for example ATCWFLog, DocDetail */
    UCName!: string;
    /** Bit Coded RIUDS   */
    Permit?: number;
    /** When true, enabled */
    Enabled?: boolean;
    /** PK of related entity */
    keyValue?: string;
    /** optional additional information.  For example ATCWFLog places the log here */
    auxValue?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocAccessControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UCName = _data["UCName"];
            this.Permit = _data["Permit"];
            this.Enabled = _data["Enabled"];
            this.keyValue = _data["keyValue"];
            this.auxValue = _data["auxValue"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocAccessControl {
        data = typeof data === 'object' ? data : {};
        let result = new DocAccessControl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UCName"] = this.UCName;
        data["Permit"] = this.Permit;
        data["Enabled"] = this.Enabled;
        data["keyValue"] = this.keyValue;
        data["auxValue"] = this.auxValue;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocAccessControl {
        const json = this.toJSON();
        let result = new DocAccessControl();
        result.init(json);
        return result;
    }
}

/** A change to a system field value */
export interface IDocAccessControl {
    /** Key of this item, for example ATCWFLog, DocDetail */
    UCName: string;
    /** Bit Coded RIUDS   */
    Permit?: number;
    /** When true, enabled */
    Enabled?: boolean;
    /** PK of related entity */
    keyValue?: string;
    /** optional additional information.  For example ATCWFLog places the log here */
    auxValue?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UpgradeRequired = 426,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
}

/** Document State Information */
export class DocumentState implements IDocumentState {
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Status code */
    Status?: string | undefined;
    /** State code ? (new), (i)nprocess, (P)ending, (C)losed, (A)pproved */
    DocState?: string | undefined;
    /** when true, document can leave a published state and return to in process */
    AllowsUnpending?: boolean;
    /** when true, document can leave a approved state and return to in process */
    AllowsUnapproved?: boolean;
    /** Prior Status if available  */
    PriorStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocumentState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.Status = _data["Status"];
            this.DocState = _data["DocState"];
            this.AllowsUnpending = _data["AllowsUnpending"];
            this.AllowsUnapproved = _data["AllowsUnapproved"];
            this.PriorStatus = _data["PriorStatus"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocumentState {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["Status"] = this.Status;
        data["DocState"] = this.DocState;
        data["AllowsUnpending"] = this.AllowsUnpending;
        data["AllowsUnapproved"] = this.AllowsUnapproved;
        data["PriorStatus"] = this.PriorStatus;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocumentState {
        const json = this.toJSON();
        let result = new DocumentState();
        result.init(json);
        return result;
    }
}

/** Document State Information */
export interface IDocumentState {
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Status code */
    Status?: string | undefined;
    /** State code ? (new), (i)nprocess, (P)ending, (C)losed, (A)pproved */
    DocState?: string | undefined;
    /** when true, document can leave a published state and return to in process */
    AllowsUnpending?: boolean;
    /** when true, document can leave a approved state and return to in process */
    AllowsUnapproved?: boolean;
    /** Prior Status if available  */
    PriorStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Passes data to a simple API */
export class APIData implements IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded?: boolean;

    constructor(data?: IAPIData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Data = _data["Data"];
            this.IsURIEncoded = _data["IsURIEncoded"];
        }
    }

    static fromJS(data: any): APIData {
        data = typeof data === 'object' ? data : {};
        let result = new APIData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.Data;
        data["IsURIEncoded"] = this.IsURIEncoded;
        return data;
    }

    clone(): APIData {
        const json = this.toJSON();
        let result = new APIData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded?: boolean;
}

/** Describes new value for a document field */
export class DocFieldChange extends APIData implements IDocFieldChange {
    /** table */
    DataMember?: string | undefined;
    /** field */
    DataField?: string | undefined;
    /** Identifies which row in the specified data member */
    InstanceKey?: string | undefined;

    constructor(data?: IDocFieldChange) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.InstanceKey = _data["InstanceKey"];
        }
    }

    static fromJS(data: any): DocFieldChange {
        data = typeof data === 'object' ? data : {};
        let result = new DocFieldChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["InstanceKey"] = this.InstanceKey;
        super.toJSON(data);
        return data;
    }

    clone(): DocFieldChange {
        const json = this.toJSON();
        let result = new DocFieldChange();
        result.init(json);
        return result;
    }
}

/** Describes new value for a document field */
export interface IDocFieldChange extends IAPIData {
    /** table */
    DataMember?: string | undefined;
    /** field */
    DataField?: string | undefined;
    /** Identifies which row in the specified data member */
    InstanceKey?: string | undefined;
}

/** Document Header information for a process */
export class DocMasterDetail implements IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey?: string;
    /** References a Document Process Type */
    DocTypeKey?: string;
    /** Site Name of Doc Type Process */
    DocTypeKey_dv?: string | undefined;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference?: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate?: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority?: number;
    /** Number to send */
    NumToSend?: number;
    /** Number to forward  */
    NumToForward?: number;
    /** numeric probability. valid values 0 to 100 */
    Probability?: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled?: boolean;
    /** When true, access is strictly restricted */
    Confidential?: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit?: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final?: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag?: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed?: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff?: Date;
    /** For example, invoice date of pay request */
    SourceDate?: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey?: string;
    /** key to global reference */
    UniReferenceKey?: string;
    /** Key for contact considered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty?: string;
    /** link to contact/user; the source  */
    SourceContact?: string;
    /** Validated in Contact Table */
    OwnerApprover?: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy?: string;
    /** Predefined route last resolved */
    LastRouteKey?: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area?: number;
    /** Numeric duration - units implied by SOP */
    Duration?: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask?: number;
    /** list of choices for UpdateMask */
    UpdateMaskChoices?: Suggestion[] | undefined;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags?: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser?: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage?: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo?: number;
    /** Read only Links to document revision */
    DocRevKey?: string;
    /** Read only key for document session */
    DocSessionKey?: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq?: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS?: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn?: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut?: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey?: string;
    /** Key to user currently editing  */
    EditUser?: string;
    /** read only summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;
    /** readonly Summary of attachment state  */
    AttachmentInfo?: string | undefined;
    /** Revision Number - System Generated */
    RevNo?: number;
    /** Free form explanation or generic description (!!!) */
    Description?: string | undefined;
    /** Scheduled Impact Requested in Days */
    DaysRequested?: number;
    /** Scheduled Impact Approved */
    DaysApproved?: number;
    /** Amount of Completed Work Retention */
    CWRetention?: number;
    /** Amount of Stored Material Retention */
    SMRetention?: number;
    /** Cost Impact - often computed by a configurable formula summarizing the items */
    CostImpact?: number;
    RangeFrom?: number;
    RangeThru?: number;
    Bond?: number;
    BondRate?: number;
    /** 8.25% as .0825 */
    TaxRate?: number;
    /** Code defined in DocType specific list */
    Segment?: string | undefined;
    /** Code defined in DocType specific list */
    Subsegment?: string | undefined;
    /** Link to external document  */
    DraftNumber?: string | undefined;
    /** Architect's Project (External Reference) */
    ArchProject?: string | undefined;
    /** Tax ID code */
    TaxID?: string | undefined;
    /** Codes assigned by Spitfire with special handling for Tax Included, Tax Added, No Tax */
    TaxHandling?: string | undefined;
    /** YYYYMM */
    InPeriod?: string | undefined;
    /** Free format notes */
    Notes?: string | undefined;
    /** Free format notes */
    NoteA?: string | undefined;
    /** Free format notes */
    NoteB?: string | undefined;
    /** Free format notes */
    NoteEML?: string | undefined;
    /** Subject for Email generated (See ATC: EMAIL workflow) */
    EmailSubject?: string | undefined;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom use */
    csValue?: number;
    /** for custom use */
    csQty?: number;
    /** for custom use */
    csNumber?: number;
    /** date, for custom use */
    csDate?: Date;
    /** for custom use */
    csWhen?: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** for custom use */
    csContactKey?: string;
    /** for custom use */
    csKey?: string;
    /** for custom use */
    csCheck?: boolean;
    /** for custom use */
    csFlag?: boolean;
    /** Version of SFPMS when revision created (4.1 and later) */
    sfVersion?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** When true, a financial snapshot exists for this Revision Key */
    HasBFASS?: boolean;
    /** Update Timestamps (for change detection) */
    ChangeTimestamps?: { [key: string]: number; } | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocMasterDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocTypeKey_dv = _data["DocTypeKey_dv"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Title = _data["Title"];
            this.Source = _data["Source"];
            this.Priority = _data["Priority"];
            this.NumToSend = _data["NumToSend"];
            this.NumToForward = _data["NumToForward"];
            this.Probability = _data["Probability"];
            this.AutoTitled = _data["AutoTitled"];
            this.Confidential = _data["Confidential"];
            this.DocEdit = _data["DocEdit"];
            this.Final = _data["Final"];
            this.DocFlag = _data["DocFlag"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.SourceContact = _data["SourceContact"];
            this.OwnerApprover = _data["OwnerApprover"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.LastRouteKey = _data["LastRouteKey"];
            this.Status = _data["Status"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(Suggestion.fromJS(item));
            }
            this.Subtype = _data["Subtype"];
            this.ContractType = _data["ContractType"];
            this.Reason = _data["Reason"];
            this.Area = _data["Area"];
            this.Duration = _data["Duration"];
            this.UpdateMask = _data["UpdateMask"];
            if (Array.isArray(_data["UpdateMaskChoices"])) {
                this.UpdateMaskChoices = [] as any;
                for (let item of _data["UpdateMaskChoices"])
                    this.UpdateMaskChoices!.push(Suggestion.fromJS(item));
            }
            this.RouteFlags = _data["RouteFlags"];
            this.Location = _data["Location"];
            this.PayItemNumber = _data["PayItemNumber"];
            this.DivisionID = _data["DivisionID"];
            this.Project = _data["Project"];
            this.Project_dv = _data["Project_dv"];
            this.ProjEntity = _data["ProjEntity"];
            this.Specification = _data["Specification"];
            this.BudgetRevFlag = _data["BudgetRevFlag"];
            this.SOVItemNumber = _data["SOVItemNumber"];
            this.Section = _data["Section"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.FromUser = _data["FromUser"];
            this.MaxStage = _data["MaxStage"];
            this.MaxRevNo = _data["MaxRevNo"];
            this.DocRevKey = _data["DocRevKey"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.ProjectSubtype = _data["ProjectSubtype"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.EditUser = _data["EditUser"];
            this.ComplianceInfo = _data["ComplianceInfo"];
            this.AttachmentInfo = _data["AttachmentInfo"];
            this.RevNo = _data["RevNo"];
            this.Description = _data["Description"];
            this.DaysRequested = _data["DaysRequested"];
            this.DaysApproved = _data["DaysApproved"];
            this.CWRetention = _data["CWRetention"];
            this.SMRetention = _data["SMRetention"];
            this.CostImpact = _data["CostImpact"];
            this.RangeFrom = _data["RangeFrom"];
            this.RangeThru = _data["RangeThru"];
            this.Bond = _data["Bond"];
            this.BondRate = _data["BondRate"];
            this.TaxRate = _data["TaxRate"];
            this.Segment = _data["Segment"];
            this.Subsegment = _data["Subsegment"];
            this.DraftNumber = _data["DraftNumber"];
            this.ArchProject = _data["ArchProject"];
            this.TaxID = _data["TaxID"];
            this.TaxHandling = _data["TaxHandling"];
            this.InPeriod = _data["InPeriod"];
            this.Notes = _data["Notes"];
            this.NoteA = _data["NoteA"];
            this.NoteB = _data["NoteB"];
            this.NoteEML = _data["NoteEML"];
            this.EmailSubject = _data["EmailSubject"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.sfVersion = _data["sfVersion"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.HasBFASS = _data["HasBFASS"];
            if (_data["ChangeTimestamps"]) {
                this.ChangeTimestamps = {} as any;
                for (let key in _data["ChangeTimestamps"]) {
                    if (_data["ChangeTimestamps"].hasOwnProperty(key))
                        (<any>this.ChangeTimestamps)![key] = _data["ChangeTimestamps"][key];
                }
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocMasterDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DocMasterDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocTypeKey_dv"] = this.DocTypeKey_dv;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Title"] = this.Title;
        data["Source"] = this.Source;
        data["Priority"] = this.Priority;
        data["NumToSend"] = this.NumToSend;
        data["NumToForward"] = this.NumToForward;
        data["Probability"] = this.Probability;
        data["AutoTitled"] = this.AutoTitled;
        data["Confidential"] = this.Confidential;
        data["DocEdit"] = this.DocEdit;
        data["Final"] = this.Final;
        data["DocFlag"] = this.DocFlag;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["SourceContact"] = this.SourceContact;
        data["OwnerApprover"] = this.OwnerApprover;
        data["LastStatusBy"] = this.LastStatusBy;
        data["LastRouteKey"] = this.LastRouteKey;
        data["Status"] = this.Status;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        data["Subtype"] = this.Subtype;
        data["ContractType"] = this.ContractType;
        data["Reason"] = this.Reason;
        data["Area"] = this.Area;
        data["Duration"] = this.Duration;
        data["UpdateMask"] = this.UpdateMask;
        if (Array.isArray(this.UpdateMaskChoices)) {
            data["UpdateMaskChoices"] = [];
            for (let item of this.UpdateMaskChoices)
                data["UpdateMaskChoices"].push(item.toJSON());
        }
        data["RouteFlags"] = this.RouteFlags;
        data["Location"] = this.Location;
        data["PayItemNumber"] = this.PayItemNumber;
        data["DivisionID"] = this.DivisionID;
        data["Project"] = this.Project;
        data["Project_dv"] = this.Project_dv;
        data["ProjEntity"] = this.ProjEntity;
        data["Specification"] = this.Specification;
        data["BudgetRevFlag"] = this.BudgetRevFlag;
        data["SOVItemNumber"] = this.SOVItemNumber;
        data["Section"] = this.Section;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["FromUser"] = this.FromUser;
        data["MaxStage"] = this.MaxStage;
        data["MaxRevNo"] = this.MaxRevNo;
        data["DocRevKey"] = this.DocRevKey;
        data["DocSessionKey"] = this.DocSessionKey;
        data["CurrentSeq"] = this.CurrentSeq;
        data["ProjectSubtype"] = this.ProjectSubtype;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["EditUser"] = this.EditUser;
        data["ComplianceInfo"] = this.ComplianceInfo;
        data["AttachmentInfo"] = this.AttachmentInfo;
        data["RevNo"] = this.RevNo;
        data["Description"] = this.Description;
        data["DaysRequested"] = this.DaysRequested;
        data["DaysApproved"] = this.DaysApproved;
        data["CWRetention"] = this.CWRetention;
        data["SMRetention"] = this.SMRetention;
        data["CostImpact"] = this.CostImpact;
        data["RangeFrom"] = this.RangeFrom;
        data["RangeThru"] = this.RangeThru;
        data["Bond"] = this.Bond;
        data["BondRate"] = this.BondRate;
        data["TaxRate"] = this.TaxRate;
        data["Segment"] = this.Segment;
        data["Subsegment"] = this.Subsegment;
        data["DraftNumber"] = this.DraftNumber;
        data["ArchProject"] = this.ArchProject;
        data["TaxID"] = this.TaxID;
        data["TaxHandling"] = this.TaxHandling;
        data["InPeriod"] = this.InPeriod;
        data["Notes"] = this.Notes;
        data["NoteA"] = this.NoteA;
        data["NoteB"] = this.NoteB;
        data["NoteEML"] = this.NoteEML;
        data["EmailSubject"] = this.EmailSubject;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["sfVersion"] = this.sfVersion;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["HasBFASS"] = this.HasBFASS;
        if (this.ChangeTimestamps) {
            data["ChangeTimestamps"] = {};
            for (let key in this.ChangeTimestamps) {
                if (this.ChangeTimestamps.hasOwnProperty(key))
                    (<any>data["ChangeTimestamps"])[key] = (<any>this.ChangeTimestamps)[key];
            }
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocMasterDetail {
        const json = this.toJSON();
        let result = new DocMasterDetail();
        result.init(json);
        return result;
    }
}

/** Document Header information for a process */
export interface IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey?: string;
    /** References a Document Process Type */
    DocTypeKey?: string;
    /** Site Name of Doc Type Process */
    DocTypeKey_dv?: string | undefined;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference?: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate?: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority?: number;
    /** Number to send */
    NumToSend?: number;
    /** Number to forward  */
    NumToForward?: number;
    /** numeric probability. valid values 0 to 100 */
    Probability?: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled?: boolean;
    /** When true, access is strictly restricted */
    Confidential?: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit?: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final?: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag?: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed?: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff?: Date;
    /** For example, invoice date of pay request */
    SourceDate?: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey?: string;
    /** key to global reference */
    UniReferenceKey?: string;
    /** Key for contact considered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty?: string;
    /** link to contact/user; the source  */
    SourceContact?: string;
    /** Validated in Contact Table */
    OwnerApprover?: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy?: string;
    /** Predefined route last resolved */
    LastRouteKey?: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area?: number;
    /** Numeric duration - units implied by SOP */
    Duration?: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask?: number;
    /** list of choices for UpdateMask */
    UpdateMaskChoices?: Suggestion[] | undefined;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags?: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser?: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage?: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo?: number;
    /** Read only Links to document revision */
    DocRevKey?: string;
    /** Read only key for document session */
    DocSessionKey?: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq?: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS?: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn?: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut?: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey?: string;
    /** Key to user currently editing  */
    EditUser?: string;
    /** read only summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;
    /** readonly Summary of attachment state  */
    AttachmentInfo?: string | undefined;
    /** Revision Number - System Generated */
    RevNo?: number;
    /** Free form explanation or generic description (!!!) */
    Description?: string | undefined;
    /** Scheduled Impact Requested in Days */
    DaysRequested?: number;
    /** Scheduled Impact Approved */
    DaysApproved?: number;
    /** Amount of Completed Work Retention */
    CWRetention?: number;
    /** Amount of Stored Material Retention */
    SMRetention?: number;
    /** Cost Impact - often computed by a configurable formula summarizing the items */
    CostImpact?: number;
    RangeFrom?: number;
    RangeThru?: number;
    Bond?: number;
    BondRate?: number;
    /** 8.25% as .0825 */
    TaxRate?: number;
    /** Code defined in DocType specific list */
    Segment?: string | undefined;
    /** Code defined in DocType specific list */
    Subsegment?: string | undefined;
    /** Link to external document  */
    DraftNumber?: string | undefined;
    /** Architect's Project (External Reference) */
    ArchProject?: string | undefined;
    /** Tax ID code */
    TaxID?: string | undefined;
    /** Codes assigned by Spitfire with special handling for Tax Included, Tax Added, No Tax */
    TaxHandling?: string | undefined;
    /** YYYYMM */
    InPeriod?: string | undefined;
    /** Free format notes */
    Notes?: string | undefined;
    /** Free format notes */
    NoteA?: string | undefined;
    /** Free format notes */
    NoteB?: string | undefined;
    /** Free format notes */
    NoteEML?: string | undefined;
    /** Subject for Email generated (See ATC: EMAIL workflow) */
    EmailSubject?: string | undefined;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom use */
    csValue?: number;
    /** for custom use */
    csQty?: number;
    /** for custom use */
    csNumber?: number;
    /** date, for custom use */
    csDate?: Date;
    /** for custom use */
    csWhen?: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** for custom use */
    csContactKey?: string;
    /** for custom use */
    csKey?: string;
    /** for custom use */
    csCheck?: boolean;
    /** for custom use */
    csFlag?: boolean;
    /** Version of SFPMS when revision created (4.1 and later) */
    sfVersion?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** When true, a financial snapshot exists for this Revision Key */
    HasBFASS?: boolean;
    /** Update Timestamps (for change detection) */
    ChangeTimestamps?: { [key: string]: number; } | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocItem Condition */
export class DocItem implements IDocItem {
    /** Key of this item */
    DocItemKey!: string;
    /** Read only Number of task entries for this item; often 1 */
    TaskCount?: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount?: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty?: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey?: string;
    /** Weak Link to another item */
    LinkedItemKey?: string;
    /** Key to global reference  */
    UniReferenceKey?: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy?: string;
    /** Key Reference user/contact */
    Approver?: string;
    /** References user/contact */
    Author?: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Money - Completed Work Retention */
    CWRetention?: number;
    /** Money - Stored Material Retention */
    SMRetention?: number;
    /** Original Estimate (of cost) */
    OriginalEstimate?: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote?: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity?: number;
    /** when true, is billable/included */
    Billable?: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey?: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey?: string;
    /** Reference to user/contact */
    ItemFromUser?: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated?: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc?: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared?: boolean;
    /** Hmm */
    ResponsibleNow?: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocItemKey = _data["DocItemKey"];
            this.TaskCount = _data["TaskCount"];
            this.CommentCount = _data["CommentCount"];
            this.ItemRevisionMap = _data["ItemRevisionMap"] ? DocItemMap.fromJS(_data["ItemRevisionMap"]) : <any>undefined;
            if (Array.isArray(_data["DocItemTask"])) {
                this.DocItemTask = [] as any;
                for (let item of _data["DocItemTask"])
                    this.DocItemTask!.push(DocItemTask.fromJS(item));
            }
            this.RelatedLineDetails = _data["RelatedLineDetails"] ? RelatedItemDetail.fromJS(_data["RelatedLineDetails"]) : <any>undefined;
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.Approver = _data["Approver"];
            this.Author = _data["Author"];
            this.Description = _data["Description"];
            this.DrawingNumber = _data["DrawingNumber"];
            this.RevisionNumber = _data["RevisionNumber"];
            this.Paragraph = _data["Paragraph"];
            this.Specification = _data["Specification"];
            this.ItemStatus = _data["ItemStatus"];
            this.ItemSource = _data["ItemSource"];
            this.ItemType = _data["ItemType"];
            this.ItemSubtype = _data["ItemSubtype"];
            this.Drawings = _data["Drawings"];
            this.Samples = _data["Samples"];
            this.ProductData = _data["ProductData"];
            this.TestReport = _data["TestReport"];
            this.MixDesign = _data["MixDesign"];
            this.Schedule = _data["Schedule"];
            this.FieldMockup = _data["FieldMockup"];
            this.Guarantee = _data["Guarantee"];
            this.Certification = _data["Certification"];
            this.Evaluation = _data["Evaluation"];
            this.Shop = _data["Shop"];
            this.SourceItemNumber = _data["SourceItemNumber"];
            this.SourceInitialNumber = _data["SourceInitialNumber"];
            this.ArchitectInitialNumber = _data["ArchitectInitialNumber"];
            this.ArchitectItemNumber = _data["ArchitectItemNumber"];
            this.SOVLineNumber = _data["SOVLineNumber"];
            this.Manufacturer = _data["Manufacturer"];
            this.Supplier = _data["Supplier"];
            this.RevenueEntity = _data["RevenueEntity"];
            this.Stage = _data["Stage"];
            this.CWRetention = _data["CWRetention"];
            this.SMRetention = _data["SMRetention"];
            this.OriginalEstimate = _data["OriginalEstimate"];
            this.OriginalQuote = _data["OriginalQuote"];
            this.ItemQuantity = _data["ItemQuantity"];
            this.Billable = _data["Billable"];
            this.Started = _data["Started"] ? new Date(_data["Started"].toString()) : <any>undefined;
            this.Submitted = _data["Submitted"] ? new Date(_data["Submitted"].toString()) : <any>undefined;
            this.Requested = _data["Requested"] ? new Date(_data["Requested"].toString()) : <any>undefined;
            this.Received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.Reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Completed = _data["Completed"] ? new Date(_data["Completed"].toString()) : <any>undefined;
            this.ItemRevKey = _data["ItemRevKey"];
            this.ItemFolderKey = _data["ItemFolderKey"];
            this.ItemFromUser = _data["ItemFromUser"];
            this.DocItemNumber = _data["DocItemNumber"];
            this.ItemCreated = _data["ItemCreated"] ? new Date(_data["ItemCreated"].toString()) : <any>undefined;
            this.IsRegisterDoc = _data["IsRegisterDoc"];
            this.ItemRegisterNumber = _data["ItemRegisterNumber"];
            this.ItemIsShared = _data["ItemIsShared"];
            this.ResponsibleNow = _data["ResponsibleNow"];
            this.ResponsibleCommon = _data["ResponsibleCommon"];
            this.ETag = _data["ETag"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocItemKey"] = this.DocItemKey;
        data["TaskCount"] = this.TaskCount;
        data["CommentCount"] = this.CommentCount;
        data["ItemRevisionMap"] = this.ItemRevisionMap ? this.ItemRevisionMap.toJSON() : <any>undefined;
        if (Array.isArray(this.DocItemTask)) {
            data["DocItemTask"] = [];
            for (let item of this.DocItemTask)
                data["DocItemTask"].push(item.toJSON());
        }
        data["RelatedLineDetails"] = this.RelatedLineDetails ? this.RelatedLineDetails.toJSON() : <any>undefined;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["LastStatusBy"] = this.LastStatusBy;
        data["Approver"] = this.Approver;
        data["Author"] = this.Author;
        data["Description"] = this.Description;
        data["DrawingNumber"] = this.DrawingNumber;
        data["RevisionNumber"] = this.RevisionNumber;
        data["Paragraph"] = this.Paragraph;
        data["Specification"] = this.Specification;
        data["ItemStatus"] = this.ItemStatus;
        data["ItemSource"] = this.ItemSource;
        data["ItemType"] = this.ItemType;
        data["ItemSubtype"] = this.ItemSubtype;
        data["Drawings"] = this.Drawings;
        data["Samples"] = this.Samples;
        data["ProductData"] = this.ProductData;
        data["TestReport"] = this.TestReport;
        data["MixDesign"] = this.MixDesign;
        data["Schedule"] = this.Schedule;
        data["FieldMockup"] = this.FieldMockup;
        data["Guarantee"] = this.Guarantee;
        data["Certification"] = this.Certification;
        data["Evaluation"] = this.Evaluation;
        data["Shop"] = this.Shop;
        data["SourceItemNumber"] = this.SourceItemNumber;
        data["SourceInitialNumber"] = this.SourceInitialNumber;
        data["ArchitectInitialNumber"] = this.ArchitectInitialNumber;
        data["ArchitectItemNumber"] = this.ArchitectItemNumber;
        data["SOVLineNumber"] = this.SOVLineNumber;
        data["Manufacturer"] = this.Manufacturer;
        data["Supplier"] = this.Supplier;
        data["RevenueEntity"] = this.RevenueEntity;
        data["Stage"] = this.Stage;
        data["CWRetention"] = this.CWRetention;
        data["SMRetention"] = this.SMRetention;
        data["OriginalEstimate"] = this.OriginalEstimate;
        data["OriginalQuote"] = this.OriginalQuote;
        data["ItemQuantity"] = this.ItemQuantity;
        data["Billable"] = this.Billable;
        data["Started"] = this.Started ? this.Started.toISOString() : <any>undefined;
        data["Submitted"] = this.Submitted ? this.Submitted.toISOString() : <any>undefined;
        data["Requested"] = this.Requested ? this.Requested.toISOString() : <any>undefined;
        data["Received"] = this.Received ? this.Received.toISOString() : <any>undefined;
        data["Reviewed"] = this.Reviewed ? this.Reviewed.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Completed"] = this.Completed ? this.Completed.toISOString() : <any>undefined;
        data["ItemRevKey"] = this.ItemRevKey;
        data["ItemFolderKey"] = this.ItemFolderKey;
        data["ItemFromUser"] = this.ItemFromUser;
        data["DocItemNumber"] = this.DocItemNumber;
        data["ItemCreated"] = this.ItemCreated ? this.ItemCreated.toISOString() : <any>undefined;
        data["IsRegisterDoc"] = this.IsRegisterDoc;
        data["ItemRegisterNumber"] = this.ItemRegisterNumber;
        data["ItemIsShared"] = this.ItemIsShared;
        data["ResponsibleNow"] = this.ResponsibleNow;
        data["ResponsibleCommon"] = this.ResponsibleCommon;
        data["ETag"] = this.ETag;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocItem {
        const json = this.toJSON();
        let result = new DocItem();
        result.init(json);
        return result;
    }
}

/** Describes an DocItem Condition */
export interface IDocItem {
    /** Key of this item */
    DocItemKey: string;
    /** Read only Number of task entries for this item; often 1 */
    TaskCount?: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount?: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty?: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey?: string;
    /** Weak Link to another item */
    LinkedItemKey?: string;
    /** Key to global reference  */
    UniReferenceKey?: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy?: string;
    /** Key Reference user/contact */
    Approver?: string;
    /** References user/contact */
    Author?: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Money - Completed Work Retention */
    CWRetention?: number;
    /** Money - Stored Material Retention */
    SMRetention?: number;
    /** Original Estimate (of cost) */
    OriginalEstimate?: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote?: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity?: number;
    /** when true, is billable/included */
    Billable?: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey?: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey?: string;
    /** Reference to user/contact */
    ItemFromUser?: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated?: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc?: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared?: boolean;
    /** Hmm */
    ResponsibleNow?: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Describes an DocRevItem Condition */
export class DocItemMap implements IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey?: string;
    /** Links to item */
    DocItemKey?: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocItemMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocRevItemKey = _data["DocRevItemKey"];
            this.DocItemKey = _data["DocItemKey"];
            this.ContainerKey = _data["ContainerKey"];
            this.FromUser = _data["FromUser"];
            this.ItemNumber = _data["ItemNumber"];
            this.ItemSeq = _data["ItemSeq"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocItemMap {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocRevItemKey"] = this.DocRevItemKey;
        data["DocItemKey"] = this.DocItemKey;
        data["ContainerKey"] = this.ContainerKey;
        data["FromUser"] = this.FromUser;
        data["ItemNumber"] = this.ItemNumber;
        data["ItemSeq"] = this.ItemSeq;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocItemMap {
        const json = this.toJSON();
        let result = new DocItemMap();
        result.init(json);
        return result;
    }
}

/** Describes an DocRevItem Condition */
export interface IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey?: string;
    /** Links to item */
    DocItemKey?: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocItemTask Condition */
export class DocItemTask implements IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey?: string;
    LinkedLineKey?: string;
    /** Weak link to RFQ */
    LinkedRFQKey?: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey?: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent?: number;
    /** pjcosubd.change_units */
    Quantity?: number;
    /** Calculated, but editable */
    RevenueAmount?: number;
    Rate?: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount?: number;
    /** Material part of RevenueAmount */
    StoredAmount?: number;
    /** Labor part of RevenueAmount */
    WorkAmount?: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount?: number;
    SMRetentionAmount?: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork?: number;
    /** Total material value on SOV */
    SOVMaterials?: number;
    MarkupRate?: number;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl?: boolean;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey?: string;
    csKey?: string;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    LinkedEstimate?: number;
    LinkedQuote?: number;
    LinkedExpense?: number;
    LinkedLines?: number;
    LinkedContact?: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocItemTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ItemTaskKey = _data["ItemTaskKey"];
            this.LinkedLineKey = _data["LinkedLineKey"];
            this.LinkedRFQKey = _data["LinkedRFQKey"];
            this.LinkedCCCKey = _data["LinkedCCCKey"];
            this.ProjEntity = _data["ProjEntity"];
            this.AccountCategory = _data["AccountCategory"];
            this.Subcontract = _data["Subcontract"];
            this.SubChangeOrder = _data["SubChangeOrder"];
            this.CostType = _data["CostType"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.UOM = _data["UOM"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.Vendor = _data["Vendor"];
            this.ProjectReference = _data["ProjectReference"];
            this.ItemPercent = _data["ItemPercent"];
            this.Quantity = _data["Quantity"];
            this.RevenueAmount = _data["RevenueAmount"];
            this.Rate = _data["Rate"];
            this.ExpenseAmount = _data["ExpenseAmount"];
            this.StoredAmount = _data["StoredAmount"];
            this.WorkAmount = _data["WorkAmount"];
            this.RetentionAmount = _data["RetentionAmount"];
            this.SMRetentionAmount = _data["SMRetentionAmount"];
            this.SOVWork = _data["SOVWork"];
            this.SOVMaterials = _data["SOVMaterials"];
            this.MarkupRate = _data["MarkupRate"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.MarkupControl = _data["MarkupControl"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.Note = _data["Note"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.LinkedEstimate = _data["LinkedEstimate"];
            this.LinkedQuote = _data["LinkedQuote"];
            this.LinkedExpense = _data["LinkedExpense"];
            this.LinkedLines = _data["LinkedLines"];
            this.LinkedContact = _data["LinkedContact"];
            this.LinkedRFQSC = _data["LinkedRFQSC"];
            this.LinkedStatus = _data["LinkedStatus"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocItemTask {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemTaskKey"] = this.ItemTaskKey;
        data["LinkedLineKey"] = this.LinkedLineKey;
        data["LinkedRFQKey"] = this.LinkedRFQKey;
        data["LinkedCCCKey"] = this.LinkedCCCKey;
        data["ProjEntity"] = this.ProjEntity;
        data["AccountCategory"] = this.AccountCategory;
        data["Subcontract"] = this.Subcontract;
        data["SubChangeOrder"] = this.SubChangeOrder;
        data["CostType"] = this.CostType;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["UOM"] = this.UOM;
        data["RetentionMethod"] = this.RetentionMethod;
        data["Vendor"] = this.Vendor;
        data["ProjectReference"] = this.ProjectReference;
        data["ItemPercent"] = this.ItemPercent;
        data["Quantity"] = this.Quantity;
        data["RevenueAmount"] = this.RevenueAmount;
        data["Rate"] = this.Rate;
        data["ExpenseAmount"] = this.ExpenseAmount;
        data["StoredAmount"] = this.StoredAmount;
        data["WorkAmount"] = this.WorkAmount;
        data["RetentionAmount"] = this.RetentionAmount;
        data["SMRetentionAmount"] = this.SMRetentionAmount;
        data["SOVWork"] = this.SOVWork;
        data["SOVMaterials"] = this.SOVMaterials;
        data["MarkupRate"] = this.MarkupRate;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["MarkupControl"] = this.MarkupControl;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.Note;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["LinkedEstimate"] = this.LinkedEstimate;
        data["LinkedQuote"] = this.LinkedQuote;
        data["LinkedExpense"] = this.LinkedExpense;
        data["LinkedLines"] = this.LinkedLines;
        data["LinkedContact"] = this.LinkedContact;
        data["LinkedRFQSC"] = this.LinkedRFQSC;
        data["LinkedStatus"] = this.LinkedStatus;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocItemTask {
        const json = this.toJSON();
        let result = new DocItemTask();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemTask Condition */
export interface IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey?: string;
    LinkedLineKey?: string;
    /** Weak link to RFQ */
    LinkedRFQKey?: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey?: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent?: number;
    /** pjcosubd.change_units */
    Quantity?: number;
    /** Calculated, but editable */
    RevenueAmount?: number;
    Rate?: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount?: number;
    /** Material part of RevenueAmount */
    StoredAmount?: number;
    /** Labor part of RevenueAmount */
    WorkAmount?: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount?: number;
    SMRetentionAmount?: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork?: number;
    /** Total material value on SOV */
    SOVMaterials?: number;
    MarkupRate?: number;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl?: boolean;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey?: string;
    csKey?: string;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    LinkedEstimate?: number;
    LinkedQuote?: number;
    LinkedExpense?: number;
    LinkedLines?: number;
    LinkedContact?: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an SPRLineDetails Condition */
export class RelatedItemDetail implements IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey?: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity?: number;
    /** Approved Retention  */
    ApprovedRetention?: number;
    /** Change Order Approved  */
    ApprovedAmount?: number;
    /** Change Order Approved  */
    ApprovedExpense?: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits?: number;
    /** not yet approved */
    PendingChangeRetention?: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount?: number;
    /** not yet approved */
    PendingChangeExpense?: number;
    /** Paid Units */
    VoucheredUnits?: number;
    /** Paid Amount */
    VoucheredAmount?: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount?: number;
    /** Amount Earned but held as retention */
    VoucheredRetention?: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention?: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity?: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention?: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount?: number;
    /** Units received */
    ReceivedUnits?: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits?: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount?: number;
    /** Units on line, includes change orders */
    ContractUnits?: number;
    /** Percent */
    TotalPercentRequest?: number;
    /** Units */
    TotalUnitsCompleted?: number;
    /** Amount */
    TotalAmountCompleted?: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount?: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent?: number;
    Rate?: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap?: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IRelatedItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.Subcontract = _data["Subcontract"];
            this.SCDocItemKey = _data["SCDocItemKey"];
            this.ApprovedQuantity = _data["ApprovedQuantity"];
            this.ApprovedRetention = _data["ApprovedRetention"];
            this.ApprovedAmount = _data["ApprovedAmount"];
            this.ApprovedExpense = _data["ApprovedExpense"];
            this.PendingChangeUnits = _data["PendingChangeUnits"];
            this.PendingChangeRetention = _data["PendingChangeRetention"];
            this.PendingChangeAmount = _data["PendingChangeAmount"];
            this.PendingChangeExpense = _data["PendingChangeExpense"];
            this.VoucheredUnits = _data["VoucheredUnits"];
            this.VoucheredAmount = _data["VoucheredAmount"];
            this.VoucheredSMAmount = _data["VoucheredSMAmount"];
            this.VoucheredRetention = _data["VoucheredRetention"];
            this.VoucheredSMRetention = _data["VoucheredSMRetention"];
            this.PRInProgressQuantity = _data["PRInProgressQuantity"];
            this.PRInProgressRetention = _data["PRInProgressRetention"];
            this.PRInProgressAmount = _data["PRInProgressAmount"];
            this.ReceivedUnits = _data["ReceivedUnits"];
            this.ReceiptInProgressUnits = _data["ReceiptInProgressUnits"];
            this.ContractAmount = _data["ContractAmount"];
            this.ContractUnits = _data["ContractUnits"];
            this.TotalPercentRequest = _data["TotalPercentRequest"];
            this.TotalUnitsCompleted = _data["TotalUnitsCompleted"];
            this.TotalAmountCompleted = _data["TotalAmountCompleted"];
            this.TotalPriorAmount = _data["TotalPriorAmount"];
            this.ProjEntity = _data["ProjEntity"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.AccountCategory = _data["AccountCategory"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.ItemPercent = _data["ItemPercent"];
            this.Rate = _data["Rate"];
            this.LineDesc = _data["LineDesc"];
            this.Cap = _data["Cap"];
            this.UOM = _data["UOM"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): RelatedItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["Subcontract"] = this.Subcontract;
        data["SCDocItemKey"] = this.SCDocItemKey;
        data["ApprovedQuantity"] = this.ApprovedQuantity;
        data["ApprovedRetention"] = this.ApprovedRetention;
        data["ApprovedAmount"] = this.ApprovedAmount;
        data["ApprovedExpense"] = this.ApprovedExpense;
        data["PendingChangeUnits"] = this.PendingChangeUnits;
        data["PendingChangeRetention"] = this.PendingChangeRetention;
        data["PendingChangeAmount"] = this.PendingChangeAmount;
        data["PendingChangeExpense"] = this.PendingChangeExpense;
        data["VoucheredUnits"] = this.VoucheredUnits;
        data["VoucheredAmount"] = this.VoucheredAmount;
        data["VoucheredSMAmount"] = this.VoucheredSMAmount;
        data["VoucheredRetention"] = this.VoucheredRetention;
        data["VoucheredSMRetention"] = this.VoucheredSMRetention;
        data["PRInProgressQuantity"] = this.PRInProgressQuantity;
        data["PRInProgressRetention"] = this.PRInProgressRetention;
        data["PRInProgressAmount"] = this.PRInProgressAmount;
        data["ReceivedUnits"] = this.ReceivedUnits;
        data["ReceiptInProgressUnits"] = this.ReceiptInProgressUnits;
        data["ContractAmount"] = this.ContractAmount;
        data["ContractUnits"] = this.ContractUnits;
        data["TotalPercentRequest"] = this.TotalPercentRequest;
        data["TotalUnitsCompleted"] = this.TotalUnitsCompleted;
        data["TotalAmountCompleted"] = this.TotalAmountCompleted;
        data["TotalPriorAmount"] = this.TotalPriorAmount;
        data["ProjEntity"] = this.ProjEntity;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["AccountCategory"] = this.AccountCategory;
        data["RetentionMethod"] = this.RetentionMethod;
        data["ItemPercent"] = this.ItemPercent;
        data["Rate"] = this.Rate;
        data["LineDesc"] = this.LineDesc;
        data["Cap"] = this.Cap;
        data["UOM"] = this.UOM;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): RelatedItemDetail {
        const json = this.toJSON();
        let result = new RelatedItemDetail();
        result.init(json);
        return result;
    }
}

/** Describes an SPRLineDetails Condition */
export interface IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey?: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity?: number;
    /** Approved Retention  */
    ApprovedRetention?: number;
    /** Change Order Approved  */
    ApprovedAmount?: number;
    /** Change Order Approved  */
    ApprovedExpense?: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits?: number;
    /** not yet approved */
    PendingChangeRetention?: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount?: number;
    /** not yet approved */
    PendingChangeExpense?: number;
    /** Paid Units */
    VoucheredUnits?: number;
    /** Paid Amount */
    VoucheredAmount?: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount?: number;
    /** Amount Earned but held as retention */
    VoucheredRetention?: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention?: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity?: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention?: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount?: number;
    /** Units received */
    ReceivedUnits?: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits?: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount?: number;
    /** Units on line, includes change orders */
    ContractUnits?: number;
    /** Percent */
    TotalPercentRequest?: number;
    /** Units */
    TotalUnitsCompleted?: number;
    /** Amount */
    TotalAmountCompleted?: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount?: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent?: number;
    Rate?: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap?: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes a sequenced recipient in a document route */
export class DocRoute implements IDocRoute {
    /** associates the row with a specific doc route */
    RouteID?: string;
    /** Link to user/contact */
    UserKey?: string;
    /** When true, the user is inactive */
    UserKey_Inactive?: boolean;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Display sequence (by name withing sequence) */
    Sequence?: number;
    /** Parallel Route Group ID */
    GroupNo?: number;
    /** Links to the user/contact that added this route */
    FromUser?: string;
    /** The role assigned to this recipient  */
    RecipientRole?: string | undefined;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit?: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts?: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo?: boolean;
    /** Name of Person email routes are sent on-behalf-of (output only) */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route recipient  */
    Request?: string | undefined;
    /** Free form response to route recipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    RouteeProxy?: string;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date;
    /** When 1, no notification emails are sent */
    PriorityOver?: number;
    ExpectProxy?: boolean;
    HasContent?: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal?: boolean;
    /** associates the row with a doc route sequence */
    RouteStepKey?: string;
    /** When this route was reached (estimated) */
    Reached?: Date;
    /** Identifies the user that added the route  */
    ByUser?: string;
    /** The transmittal control number */
    TransNumber?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** If transmittal has data */
    HasBinData?: boolean;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RouteID = _data["RouteID"];
            this.UserKey = _data["UserKey"];
            this.UserKey_Inactive = _data["UserKey_Inactive"];
            this.Stage = _data["Stage"];
            this.Sequence = _data["Sequence"];
            this.GroupNo = _data["GroupNo"];
            this.FromUser = _data["FromUser"];
            this.RecipientRole = _data["RecipientRole"];
            this.Status = _data["Status"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(Suggestion.fromJS(item));
            }
            this.RouteVia = _data["RouteVia"];
            if (Array.isArray(_data["RouteViaChoices"])) {
                this.RouteViaChoices = [] as any;
                for (let item of _data["RouteViaChoices"])
                    this.RouteViaChoices!.push(Suggestion.fromJS(item));
            }
            this.UserDocEdit = _data["UserDocEdit"];
            this.SendAlerts = _data["SendAlerts"];
            this.ReplyTo = _data["ReplyTo"];
            this.EmailFrom = _data["EmailFrom"];
            this.Note = _data["Note"];
            this.Request = _data["Request"];
            this.Response = _data["Response"];
            this.ResponseCode = _data["ResponseCode"];
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(Suggestion.fromJS(item));
            }
            this.WorkflowScript = _data["WorkflowScript"];
            this.Alerted = _data["Alerted"] ? new Date(_data["Alerted"].toString()) : <any>undefined;
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Downloaded = _data["Downloaded"] ? new Date(_data["Downloaded"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Acted = _data["Acted"] ? new Date(_data["Acted"].toString()) : <any>undefined;
            this.UserName = _data["UserName"];
            this.Activity = _data["Activity"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.PriorityOver = _data["PriorityOver"];
            this.ExpectProxy = _data["ExpectProxy"];
            this.HasContent = _data["HasContent"];
            this.IsInternal = _data["IsInternal"];
            this.RouteStepKey = _data["RouteStepKey"];
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.ByUser = _data["ByUser"];
            this.TransNumber = _data["TransNumber"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.TransStatus = _data["TransStatus"];
            this.BinType = _data["BinType"];
            this.HasBinData = _data["HasBinData"];
            this.ETag = _data["ETag"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocRoute {
        data = typeof data === 'object' ? data : {};
        let result = new DocRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RouteID"] = this.RouteID;
        data["UserKey"] = this.UserKey;
        data["UserKey_Inactive"] = this.UserKey_Inactive;
        data["Stage"] = this.Stage;
        data["Sequence"] = this.Sequence;
        data["GroupNo"] = this.GroupNo;
        data["FromUser"] = this.FromUser;
        data["RecipientRole"] = this.RecipientRole;
        data["Status"] = this.Status;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        data["RouteVia"] = this.RouteVia;
        if (Array.isArray(this.RouteViaChoices)) {
            data["RouteViaChoices"] = [];
            for (let item of this.RouteViaChoices)
                data["RouteViaChoices"].push(item.toJSON());
        }
        data["UserDocEdit"] = this.UserDocEdit;
        data["SendAlerts"] = this.SendAlerts;
        data["ReplyTo"] = this.ReplyTo;
        data["EmailFrom"] = this.EmailFrom;
        data["Note"] = this.Note;
        data["Request"] = this.Request;
        data["Response"] = this.Response;
        data["ResponseCode"] = this.ResponseCode;
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        data["WorkflowScript"] = this.WorkflowScript;
        data["Alerted"] = this.Alerted ? this.Alerted.toISOString() : <any>undefined;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Downloaded"] = this.Downloaded ? this.Downloaded.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Acted"] = this.Acted ? this.Acted.toISOString() : <any>undefined;
        data["UserName"] = this.UserName;
        data["Activity"] = this.Activity;
        data["RouteeProxy"] = this.RouteeProxy;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["PriorityOver"] = this.PriorityOver;
        data["ExpectProxy"] = this.ExpectProxy;
        data["HasContent"] = this.HasContent;
        data["IsInternal"] = this.IsInternal;
        data["RouteStepKey"] = this.RouteStepKey;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["ByUser"] = this.ByUser;
        data["TransNumber"] = this.TransNumber;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["TransStatus"] = this.TransStatus;
        data["BinType"] = this.BinType;
        data["HasBinData"] = this.HasBinData;
        data["ETag"] = this.ETag;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocRoute {
        const json = this.toJSON();
        let result = new DocRoute();
        result.init(json);
        return result;
    }
}

/** Describes a sequenced recipient in a document route */
export interface IDocRoute {
    /** associates the row with a specific doc route */
    RouteID?: string;
    /** Link to user/contact */
    UserKey?: string;
    /** When true, the user is inactive */
    UserKey_Inactive?: boolean;
    /** Initialized to current stage when added */
    Stage?: number;
    /** Display sequence (by name withing sequence) */
    Sequence?: number;
    /** Parallel Route Group ID */
    GroupNo?: number;
    /** Links to the user/contact that added this route */
    FromUser?: string;
    /** The role assigned to this recipient  */
    RecipientRole?: string | undefined;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit?: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts?: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo?: boolean;
    /** Name of Person email routes are sent on-behalf-of (output only) */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route recipient  */
    Request?: string | undefined;
    /** Free form response to route recipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    RouteeProxy?: string;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date;
    /** When 1, no notification emails are sent */
    PriorityOver?: number;
    ExpectProxy?: boolean;
    HasContent?: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal?: boolean;
    /** associates the row with a doc route sequence */
    RouteStepKey?: string;
    /** When this route was reached (estimated) */
    Reached?: Date;
    /** Identifies the user that added the route  */
    ByUser?: string;
    /** The transmittal control number */
    TransNumber?: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** If transmittal has data */
    HasBinData?: boolean;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Describes a Date (start and finish) on a document */
export class DocDate implements IDocDate {
    /** Key of row */
    DocDateRowKey?: string;
    /** Key of date type */
    DocDateTypeKey?: string;
    /** Display sequence (by name within sequence) */
    Sequence?: number;
    /** Date type requests start  */
    IncludeStart?: boolean;
    /** Date type requests finish */
    IncludeFinish?: boolean;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired?: boolean;
    /** Default lead time in days */
    LeadTime?: number;
    /** When start is anticipated */
    SchedStart?: Date | undefined;
    /** When finish is anticipated */
    SchedFinish?: Date | undefined;
    /** When actually started */
    ActStart?: Date | undefined;
    /** When Actually finished */
    ActFinish?: Date | undefined;
    /** The whole number of days between ActStart and ActFinish; read only. */
    DaysBetween?: number;
    /** Free form */
    Note?: string | undefined;
    /** When true, this date is "done" */
    IsDone?: boolean;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom use */
    csValue?: number;
    /** for custom use */
    csQty?: number;
    /** for custom use */
    csNumber?: number;
    /** for custom use */
    csCheck?: boolean;
    /** for custom use */
    csFlag?: boolean;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csContactKey?: string;
    /** for custom use */
    csKey?: string;
    /** date, for custom use */
    csDate?: Date | undefined;
    /** for custom use */
    csWhen?: Date | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocDateRowKey = _data["DocDateRowKey"];
            this.DocDateTypeKey = _data["DocDateTypeKey"];
            this.Sequence = _data["Sequence"];
            this.IncludeStart = _data["IncludeStart"];
            this.IncludeFinish = _data["IncludeFinish"];
            this.IsRequired = _data["IsRequired"];
            this.LeadTime = _data["LeadTime"];
            this.SchedStart = _data["SchedStart"] ? new Date(_data["SchedStart"].toString()) : <any>undefined;
            this.SchedFinish = _data["SchedFinish"] ? new Date(_data["SchedFinish"].toString()) : <any>undefined;
            this.ActStart = _data["ActStart"] ? new Date(_data["ActStart"].toString()) : <any>undefined;
            this.ActFinish = _data["ActFinish"] ? new Date(_data["ActFinish"].toString()) : <any>undefined;
            this.DaysBetween = _data["DaysBetween"];
            this.Note = _data["Note"];
            this.IsDone = _data["IsDone"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocDate {
        data = typeof data === 'object' ? data : {};
        let result = new DocDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocDateRowKey"] = this.DocDateRowKey;
        data["DocDateTypeKey"] = this.DocDateTypeKey;
        data["Sequence"] = this.Sequence;
        data["IncludeStart"] = this.IncludeStart;
        data["IncludeFinish"] = this.IncludeFinish;
        data["IsRequired"] = this.IsRequired;
        data["LeadTime"] = this.LeadTime;
        data["SchedStart"] = this.SchedStart ? this.SchedStart.toISOString() : <any>undefined;
        data["SchedFinish"] = this.SchedFinish ? this.SchedFinish.toISOString() : <any>undefined;
        data["ActStart"] = this.ActStart ? this.ActStart.toISOString() : <any>undefined;
        data["ActFinish"] = this.ActFinish ? this.ActFinish.toISOString() : <any>undefined;
        data["DaysBetween"] = this.DaysBetween;
        data["Note"] = this.Note;
        data["IsDone"] = this.IsDone;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocDate {
        const json = this.toJSON();
        let result = new DocDate();
        result.init(json);
        return result;
    }
}

/** Describes a Date (start and finish) on a document */
export interface IDocDate {
    /** Key of row */
    DocDateRowKey?: string;
    /** Key of date type */
    DocDateTypeKey?: string;
    /** Display sequence (by name within sequence) */
    Sequence?: number;
    /** Date type requests start  */
    IncludeStart?: boolean;
    /** Date type requests finish */
    IncludeFinish?: boolean;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired?: boolean;
    /** Default lead time in days */
    LeadTime?: number;
    /** When start is anticipated */
    SchedStart?: Date | undefined;
    /** When finish is anticipated */
    SchedFinish?: Date | undefined;
    /** When actually started */
    ActStart?: Date | undefined;
    /** When Actually finished */
    ActFinish?: Date | undefined;
    /** The whole number of days between ActStart and ActFinish; read only. */
    DaysBetween?: number;
    /** Free form */
    Note?: string | undefined;
    /** When true, this date is "done" */
    IsDone?: boolean;
    /** Amount, for custom use */
    csAmount?: number;
    /** for custom use */
    csValue?: number;
    /** for custom use */
    csQty?: number;
    /** for custom use */
    csNumber?: number;
    /** for custom use */
    csCheck?: boolean;
    /** for custom use */
    csFlag?: boolean;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csContactKey?: string;
    /** for custom use */
    csKey?: string;
    /** date, for custom use */
    csDate?: Date | undefined;
    /** for custom use */
    csWhen?: Date | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an Docr Condition */
export class DocAddress implements IDocAddress {
    /** Key for record */
    DocAddrKey?: string;
    /** To or From */
    AddrType?: string | undefined;
    /** User/Contact(Customer, Vendor), or Manual */
    SourceType?: string | undefined;
    /** When TRUE the corresponding AddrType from the Project Setup is copied here and becomes read only */
    UseSource?: boolean;
    /** Link to user/contact */
    UserKey?: string;
    /** Free form, typically a name */
    Person?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    Addr1?: string | undefined;
    /** Second line of address */
    Addr2?: string | undefined;
    /** City (for address) */
    City?: string | undefined;
    /** For Address */
    State?: string | undefined;
    /** Zipcode for address */
    Zip?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    Phone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Freeform and Informational. Intended for External contacts project reference */
    ContactProject?: string | undefined;
    /** Descriptive name */
    RoleName?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAddrKey = _data["DocAddrKey"];
            this.AddrType = _data["AddrType"];
            this.SourceType = _data["SourceType"];
            this.UseSource = _data["UseSource"];
            this.UserKey = _data["UserKey"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.Phone = _data["Phone"];
            this.Fax = _data["Fax"];
            this.Email = _data["Email"];
            this.ContactProject = _data["ContactProject"];
            this.RoleName = _data["RoleName"];
            this.Title = _data["Title"];
            this.ETag = _data["ETag"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocAddress {
        data = typeof data === 'object' ? data : {};
        let result = new DocAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAddrKey"] = this.DocAddrKey;
        data["AddrType"] = this.AddrType;
        data["SourceType"] = this.SourceType;
        data["UseSource"] = this.UseSource;
        data["UserKey"] = this.UserKey;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["Phone"] = this.Phone;
        data["Fax"] = this.Fax;
        data["Email"] = this.Email;
        data["ContactProject"] = this.ContactProject;
        data["RoleName"] = this.RoleName;
        data["Title"] = this.Title;
        data["ETag"] = this.ETag;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocAddress {
        const json = this.toJSON();
        let result = new DocAddress();
        result.init(json);
        return result;
    }
}

/** Describes an Docr Condition */
export interface IDocAddress {
    /** Key for record */
    DocAddrKey?: string;
    /** To or From */
    AddrType?: string | undefined;
    /** User/Contact(Customer, Vendor), or Manual */
    SourceType?: string | undefined;
    /** When TRUE the corresponding AddrType from the Project Setup is copied here and becomes read only */
    UseSource?: boolean;
    /** Link to user/contact */
    UserKey?: string;
    /** Free form, typically a name */
    Person?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    Addr1?: string | undefined;
    /** Second line of address */
    Addr2?: string | undefined;
    /** City (for address) */
    City?: string | undefined;
    /** For Address */
    State?: string | undefined;
    /** Zipcode for address */
    Zip?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    Phone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Freeform and Informational. Intended for External contacts project reference */
    ContactProject?: string | undefined;
    /** Descriptive name */
    RoleName?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Describes an DocAttachedFile */
export class DocAttachment implements IDocAttachment {
    /** Key of this attachment */
    DocAttachKey?: string;
    /** Optional: Key for attached file */
    DocKey?: string;
    /** Optional: references another routed document */
    AttachedDocMaster?: string;
    /** Weak Link to an item */
    LinkedItemKey?: string;
    /** Resolved to item number of key  */
    AttachedItemNumber?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Indicates route that attached this to the document */
    FromRouteID?: string;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** Current Revision Number when attached */
    AttachedRevID?: number;
    /** View or Update */
    AccessLevel?: string | undefined;
    /** Indicates how this attachment is sent to non-web route parties, eg: 0=never;1=always;M=Assembled;P=PDF (see code set!) */
    MailRoute?: string | undefined;
    /** Controls order of attachments in merges and emails, etc */
    AttachSeq?: number;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference?: string;
    /** Category (Scanned Invoice;Site Photo) */
    CatType?: string;
    /** Status code */
    Status?: string | undefined;
    /** Resolves to cost impact carried by the attachment */
    CostImpact?: number;
    /** Resolves to responsible name of the attachment */
    ResponsibleName?: string | undefined;
    /** Code for Relationship type of attachment */
    RelationshipType?: string | undefined;
    /** Indicates the "folder" where the resource resides */
    ContainerKey?: string;
    /** free form; Text Indexed */
    FileName?: string | undefined;
    /** Free form; text indexed */
    keyword?: string | undefined;
    /** Free format keywords */
    Other?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** Optional; Text Indexed */
    SourceBatchNo?: string | undefined;
    /** Date of source attachment */
    ReferenceDate?: Date;
    /** TIF/DOC/JPG etc */
    FileType?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** link to contact/user; the source  */
    SourceContact?: string;
    /** Approved Revision ID  */
    ApprRevID?: number;
    /** Most recent Revision ID  */
    LastRevID?: number;
    /** External reference */
    SourceRevision?: string | undefined;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** Date and time cataloged  */
    Cataloged?: Date;
    /** Size of native binary data, regardless of current Data storage Method */
    BinSize?: number;
    /** Internal document, output of a routed document */
    sfGenerated?: boolean;
    /** If sfGenerated and current document is ByDocMaster and this field is true, bookmarks are refreshed */
    RefreshBookmarks?: boolean;
    /** When True, e-signature tabs have been detected */
    HasSignTabs?: boolean;
    /** When true, access is strictly restricted */
    Confidential?: boolean;
    /** When true, this attachment is a mirror of the attachment on the other doc */
    IsInherited?: boolean;
    /** When TRUE (default), file is elligible for cloud sync */
    CloudSync?: boolean;
    /** When true, inbound changes are blocked */
    CloudBlockIn?: boolean;
    /** When true, outbound changes are blocked */
    CloudBlockOut?: boolean;
    LastSyncDir?: string | undefined;
    LastSync?: Date;
    /** Key of XTS mapping */
    TDKeyMapKey?: string;
    DocLinks?: number;
    RCLinks?: number;
    /** Key of user that has this attachment checked out */
    CheckOutUser?: string;
    /** Code of current check out status (O==Out; L==Locked, etc) */
    CheckOutStatus?: string | undefined;
    /** When checked out */
    CheckedOut?: Date;
    /** When checked in */
    CheckedIn?: Date;
    /** When checked out will expire on its own */
    Expires?: Date;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttachKey = _data["DocAttachKey"];
            this.DocKey = _data["DocKey"];
            this.AttachedDocMaster = _data["AttachedDocMaster"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.AttachedItemNumber = _data["AttachedItemNumber"];
            this.Note = _data["Note"];
            this.FromUser = _data["FromUser"];
            this.FromRouteID = _data["FromRouteID"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.AttachedRevID = _data["AttachedRevID"];
            this.AccessLevel = _data["AccessLevel"];
            this.MailRoute = _data["MailRoute"];
            this.AttachSeq = _data["AttachSeq"];
            this.DocReference = _data["DocReference"];
            this.CatType = _data["CatType"];
            this.Status = _data["Status"];
            this.CostImpact = _data["CostImpact"];
            this.ResponsibleName = _data["ResponsibleName"];
            this.RelationshipType = _data["RelationshipType"];
            this.ContainerKey = _data["ContainerKey"];
            this.FileName = _data["FileName"];
            this.keyword = _data["keyword"];
            this.Other = _data["Other"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.SourceBatchNo = _data["SourceBatchNo"];
            this.ReferenceDate = _data["ReferenceDate"] ? new Date(_data["ReferenceDate"].toString()) : <any>undefined;
            this.FileType = _data["FileType"];
            this.Project = _data["Project"];
            this.DivisionID = _data["DivisionID"];
            this.SourceContact = _data["SourceContact"];
            this.ApprRevID = _data["ApprRevID"];
            this.LastRevID = _data["LastRevID"];
            this.SourceRevision = _data["SourceRevision"];
            this.DataHash = _data["DataHash"];
            this.Cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.BinSize = _data["BinSize"];
            this.sfGenerated = _data["sfGenerated"];
            this.RefreshBookmarks = _data["RefreshBookmarks"];
            this.HasSignTabs = _data["HasSignTabs"];
            this.Confidential = _data["Confidential"];
            this.IsInherited = _data["IsInherited"];
            this.CloudSync = _data["CloudSync"];
            this.CloudBlockIn = _data["CloudBlockIn"];
            this.CloudBlockOut = _data["CloudBlockOut"];
            this.LastSyncDir = _data["LastSyncDir"];
            this.LastSync = _data["LastSync"] ? new Date(_data["LastSync"].toString()) : <any>undefined;
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.DocLinks = _data["DocLinks"];
            this.RCLinks = _data["RCLinks"];
            this.CheckOutUser = _data["CheckOutUser"];
            this.CheckOutStatus = _data["CheckOutStatus"];
            this.CheckedOut = _data["CheckedOut"] ? new Date(_data["CheckedOut"].toString()) : <any>undefined;
            this.CheckedIn = _data["CheckedIn"] ? new Date(_data["CheckedIn"].toString()) : <any>undefined;
            this.Expires = _data["Expires"] ? new Date(_data["Expires"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new DocAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.DocAttachKey;
        data["DocKey"] = this.DocKey;
        data["AttachedDocMaster"] = this.AttachedDocMaster;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["AttachedItemNumber"] = this.AttachedItemNumber;
        data["Note"] = this.Note;
        data["FromUser"] = this.FromUser;
        data["FromRouteID"] = this.FromRouteID;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["AttachedRevID"] = this.AttachedRevID;
        data["AccessLevel"] = this.AccessLevel;
        data["MailRoute"] = this.MailRoute;
        data["AttachSeq"] = this.AttachSeq;
        data["DocReference"] = this.DocReference;
        data["CatType"] = this.CatType;
        data["Status"] = this.Status;
        data["CostImpact"] = this.CostImpact;
        data["ResponsibleName"] = this.ResponsibleName;
        data["RelationshipType"] = this.RelationshipType;
        data["ContainerKey"] = this.ContainerKey;
        data["FileName"] = this.FileName;
        data["keyword"] = this.keyword;
        data["Other"] = this.Other;
        data["SourceDocNo"] = this.SourceDocNo;
        data["SourceBatchNo"] = this.SourceBatchNo;
        data["ReferenceDate"] = this.ReferenceDate ? this.ReferenceDate.toISOString() : <any>undefined;
        data["FileType"] = this.FileType;
        data["Project"] = this.Project;
        data["DivisionID"] = this.DivisionID;
        data["SourceContact"] = this.SourceContact;
        data["ApprRevID"] = this.ApprRevID;
        data["LastRevID"] = this.LastRevID;
        data["SourceRevision"] = this.SourceRevision;
        data["DataHash"] = this.DataHash;
        data["Cataloged"] = this.Cataloged ? this.Cataloged.toISOString() : <any>undefined;
        data["BinSize"] = this.BinSize;
        data["sfGenerated"] = this.sfGenerated;
        data["RefreshBookmarks"] = this.RefreshBookmarks;
        data["HasSignTabs"] = this.HasSignTabs;
        data["Confidential"] = this.Confidential;
        data["IsInherited"] = this.IsInherited;
        data["CloudSync"] = this.CloudSync;
        data["CloudBlockIn"] = this.CloudBlockIn;
        data["CloudBlockOut"] = this.CloudBlockOut;
        data["LastSyncDir"] = this.LastSyncDir;
        data["LastSync"] = this.LastSync ? this.LastSync.toISOString() : <any>undefined;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["DocLinks"] = this.DocLinks;
        data["RCLinks"] = this.RCLinks;
        data["CheckOutUser"] = this.CheckOutUser;
        data["CheckOutStatus"] = this.CheckOutStatus;
        data["CheckedOut"] = this.CheckedOut ? this.CheckedOut.toISOString() : <any>undefined;
        data["CheckedIn"] = this.CheckedIn ? this.CheckedIn.toISOString() : <any>undefined;
        data["Expires"] = this.Expires ? this.Expires.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocAttachment {
        const json = this.toJSON();
        let result = new DocAttachment();
        result.init(json);
        return result;
    }
}

/** Describes an DocAttachedFile */
export interface IDocAttachment {
    /** Key of this attachment */
    DocAttachKey?: string;
    /** Optional: Key for attached file */
    DocKey?: string;
    /** Optional: references another routed document */
    AttachedDocMaster?: string;
    /** Weak Link to an item */
    LinkedItemKey?: string;
    /** Resolved to item number of key  */
    AttachedItemNumber?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Links to a user/contact  */
    FromUser?: string;
    /** Indicates route that attached this to the document */
    FromRouteID?: string;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created?: Date;
    /** Current Revision Number when attached */
    AttachedRevID?: number;
    /** View or Update */
    AccessLevel?: string | undefined;
    /** Indicates how this attachment is sent to non-web route parties, eg: 0=never;1=always;M=Assembled;P=PDF (see code set!) */
    MailRoute?: string | undefined;
    /** Controls order of attachments in merges and emails, etc */
    AttachSeq?: number;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference?: string;
    /** Category (Scanned Invoice;Site Photo) */
    CatType?: string;
    /** Status code */
    Status?: string | undefined;
    /** Resolves to cost impact carried by the attachment */
    CostImpact?: number;
    /** Resolves to responsible name of the attachment */
    ResponsibleName?: string | undefined;
    /** Code for Relationship type of attachment */
    RelationshipType?: string | undefined;
    /** Indicates the "folder" where the resource resides */
    ContainerKey?: string;
    /** free form; Text Indexed */
    FileName?: string | undefined;
    /** Free form; text indexed */
    keyword?: string | undefined;
    /** Free format keywords */
    Other?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** Optional; Text Indexed */
    SourceBatchNo?: string | undefined;
    /** Date of source attachment */
    ReferenceDate?: Date;
    /** TIF/DOC/JPG etc */
    FileType?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** link to contact/user; the source  */
    SourceContact?: string;
    /** Approved Revision ID  */
    ApprRevID?: number;
    /** Most recent Revision ID  */
    LastRevID?: number;
    /** External reference */
    SourceRevision?: string | undefined;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** Date and time cataloged  */
    Cataloged?: Date;
    /** Size of native binary data, regardless of current Data storage Method */
    BinSize?: number;
    /** Internal document, output of a routed document */
    sfGenerated?: boolean;
    /** If sfGenerated and current document is ByDocMaster and this field is true, bookmarks are refreshed */
    RefreshBookmarks?: boolean;
    /** When True, e-signature tabs have been detected */
    HasSignTabs?: boolean;
    /** When true, access is strictly restricted */
    Confidential?: boolean;
    /** When true, this attachment is a mirror of the attachment on the other doc */
    IsInherited?: boolean;
    /** When TRUE (default), file is elligible for cloud sync */
    CloudSync?: boolean;
    /** When true, inbound changes are blocked */
    CloudBlockIn?: boolean;
    /** When true, outbound changes are blocked */
    CloudBlockOut?: boolean;
    LastSyncDir?: string | undefined;
    LastSync?: Date;
    /** Key of XTS mapping */
    TDKeyMapKey?: string;
    DocLinks?: number;
    RCLinks?: number;
    /** Key of user that has this attachment checked out */
    CheckOutUser?: string;
    /** Code of current check out status (O==Out; L==Locked, etc) */
    CheckOutStatus?: string | undefined;
    /** When checked out */
    CheckedOut?: Date;
    /** When checked in */
    CheckedIn?: Date;
    /** When checked out will expire on its own */
    Expires?: Date;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Describes an DocInclusion Condition */
export class DocInclusion implements IDocInclusion {
    /** Key to this contract annotation */
    InclusionKey?: string;
    /** See code list */
    ItemType?: string | undefined;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    csContactKey?: string;
    csKey?: string;
    /** FreeForm */
    ItemText?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocInclusion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.InclusionKey = _data["InclusionKey"];
            this.ItemType = _data["ItemType"];
            this.ItemNumber = _data["ItemNumber"];
            this.Paragraph = _data["Paragraph"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.ItemText = _data["ItemText"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocInclusion {
        data = typeof data === 'object' ? data : {};
        let result = new DocInclusion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["InclusionKey"] = this.InclusionKey;
        data["ItemType"] = this.ItemType;
        data["ItemNumber"] = this.ItemNumber;
        data["Paragraph"] = this.Paragraph;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["ItemText"] = this.ItemText;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocInclusion {
        const json = this.toJSON();
        let result = new DocInclusion();
        result.init(json);
        return result;
    }
}

/** Describes an DocInclusion Condition */
export interface IDocInclusion {
    /** Key to this contract annotation */
    InclusionKey?: string;
    /** See code list */
    ItemType?: string | undefined;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    csContactKey?: string;
    csKey?: string;
    /** FreeForm */
    ItemText?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocCompliance Condition */
export class DocCompliance implements IDocCompliance {
    /** Key for this compliance item */
    ComplianceItemKey?: string;
    /** Reference to compliance type */
    ComplianceTypeKey?: string;
    /** Weak reference xsfUser; set by data layer each time a user changes the Released column value */
    LastReleasedBy?: string;
    /** Reference to document to notifiy party about compliance issue */
    NotificationDocKey?: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Informational */
    Carrier?: string | undefined;
    /** Brief description of last compliance item */
    LastReason?: string | undefined;
    /** See Code List "Recur" */
    Recurs?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** No longer used */
    CertificateReqd?: boolean;
    /** OUTPUT of compliance engine. When true, this item was deemed in compliance at last evaluation */
    Complied?: boolean;
    /** When true, this compliance item can generate alerts and notifications */
    Alerts?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** Applied to comparison of current date and expiration to resolve "expires soon" */
    LeadDays?: number;
    /** Amount; Optionally compared to total current subcontract amount to determine compliance */
    Amount?: number;
    /** Out of compliance when this date is compared to the Subcontract Current Start Date */
    Effective?: Date | undefined;
    /** Date of Expiration  */
    Expiration?: Date | undefined;
    /** Only editable if type has AllowProof set true.?? When NULL, defaults to the parent document due date */
    RequiredBy?: Date | undefined;
    /** When this field is set, the item is in compliance. Period! */
    Released?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** When Alert was generated */
    LastAlertWas?: Date | undefined;
    /** For recurring alerts: set to indicate the next point in time that alerts will be considered */
    NextAlertAfter?: Date | undefined;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired?: boolean;
    /** Display name of compliance type */
    ComplianceName?: string | undefined;
    /** When true, this compliance item is dynamically evaluated by the system */
    AutoControl?: boolean;
    /** When true, the description field is editable */
    AllowDescription?: boolean;
    /** Track carrier field on compliance items */
    AllowCarrier?: boolean;
    /** When true, the RequiredBy and Received compliance fields are editable */
    AllowProof?: boolean;
    /** Track amount */
    AllowAmount?: boolean;
    /** Track effective date */
    AllowEffective?: boolean;
    /** Track expiration date */
    AllowExpiration?: boolean;
    /** Track lead days on items */
    AllowLeadDays?: boolean;
    /** Not used! */
    AllowRecurs?: boolean;
    /** Allows multiple compliance items of the same type */
    AllowMultiple?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocCompliance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ComplianceItemKey = _data["ComplianceItemKey"];
            this.ComplianceTypeKey = _data["ComplianceTypeKey"];
            this.LastReleasedBy = _data["LastReleasedBy"];
            this.NotificationDocKey = _data["NotificationDocKey"];
            this.Description = _data["Description"];
            this.Carrier = _data["Carrier"];
            this.LastReason = _data["LastReason"];
            this.Recurs = _data["Recurs"];
            this.PayControl = _data["PayControl"];
            this.CertificateReqd = _data["CertificateReqd"];
            this.Complied = _data["Complied"];
            this.Alerts = _data["Alerts"];
            this.Active = _data["Active"];
            this.LeadDays = _data["LeadDays"];
            this.Amount = _data["Amount"];
            this.Effective = _data["Effective"] ? new Date(_data["Effective"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.RequiredBy = _data["RequiredBy"] ? new Date(_data["RequiredBy"].toString()) : <any>undefined;
            this.Released = _data["Released"] ? new Date(_data["Released"].toString()) : <any>undefined;
            this.Received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.LastAlertWas = _data["LastAlertWas"] ? new Date(_data["LastAlertWas"].toString()) : <any>undefined;
            this.NextAlertAfter = _data["NextAlertAfter"] ? new Date(_data["NextAlertAfter"].toString()) : <any>undefined;
            this.IsRequired = _data["IsRequired"];
            this.ComplianceName = _data["ComplianceName"];
            this.AutoControl = _data["AutoControl"];
            this.AllowDescription = _data["AllowDescription"];
            this.AllowCarrier = _data["AllowCarrier"];
            this.AllowProof = _data["AllowProof"];
            this.AllowAmount = _data["AllowAmount"];
            this.AllowEffective = _data["AllowEffective"];
            this.AllowExpiration = _data["AllowExpiration"];
            this.AllowLeadDays = _data["AllowLeadDays"];
            this.AllowRecurs = _data["AllowRecurs"];
            this.AllowMultiple = _data["AllowMultiple"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocCompliance {
        data = typeof data === 'object' ? data : {};
        let result = new DocCompliance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ComplianceItemKey"] = this.ComplianceItemKey;
        data["ComplianceTypeKey"] = this.ComplianceTypeKey;
        data["LastReleasedBy"] = this.LastReleasedBy;
        data["NotificationDocKey"] = this.NotificationDocKey;
        data["Description"] = this.Description;
        data["Carrier"] = this.Carrier;
        data["LastReason"] = this.LastReason;
        data["Recurs"] = this.Recurs;
        data["PayControl"] = this.PayControl;
        data["CertificateReqd"] = this.CertificateReqd;
        data["Complied"] = this.Complied;
        data["Alerts"] = this.Alerts;
        data["Active"] = this.Active;
        data["LeadDays"] = this.LeadDays;
        data["Amount"] = this.Amount;
        data["Effective"] = this.Effective ? this.Effective.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["RequiredBy"] = this.RequiredBy ? this.RequiredBy.toISOString() : <any>undefined;
        data["Released"] = this.Released ? this.Released.toISOString() : <any>undefined;
        data["Received"] = this.Received ? this.Received.toISOString() : <any>undefined;
        data["LastAlertWas"] = this.LastAlertWas ? this.LastAlertWas.toISOString() : <any>undefined;
        data["NextAlertAfter"] = this.NextAlertAfter ? this.NextAlertAfter.toISOString() : <any>undefined;
        data["IsRequired"] = this.IsRequired;
        data["ComplianceName"] = this.ComplianceName;
        data["AutoControl"] = this.AutoControl;
        data["AllowDescription"] = this.AllowDescription;
        data["AllowCarrier"] = this.AllowCarrier;
        data["AllowProof"] = this.AllowProof;
        data["AllowAmount"] = this.AllowAmount;
        data["AllowEffective"] = this.AllowEffective;
        data["AllowExpiration"] = this.AllowExpiration;
        data["AllowLeadDays"] = this.AllowLeadDays;
        data["AllowRecurs"] = this.AllowRecurs;
        data["AllowMultiple"] = this.AllowMultiple;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocCompliance {
        const json = this.toJSON();
        let result = new DocCompliance();
        result.init(json);
        return result;
    }
}

/** Describes an DocCompliance Condition */
export interface IDocCompliance {
    /** Key for this compliance item */
    ComplianceItemKey?: string;
    /** Reference to compliance type */
    ComplianceTypeKey?: string;
    /** Weak reference xsfUser; set by data layer each time a user changes the Released column value */
    LastReleasedBy?: string;
    /** Reference to document to notifiy party about compliance issue */
    NotificationDocKey?: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Informational */
    Carrier?: string | undefined;
    /** Brief description of last compliance item */
    LastReason?: string | undefined;
    /** See Code List "Recur" */
    Recurs?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** No longer used */
    CertificateReqd?: boolean;
    /** OUTPUT of compliance engine. When true, this item was deemed in compliance at last evaluation */
    Complied?: boolean;
    /** When true, this compliance item can generate alerts and notifications */
    Alerts?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** Applied to comparison of current date and expiration to resolve "expires soon" */
    LeadDays?: number;
    /** Amount; Optionally compared to total current subcontract amount to determine compliance */
    Amount?: number;
    /** Out of compliance when this date is compared to the Subcontract Current Start Date */
    Effective?: Date | undefined;
    /** Date of Expiration  */
    Expiration?: Date | undefined;
    /** Only editable if type has AllowProof set true.?? When NULL, defaults to the parent document due date */
    RequiredBy?: Date | undefined;
    /** When this field is set, the item is in compliance. Period! */
    Released?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** When Alert was generated */
    LastAlertWas?: Date | undefined;
    /** For recurring alerts: set to indicate the next point in time that alerts will be considered */
    NextAlertAfter?: Date | undefined;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired?: boolean;
    /** Display name of compliance type */
    ComplianceName?: string | undefined;
    /** When true, this compliance item is dynamically evaluated by the system */
    AutoControl?: boolean;
    /** When true, the description field is editable */
    AllowDescription?: boolean;
    /** Track carrier field on compliance items */
    AllowCarrier?: boolean;
    /** When true, the RequiredBy and Received compliance fields are editable */
    AllowProof?: boolean;
    /** Track amount */
    AllowAmount?: boolean;
    /** Track effective date */
    AllowEffective?: boolean;
    /** Track expiration date */
    AllowExpiration?: boolean;
    /** Track lead days on items */
    AllowLeadDays?: boolean;
    /** Not used! */
    AllowRecurs?: boolean;
    /** Allows multiple compliance items of the same type */
    AllowMultiple?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocMeetingAttendee Condition */
export class DocMeetingAttendee implements IDocMeetingAttendee {
    /** Key for this attendee */
    AttendeeKey?: string;
    /** Link to user/contact */
    UserKey?: string;
    /** Weak Link to another item */
    LinkedItemKey?: string;
    /** Attendee Name */
    AttendeeName?: string | undefined;
    /** Reference to Item number */
    Reference?: string | undefined;
    /** Free form  */
    Purpose?: string | undefined;
    /** Amount */
    Amount?: number;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    Resolved?: Date;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    csContactKey?: string;
    csKey?: string;
    Present?: boolean;
    /** When TRUE, auto copied to next meeting */
    IsRegular?: boolean;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    /** Free form */
    Note?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocMeetingAttendee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AttendeeKey = _data["AttendeeKey"];
            this.UserKey = _data["UserKey"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.AttendeeName = _data["AttendeeName"];
            this.Reference = _data["Reference"];
            this.Purpose = _data["Purpose"];
            this.Amount = _data["Amount"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.Resolved = _data["Resolved"] ? new Date(_data["Resolved"].toString()) : <any>undefined;
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.Present = _data["Present"];
            this.IsRegular = _data["IsRegular"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.Note = _data["Note"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocMeetingAttendee {
        data = typeof data === 'object' ? data : {};
        let result = new DocMeetingAttendee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttendeeKey"] = this.AttendeeKey;
        data["UserKey"] = this.UserKey;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["AttendeeName"] = this.AttendeeName;
        data["Reference"] = this.Reference;
        data["Purpose"] = this.Purpose;
        data["Amount"] = this.Amount;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["Resolved"] = this.Resolved ? this.Resolved.toISOString() : <any>undefined;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["Present"] = this.Present;
        data["IsRegular"] = this.IsRegular;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.Note;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocMeetingAttendee {
        const json = this.toJSON();
        let result = new DocMeetingAttendee();
        result.init(json);
        return result;
    }
}

/** Describes an DocMeetingAttendee Condition */
export interface IDocMeetingAttendee {
    /** Key for this attendee */
    AttendeeKey?: string;
    /** Link to user/contact */
    UserKey?: string;
    /** Weak Link to another item */
    LinkedItemKey?: string;
    /** Attendee Name */
    AttendeeName?: string | undefined;
    /** Reference to Item number */
    Reference?: string | undefined;
    /** Free form  */
    Purpose?: string | undefined;
    /** Amount */
    Amount?: number;
    /** Amount, for custom use */
    csAmount?: number;
    csValue?: number;
    csQty?: number;
    csNumber?: number;
    Resolved?: Date;
    /** date, for custom use */
    csDate?: Date;
    csWhen?: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    csContactKey?: string;
    csKey?: string;
    Present?: boolean;
    /** When TRUE, auto copied to next meeting */
    IsRegular?: boolean;
    /** for custom use */
    csCheck?: boolean;
    csFlag?: boolean;
    /** Free form */
    Note?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an DocInstruction Condition */
export class DocAttribute implements IDocAttribute {
    DocAttributeKey?: string;
    /** Indicates the set of attributes from which this row was derived */
    AttrType?: string | undefined;
    /** Specifies the specific attribute of the set */
    AttrValue?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Amount */
    Amount?: number;
    /** pjcosubd.change_units */
    Quantity?: number;
    /** System table */
    Value?: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form */
    Recorded?: Date;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IDocAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttributeKey = _data["DocAttributeKey"];
            this.AttrType = _data["AttrType"];
            this.AttrValue = _data["AttrValue"];
            this.Paragraph = _data["Paragraph"];
            this.Specification = _data["Specification"];
            this.Amount = _data["Amount"];
            this.Quantity = _data["Quantity"];
            this.Value = _data["Value"];
            this.Description = _data["Description"];
            this.Note = _data["Note"];
            this.Recorded = _data["Recorded"] ? new Date(_data["Recorded"].toString()) : <any>undefined;
            this.Reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): DocAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new DocAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttributeKey"] = this.DocAttributeKey;
        data["AttrType"] = this.AttrType;
        data["AttrValue"] = this.AttrValue;
        data["Paragraph"] = this.Paragraph;
        data["Specification"] = this.Specification;
        data["Amount"] = this.Amount;
        data["Quantity"] = this.Quantity;
        data["Value"] = this.Value;
        data["Description"] = this.Description;
        data["Note"] = this.Note;
        data["Recorded"] = this.Recorded ? this.Recorded.toISOString() : <any>undefined;
        data["Reviewed"] = this.Reviewed ? this.Reviewed.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): DocAttribute {
        const json = this.toJSON();
        let result = new DocAttribute();
        result.init(json);
        return result;
    }
}

/** Describes an DocInstruction Condition */
export interface IDocAttribute {
    DocAttributeKey?: string;
    /** Indicates the set of attributes from which this row was derived */
    AttrType?: string | undefined;
    /** Specifies the specific attribute of the set */
    AttrValue?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Amount */
    Amount?: number;
    /** pjcosubd.change_units */
    Quantity?: number;
    /** System table */
    Value?: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form */
    Recorded?: Date;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** Summary of Project Process (Document) types */
export class ProcessDocumentType implements IProcessDocumentType {
    /** Key for Process Type */
    DocTypeKey!: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** String Site Name for this Process   */
    SiteName?: string | undefined;
    /** When True, shown on project dashboards */
    ProjectDashboard?: boolean;
    /** When True, can create from project dashboard */
    NewFromDashboard?: boolean;
    /** When True, is created from a parent document */
    CreateFromParent?: boolean;
    /** When True, uses an item register */
    UseItemRegister?: boolean;
    /** When True, is Site Active */
    SiteActive?: boolean;
    /** Key for optional parent Process Type (commitment and cco) */
    ParentTypeKey?: string | undefined;
    /** When true, this is a locally defined Process Type (specific to this site) */
    Custom?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProcessDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.SiteName = _data["SiteName"];
            this.ProjectDashboard = _data["ProjectDashboard"];
            this.NewFromDashboard = _data["NewFromDashboard"];
            this.CreateFromParent = _data["CreateFromParent"];
            this.UseItemRegister = _data["UseItemRegister"];
            this.SiteActive = _data["SiteActive"];
            this.ParentTypeKey = _data["ParentTypeKey"];
            this.Custom = _data["Custom"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProcessDocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["SiteName"] = this.SiteName;
        data["ProjectDashboard"] = this.ProjectDashboard;
        data["NewFromDashboard"] = this.NewFromDashboard;
        data["CreateFromParent"] = this.CreateFromParent;
        data["UseItemRegister"] = this.UseItemRegister;
        data["SiteActive"] = this.SiteActive;
        data["ParentTypeKey"] = this.ParentTypeKey;
        data["Custom"] = this.Custom;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProcessDocumentType {
        const json = this.toJSON();
        let result = new ProcessDocumentType();
        result.init(json);
        return result;
    }
}

/** Summary of Project Process (Document) types */
export interface IProcessDocumentType {
    /** Key for Process Type */
    DocTypeKey: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** String Site Name for this Process   */
    SiteName?: string | undefined;
    /** When True, shown on project dashboards */
    ProjectDashboard?: boolean;
    /** When True, can create from project dashboard */
    NewFromDashboard?: boolean;
    /** When True, is created from a parent document */
    CreateFromParent?: boolean;
    /** When True, uses an item register */
    UseItemRegister?: boolean;
    /** When True, is Site Active */
    SiteActive?: boolean;
    /** Key for optional parent Process Type (commitment and cco) */
    ParentTypeKey?: string | undefined;
    /** When true, this is a locally defined Process Type (specific to this site) */
    Custom?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Information about a connected User */
export class UserSessionInfo implements IUserSessionInfo {
    /** Name of User */
    UserName!: string;
    /** System */
    MachineName?: string | undefined;
    /** When connected */
    Since?: Date;
    LastURI?: string | undefined;
    LastReqInfo?: string | undefined;
    LastContext?: string | undefined;
    /** Number of requests */
    ReqCount?: number;
    /** session id */
    SessionID?: string | undefined;
    /** Agent Device  */
    AgentInfo?: string | undefined;
    /** Summary of Agent device */
    AgentSummary?: string | undefined;
    /** Key of user  */
    UserKey?: string;

    constructor(data?: IUserSessionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserName = _data["UserName"];
            this.MachineName = _data["MachineName"];
            this.Since = _data["Since"] ? new Date(_data["Since"].toString()) : <any>undefined;
            this.LastURI = _data["LastURI"];
            this.LastReqInfo = _data["LastReqInfo"];
            this.LastContext = _data["LastContext"];
            this.ReqCount = _data["ReqCount"];
            this.SessionID = _data["SessionID"];
            this.AgentInfo = _data["AgentInfo"];
            this.AgentSummary = _data["AgentSummary"];
            this.UserKey = _data["UserKey"];
        }
    }

    static fromJS(data: any): UserSessionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.UserName;
        data["MachineName"] = this.MachineName;
        data["Since"] = this.Since ? this.Since.toISOString() : <any>undefined;
        data["LastURI"] = this.LastURI;
        data["LastReqInfo"] = this.LastReqInfo;
        data["LastContext"] = this.LastContext;
        data["ReqCount"] = this.ReqCount;
        data["SessionID"] = this.SessionID;
        data["AgentInfo"] = this.AgentInfo;
        data["AgentSummary"] = this.AgentSummary;
        data["UserKey"] = this.UserKey;
        return data;
    }

    clone(): UserSessionInfo {
        const json = this.toJSON();
        let result = new UserSessionInfo();
        result.init(json);
        return result;
    }
}

/** Information about a connected User */
export interface IUserSessionInfo {
    /** Name of User */
    UserName: string;
    /** System */
    MachineName?: string | undefined;
    /** When connected */
    Since?: Date;
    LastURI?: string | undefined;
    LastReqInfo?: string | undefined;
    LastContext?: string | undefined;
    /** Number of requests */
    ReqCount?: number;
    /** session id */
    SessionID?: string | undefined;
    /** Agent Device  */
    AgentInfo?: string | undefined;
    /** Summary of Agent device */
    AgentSummary?: string | undefined;
    /** Key of user  */
    UserKey?: string;
}

/** Abstracted information about a project, see ProjectToolsClient.GetProjectDetail() */
export class ProjectAbstract implements IProjectAbstract {
    /** Project ID */
    Project!: string;
    /** Key for Project */
    ProjectKey?: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey?: string;
    /** Key for Site Address */
    SiteAddrKey?: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold?: number;
    /** Geo latitude (project setup) */
    latitude?: number;
    /** Geo longitude (project setup) */
    longitude?: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey?: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active?: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** The company Division Name for the Division specified on this project setup */
    DivisionName?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate?: Date;
    /** From Dates on project setup */
    ProjectFinishDate?: Date;
    /** From Dates on project setup: the Closeout Date */
    ProjectCloseoutDate?: Date | undefined;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** true if this project is connected to an XTS peer */
    ProjectIsIntegrated?: boolean;
    /** information about the external sync of a project with a peer
             */
    ProjectXTSTaskSummary?: ProjectXTSTaskState[] | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks?: boolean;
    /** When true, disable Note */
    ExcludeNoteUI?: boolean;
    /** When true, disable Links */
    ExcludeLinkUI?: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI?: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI?: boolean;
    /** Indicates this users data context for this project */
    DataContext?: string | undefined;
    /** Indicates when this abstract was generated */
    dataResolved?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectKey = _data["ProjectKey"];
            this.ProjectType = _data["ProjectType"];
            this.SetupDocKey = _data["SetupDocKey"];
            this.SiteAddrKey = _data["SiteAddrKey"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Phone = _data["Phone"];
            this.Fax = _data["Fax"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.SCBudgetMode = _data["SCBudgetMode"];
            this.PlanRoomMode = _data["PlanRoomMode"];
            this.WebCamURL = _data["WebCamURL"];
            this.Description = _data["Description"];
            this.ForecastThreshold = _data["ForecastThreshold"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.cldStoreKey = _data["cldStoreKey"];
            this.CloudDrivePath = _data["CloudDrivePath"];
            this.GLSUB = _data["GLSUB"];
            this.Active = _data["Active"];
            this.Status = _data["Status"];
            this.StatusText = _data["StatusText"];
            this.Subtype = _data["Subtype"];
            this.DocState = _data["DocState"];
            this.ProjectDocReference = _data["ProjectDocReference"];
            this.ProjectUniReference = _data["ProjectUniReference"];
            this.ProjectCustomerID = _data["ProjectCustomerID"];
            this.ProjectCustomerName = _data["ProjectCustomerName"];
            this.ProjectTitle = _data["ProjectTitle"];
            this.ProjectIDMasked = _data["ProjectIDMasked"];
            this.DivisionName = _data["DivisionName"];
            this.ProjectTabName = _data["ProjectTabName"];
            this.ProjectTabTip = _data["ProjectTabTip"];
            this.ProjectBar = _data["ProjectBar"];
            this.ProjectStartDate = _data["ProjectStartDate"] ? new Date(_data["ProjectStartDate"].toString()) : <any>undefined;
            this.ProjectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.ProjectCloseoutDate = _data["ProjectCloseoutDate"] ? new Date(_data["ProjectCloseoutDate"].toString()) : <any>undefined;
            this.ProjectStartFormat = _data["ProjectStartFormat"];
            this.ProjectFinishFormat = _data["ProjectFinishFormat"];
            this.ProjectPhoto = _data["ProjectPhoto"];
            this.ProjectCurrentNote = _data["ProjectCurrentNote"];
            this.ProjectIsIntegrated = _data["ProjectIsIntegrated"];
            if (Array.isArray(_data["ProjectXTSTaskSummary"])) {
                this.ProjectXTSTaskSummary = [] as any;
                for (let item of _data["ProjectXTSTaskSummary"])
                    this.ProjectXTSTaskSummary!.push(ProjectXTSTaskState.fromJS(item));
            }
            if (Array.isArray(_data["actionsMenu"])) {
                this.actionsMenu = [] as any;
                for (let item of _data["actionsMenu"])
                    this.actionsMenu!.push(MenuAction.fromJS(item));
            }
            if (Array.isArray(_data["registerMenu"])) {
                this.registerMenu = [] as any;
                for (let item of _data["registerMenu"])
                    this.registerMenu!.push(MenuAction.fromJS(item));
            }
            this.AlwaysShowLinks = _data["AlwaysShowLinks"];
            this.ExcludeNoteUI = _data["ExcludeNoteUI"];
            this.ExcludeLinkUI = _data["ExcludeLinkUI"];
            this.ExcludeCostAnalysisUI = _data["ExcludeCostAnalysisUI"];
            this.ExcludeKPIUI = _data["ExcludeKPIUI"];
            this.DataContext = _data["DataContext"];
            this.dataResolved = _data["dataResolved"] ? new Date(_data["dataResolved"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectKey"] = this.ProjectKey;
        data["ProjectType"] = this.ProjectType;
        data["SetupDocKey"] = this.SetupDocKey;
        data["SiteAddrKey"] = this.SiteAddrKey;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Phone"] = this.Phone;
        data["Fax"] = this.Fax;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["SCBudgetMode"] = this.SCBudgetMode;
        data["PlanRoomMode"] = this.PlanRoomMode;
        data["WebCamURL"] = this.WebCamURL;
        data["Description"] = this.Description;
        data["ForecastThreshold"] = this.ForecastThreshold;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["cldStoreKey"] = this.cldStoreKey;
        data["CloudDrivePath"] = this.CloudDrivePath;
        data["GLSUB"] = this.GLSUB;
        data["Active"] = this.Active;
        data["Status"] = this.Status;
        data["StatusText"] = this.StatusText;
        data["Subtype"] = this.Subtype;
        data["DocState"] = this.DocState;
        data["ProjectDocReference"] = this.ProjectDocReference;
        data["ProjectUniReference"] = this.ProjectUniReference;
        data["ProjectCustomerID"] = this.ProjectCustomerID;
        data["ProjectCustomerName"] = this.ProjectCustomerName;
        data["ProjectTitle"] = this.ProjectTitle;
        data["ProjectIDMasked"] = this.ProjectIDMasked;
        data["DivisionName"] = this.DivisionName;
        data["ProjectTabName"] = this.ProjectTabName;
        data["ProjectTabTip"] = this.ProjectTabTip;
        data["ProjectBar"] = this.ProjectBar;
        data["ProjectStartDate"] = this.ProjectStartDate ? this.ProjectStartDate.toISOString() : <any>undefined;
        data["ProjectFinishDate"] = this.ProjectFinishDate ? this.ProjectFinishDate.toISOString() : <any>undefined;
        data["ProjectCloseoutDate"] = this.ProjectCloseoutDate ? this.ProjectCloseoutDate.toISOString() : <any>undefined;
        data["ProjectStartFormat"] = this.ProjectStartFormat;
        data["ProjectFinishFormat"] = this.ProjectFinishFormat;
        data["ProjectPhoto"] = this.ProjectPhoto;
        data["ProjectCurrentNote"] = this.ProjectCurrentNote;
        data["ProjectIsIntegrated"] = this.ProjectIsIntegrated;
        if (Array.isArray(this.ProjectXTSTaskSummary)) {
            data["ProjectXTSTaskSummary"] = [];
            for (let item of this.ProjectXTSTaskSummary)
                data["ProjectXTSTaskSummary"].push(item.toJSON());
        }
        if (Array.isArray(this.actionsMenu)) {
            data["actionsMenu"] = [];
            for (let item of this.actionsMenu)
                data["actionsMenu"].push(item.toJSON());
        }
        if (Array.isArray(this.registerMenu)) {
            data["registerMenu"] = [];
            for (let item of this.registerMenu)
                data["registerMenu"].push(item.toJSON());
        }
        data["AlwaysShowLinks"] = this.AlwaysShowLinks;
        data["ExcludeNoteUI"] = this.ExcludeNoteUI;
        data["ExcludeLinkUI"] = this.ExcludeLinkUI;
        data["ExcludeCostAnalysisUI"] = this.ExcludeCostAnalysisUI;
        data["ExcludeKPIUI"] = this.ExcludeKPIUI;
        data["DataContext"] = this.DataContext;
        data["dataResolved"] = this.dataResolved ? this.dataResolved.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectAbstract {
        const json = this.toJSON();
        let result = new ProjectAbstract();
        result.init(json);
        return result;
    }
}

/** Abstracted information about a project, see ProjectToolsClient.GetProjectDetail() */
export interface IProjectAbstract {
    /** Project ID */
    Project: string;
    /** Key for Project */
    ProjectKey?: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey?: string;
    /** Key for Site Address */
    SiteAddrKey?: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold?: number;
    /** Geo latitude (project setup) */
    latitude?: number;
    /** Geo longitude (project setup) */
    longitude?: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey?: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active?: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** The company Division Name for the Division specified on this project setup */
    DivisionName?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate?: Date;
    /** From Dates on project setup */
    ProjectFinishDate?: Date;
    /** From Dates on project setup: the Closeout Date */
    ProjectCloseoutDate?: Date | undefined;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** true if this project is connected to an XTS peer */
    ProjectIsIntegrated?: boolean;
    /** information about the external sync of a project with a peer
             */
    ProjectXTSTaskSummary?: ProjectXTSTaskState[] | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks?: boolean;
    /** When true, disable Note */
    ExcludeNoteUI?: boolean;
    /** When true, disable Links */
    ExcludeLinkUI?: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI?: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI?: boolean;
    /** Indicates this users data context for this project */
    DataContext?: string | undefined;
    /** Indicates when this abstract was generated */
    dataResolved?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** information about the external sync of a project with a peer */
export class ProjectXTSTaskState implements IProjectXTSTaskState {
    /** Internal Name for this type of Sync'd data */
    AlienSet!: string;
    /** Description of this type of sync task;  */
    PeerDataType!: string;
    /** Read, Sent, To Do */
    Direction!: string;
    /** Approximate number of these objects; for Queue, the number completed in the last minute */
    MapCount?: number;
    /** The date and time as of which data for this task should be current */
    AsOf?: Date | undefined;
    /** The highest key currently mapped */
    HighKey?: string | undefined;
    /** The number of failing tasks   */
    Failing?: number;
    /** The number of queued tasks   */
    Queued?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectXTSTaskState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AlienSet = _data["AlienSet"];
            this.PeerDataType = _data["PeerDataType"];
            this.Direction = _data["Direction"];
            this.MapCount = _data["MapCount"];
            this.AsOf = _data["AsOf"] ? new Date(_data["AsOf"].toString()) : <any>undefined;
            this.HighKey = _data["HighKey"];
            this.Failing = _data["Failing"];
            this.Queued = _data["Queued"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectXTSTaskState {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectXTSTaskState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AlienSet"] = this.AlienSet;
        data["PeerDataType"] = this.PeerDataType;
        data["Direction"] = this.Direction;
        data["MapCount"] = this.MapCount;
        data["AsOf"] = this.AsOf ? this.AsOf.toISOString() : <any>undefined;
        data["HighKey"] = this.HighKey;
        data["Failing"] = this.Failing;
        data["Queued"] = this.Queued;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectXTSTaskState {
        const json = this.toJSON();
        let result = new ProjectXTSTaskState();
        result.init(json);
        return result;
    }
}

/** information about the external sync of a project with a peer */
export interface IProjectXTSTaskState {
    /** Internal Name for this type of Sync'd data */
    AlienSet: string;
    /** Description of this type of sync task;  */
    PeerDataType: string;
    /** Read, Sent, To Do */
    Direction: string;
    /** Approximate number of these objects; for Queue, the number completed in the last minute */
    MapCount?: number;
    /** The date and time as of which data for this task should be current */
    AsOf?: Date | undefined;
    /** The highest key currently mapped */
    HighKey?: string | undefined;
    /** The number of failing tasks   */
    Failing?: number;
    /** The number of queued tasks   */
    Queued?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** Attributes describing a Link to a parent or child  project */
export class ProjectLink implements IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey!: string;
    /** Key for document that owns the link */
    DocMasterKey?: string;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart?: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish?: Date;
    /** EAC Contract Value  */
    CurrentContract?: number;
    /** When True, this is a child project */
    IsChild?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttachKey = _data["DocAttachKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.LinkedProjectContractKey = _data["LinkedProjectContractKey"];
            this.Project = _data["Project"];
            this.Title = _data["Title"];
            this.Location = _data["Location"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.StatusDescription = _data["StatusDescription"];
            this.ProjectStart = _data["ProjectStart"] ? new Date(_data["ProjectStart"].toString()) : <any>undefined;
            this.ProjectFinish = _data["ProjectFinish"] ? new Date(_data["ProjectFinish"].toString()) : <any>undefined;
            this.CurrentContract = _data["CurrentContract"];
            this.IsChild = _data["IsChild"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.DocAttachKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["LinkedProjectContractKey"] = this.LinkedProjectContractKey;
        data["Project"] = this.Project;
        data["Title"] = this.Title;
        data["Location"] = this.Location;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["StatusDescription"] = this.StatusDescription;
        data["ProjectStart"] = this.ProjectStart ? this.ProjectStart.toISOString() : <any>undefined;
        data["ProjectFinish"] = this.ProjectFinish ? this.ProjectFinish.toISOString() : <any>undefined;
        data["CurrentContract"] = this.CurrentContract;
        data["IsChild"] = this.IsChild;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectLink {
        const json = this.toJSON();
        let result = new ProjectLink();
        result.init(json);
        return result;
    }
}

/** Attributes describing a Link to a parent or child  project */
export interface IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey: string;
    /** Key for document that owns the link */
    DocMasterKey?: string;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart?: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish?: Date;
    /** EAC Contract Value  */
    CurrentContract?: number;
    /** When True, this is a child project */
    IsChild?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes an WB Code that is part of a Project WBS */
export class ProjectWBS implements IProjectWBS {
    /** Row Key */
    ProjectWBSKey?: string;
    /** ID of Project  */
    Project?: string | undefined;
    /** Work Breakdown code, often a combination of a CSI and phase */
    WBCode?: string | undefined;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** Status code */
    Status?: string | undefined;
    /** Links WBS item to a SOV item */
    SOVLine?: string | undefined;
    /** DMK of SOV that adds this line */
    SOVRootDMK?: string;
    /** Date scheduled to start */
    SchedStart?: Date;
    /** Date scheduled to finish */
    SchedFinish?: Date;
    /** Date of actual start */
    ActStart?: Date;
    /** Date of actual finish */
    ActFinish?: Date;
    /** Percent Complete */
    PercentComplete?: number;
    /** CP, FP or UP  */
    CostingMethod?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectWBS) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ProjectWBSKey = _data["ProjectWBSKey"];
            this.Project = _data["Project"];
            this.WBCode = _data["WBCode"];
            this.Description = _data["Description"];
            this.ContractType = _data["ContractType"];
            this.UOM = _data["UOM"];
            this.Status = _data["Status"];
            this.SOVLine = _data["SOVLine"];
            this.SOVRootDMK = _data["SOVRootDMK"];
            this.SchedStart = _data["SchedStart"] ? new Date(_data["SchedStart"].toString()) : <any>undefined;
            this.SchedFinish = _data["SchedFinish"] ? new Date(_data["SchedFinish"].toString()) : <any>undefined;
            this.ActStart = _data["ActStart"] ? new Date(_data["ActStart"].toString()) : <any>undefined;
            this.ActFinish = _data["ActFinish"] ? new Date(_data["ActFinish"].toString()) : <any>undefined;
            this.PercentComplete = _data["PercentComplete"];
            this.CostingMethod = _data["CostingMethod"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectWBS {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWBS();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectWBSKey"] = this.ProjectWBSKey;
        data["Project"] = this.Project;
        data["WBCode"] = this.WBCode;
        data["Description"] = this.Description;
        data["ContractType"] = this.ContractType;
        data["UOM"] = this.UOM;
        data["Status"] = this.Status;
        data["SOVLine"] = this.SOVLine;
        data["SOVRootDMK"] = this.SOVRootDMK;
        data["SchedStart"] = this.SchedStart ? this.SchedStart.toISOString() : <any>undefined;
        data["SchedFinish"] = this.SchedFinish ? this.SchedFinish.toISOString() : <any>undefined;
        data["ActStart"] = this.ActStart ? this.ActStart.toISOString() : <any>undefined;
        data["ActFinish"] = this.ActFinish ? this.ActFinish.toISOString() : <any>undefined;
        data["PercentComplete"] = this.PercentComplete;
        data["CostingMethod"] = this.CostingMethod;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectWBS {
        const json = this.toJSON();
        let result = new ProjectWBS();
        result.init(json);
        return result;
    }
}

/** Describes an WB Code that is part of a Project WBS */
export interface IProjectWBS {
    /** Row Key */
    ProjectWBSKey?: string;
    /** ID of Project  */
    Project?: string | undefined;
    /** Work Breakdown code, often a combination of a CSI and phase */
    WBCode?: string | undefined;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** Status code */
    Status?: string | undefined;
    /** Links WBS item to a SOV item */
    SOVLine?: string | undefined;
    /** DMK of SOV that adds this line */
    SOVRootDMK?: string;
    /** Date scheduled to start */
    SchedStart?: Date;
    /** Date scheduled to finish */
    SchedFinish?: Date;
    /** Date of actual start */
    ActStart?: Date;
    /** Date of actual finish */
    ActFinish?: Date;
    /** Percent Complete */
    PercentComplete?: number;
    /** CP, FP or UP  */
    CostingMethod?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Primary Site Weather Now */
export class ProjectWeatherNow implements IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer?: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint?: number;
    /** Feels Like */
    FeelsLike?: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity?: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained?: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature?: number;
    /** Visibility (miles) */
    Visibility?: number;
    /** Wind (MPH) */
    Wind?: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zip Code for which this reading was obtained */
    ZipCode?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectWeatherNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.At = _data["At"];
            this.Barometer = _data["Barometer"];
            this.Condition = _data["Condition"];
            this.DewPoint = _data["DewPoint"];
            this.FeelsLike = _data["FeelsLike"];
            this.Forecast = _data["Forecast"];
            this.Humidity = _data["Humidity"];
            this.Icon = _data["Icon"];
            this.Obtained = _data["Obtained"] ? new Date(_data["Obtained"].toString()) : <any>undefined;
            this.Provider = _data["Provider"];
            this.Reported = _data["Reported"];
            this.Temperature = _data["Temperature"];
            this.Visibility = _data["Visibility"];
            this.Wind = _data["Wind"];
            this.WindInfo = _data["WindInfo"];
            this.ZipCode = _data["ZipCode"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectWeatherNow {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWeatherNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["At"] = this.At;
        data["Barometer"] = this.Barometer;
        data["Condition"] = this.Condition;
        data["DewPoint"] = this.DewPoint;
        data["FeelsLike"] = this.FeelsLike;
        data["Forecast"] = this.Forecast;
        data["Humidity"] = this.Humidity;
        data["Icon"] = this.Icon;
        data["Obtained"] = this.Obtained ? this.Obtained.toISOString() : <any>undefined;
        data["Provider"] = this.Provider;
        data["Reported"] = this.Reported;
        data["Temperature"] = this.Temperature;
        data["Visibility"] = this.Visibility;
        data["Wind"] = this.Wind;
        data["WindInfo"] = this.WindInfo;
        data["ZipCode"] = this.ZipCode;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectWeatherNow {
        const json = this.toJSON();
        let result = new ProjectWeatherNow();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer?: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint?: number;
    /** Feels Like */
    FeelsLike?: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity?: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained?: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature?: number;
    /** Visibility (miles) */
    Visibility?: number;
    /** Wind (MPH) */
    Wind?: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zip Code for which this reading was obtained */
    ZipCode?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Primary Site Weather Now */
export class WeatherAtLocation implements IWeatherAtLocation {
    /** Location (typically zip code) */
    LocationCode?: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually NOAA weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey?: string;
    /** Key of this location */
    WeatherLocationKey?: string;
    /** When this reading was acquired */
    Reported?: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility?: number;
    /** Temperature (F) */
    Temperature?: number;
    /** Feels like (F) */
    FeelsLike?: number;
    /** Dewpoint (F) */
    Dewpoint?: number;
    /** Relative Humidity */
    HumidityPct?: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind?: number;
    /** Barometric Pressure */
    Barometer?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IWeatherAtLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.LocationCode = _data["LocationCode"];
            this.Location = _data["Location"];
            this.RecordedAt = _data["RecordedAt"];
            this.Provider = _data["Provider"];
            this.WeatherInfoKey = _data["WeatherInfoKey"];
            this.WeatherLocationKey = _data["WeatherLocationKey"];
            this.Reported = _data["Reported"] ? new Date(_data["Reported"].toString()) : <any>undefined;
            this.Conditions = _data["Conditions"];
            this.Visibility = _data["Visibility"];
            this.Temperature = _data["Temperature"];
            this.FeelsLike = _data["FeelsLike"];
            this.Dewpoint = _data["Dewpoint"];
            this.HumidityPct = _data["HumidityPct"];
            this.WindDirection = _data["WindDirection"];
            this.Wind = _data["Wind"];
            this.Barometer = _data["Barometer"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): WeatherAtLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAtLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocationCode"] = this.LocationCode;
        data["Location"] = this.Location;
        data["RecordedAt"] = this.RecordedAt;
        data["Provider"] = this.Provider;
        data["WeatherInfoKey"] = this.WeatherInfoKey;
        data["WeatherLocationKey"] = this.WeatherLocationKey;
        data["Reported"] = this.Reported ? this.Reported.toISOString() : <any>undefined;
        data["Conditions"] = this.Conditions;
        data["Visibility"] = this.Visibility;
        data["Temperature"] = this.Temperature;
        data["FeelsLike"] = this.FeelsLike;
        data["Dewpoint"] = this.Dewpoint;
        data["HumidityPct"] = this.HumidityPct;
        data["WindDirection"] = this.WindDirection;
        data["Wind"] = this.Wind;
        data["Barometer"] = this.Barometer;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): WeatherAtLocation {
        const json = this.toJSON();
        let result = new WeatherAtLocation();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IWeatherAtLocation {
    /** Location (typically zip code) */
    LocationCode?: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually NOAA weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey?: string;
    /** Key of this location */
    WeatherLocationKey?: string;
    /** When this reading was acquired */
    Reported?: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility?: number;
    /** Temperature (F) */
    Temperature?: number;
    /** Feels like (F) */
    FeelsLike?: number;
    /** Dewpoint (F) */
    Dewpoint?: number;
    /** Relative Humidity */
    HumidityPct?: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind?: number;
    /** Barometric Pressure */
    Barometer?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** Read only description of an cost transaction posted to a project */
export class ProjectTranDetail implements IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey!: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount?: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime?: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num?: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime?: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date?: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date?: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units?: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line?: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS?: boolean;
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectTranDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.acct = _data["acct"];
            this.alloc_flag = _data["alloc_flag"];
            this.amount = _data["amount"];
            this.BaseCuryId = _data["BaseCuryId"];
            this.batch_id = _data["batch_id"];
            this.batch_type = _data["batch_type"];
            this.bill_batch_id = _data["bill_batch_id"];
            this.CpnyId = _data["CpnyId"];
            this.crtd_datetime = _data["crtd_datetime"] ? new Date(_data["crtd_datetime"].toString()) : <any>undefined;
            this.crtd_prog = _data["crtd_prog"];
            this.crtd_user = _data["crtd_user"];
            this.data1 = _data["data1"];
            this.detail_num = _data["detail_num"];
            this.employee = _data["employee"];
            this.fiscalno = _data["fiscalno"];
            this.gl_acct = _data["gl_acct"];
            this.gl_subacct = _data["gl_subacct"];
            this.lupd_datetime = _data["lupd_datetime"] ? new Date(_data["lupd_datetime"].toString()) : <any>undefined;
            this.lupd_prog = _data["lupd_prog"];
            this.lupd_user = _data["lupd_user"];
            this.pjt_entity = _data["pjt_entity"];
            this.post_date = _data["post_date"] ? new Date(_data["post_date"].toString()) : <any>undefined;
            this.project = _data["project"];
            this.Subcontract = _data["Subcontract"];
            this.system_cd = _data["system_cd"];
            this.trans_date = _data["trans_date"] ? new Date(_data["trans_date"].toString()) : <any>undefined;
            this.tr_comment = _data["tr_comment"];
            this.tr_id01 = _data["tr_id01"];
            this.InvoiceNumber = _data["InvoiceNumber"];
            this.PONumber = _data["PONumber"];
            this.SourceBatchNumber = _data["SourceBatchNumber"];
            this.LaborClass = _data["LaborClass"];
            this.tr_status = _data["tr_status"];
            this.unit_of_measure = _data["unit_of_measure"];
            this.units = _data["units"];
            this.vendor_num = _data["vendor_num"];
            this.voucher_line = _data["voucher_line"];
            this.voucher_num = _data["voucher_num"];
            this.emp_name = _data["emp_name"];
            this.name = _data["name"];
            this.equip_id = _data["equip_id"];
            this.invtid = _data["invtid"];
            this.lotsernbr = _data["lotsernbr"];
            this.siteid = _data["siteid"];
            this.whseloc = _data["whseloc"];
            this.Descr = _data["Descr"];
            this.IsXTS = _data["IsXTS"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTitle = _data["DocTitle"];
            this.Acct_Type = _data["Acct_Type"];
            this.Acct_TranClass = _data["Acct_TranClass"];
            this.Acct_Class = _data["Acct_Class"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectTranDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTranDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["acct"] = this.acct;
        data["alloc_flag"] = this.alloc_flag;
        data["amount"] = this.amount;
        data["BaseCuryId"] = this.BaseCuryId;
        data["batch_id"] = this.batch_id;
        data["batch_type"] = this.batch_type;
        data["bill_batch_id"] = this.bill_batch_id;
        data["CpnyId"] = this.CpnyId;
        data["crtd_datetime"] = this.crtd_datetime ? this.crtd_datetime.toISOString() : <any>undefined;
        data["crtd_prog"] = this.crtd_prog;
        data["crtd_user"] = this.crtd_user;
        data["data1"] = this.data1;
        data["detail_num"] = this.detail_num;
        data["employee"] = this.employee;
        data["fiscalno"] = this.fiscalno;
        data["gl_acct"] = this.gl_acct;
        data["gl_subacct"] = this.gl_subacct;
        data["lupd_datetime"] = this.lupd_datetime ? this.lupd_datetime.toISOString() : <any>undefined;
        data["lupd_prog"] = this.lupd_prog;
        data["lupd_user"] = this.lupd_user;
        data["pjt_entity"] = this.pjt_entity;
        data["post_date"] = this.post_date ? this.post_date.toISOString() : <any>undefined;
        data["project"] = this.project;
        data["Subcontract"] = this.Subcontract;
        data["system_cd"] = this.system_cd;
        data["trans_date"] = this.trans_date ? this.trans_date.toISOString() : <any>undefined;
        data["tr_comment"] = this.tr_comment;
        data["tr_id01"] = this.tr_id01;
        data["InvoiceNumber"] = this.InvoiceNumber;
        data["PONumber"] = this.PONumber;
        data["SourceBatchNumber"] = this.SourceBatchNumber;
        data["LaborClass"] = this.LaborClass;
        data["tr_status"] = this.tr_status;
        data["unit_of_measure"] = this.unit_of_measure;
        data["units"] = this.units;
        data["vendor_num"] = this.vendor_num;
        data["voucher_line"] = this.voucher_line;
        data["voucher_num"] = this.voucher_num;
        data["emp_name"] = this.emp_name;
        data["name"] = this.name;
        data["equip_id"] = this.equip_id;
        data["invtid"] = this.invtid;
        data["lotsernbr"] = this.lotsernbr;
        data["siteid"] = this.siteid;
        data["whseloc"] = this.whseloc;
        data["Descr"] = this.Descr;
        data["IsXTS"] = this.IsXTS;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTitle"] = this.DocTitle;
        data["Acct_Type"] = this.Acct_Type;
        data["Acct_TranClass"] = this.Acct_TranClass;
        data["Acct_Class"] = this.Acct_Class;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectTranDetail {
        const json = this.toJSON();
        let result = new ProjectTranDetail();
        result.init(json);
        return result;
    }
}

/** Read only description of an cost transaction posted to a project */
export interface IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount?: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime?: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num?: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime?: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date?: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date?: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units?: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line?: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS?: boolean;
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Read only description of an open committed cost posted to a project */
export class ProjectCommitmentDetail implements IProjectCommitmentDetail {
    /** Key for this transaction (does not persist) */
    RowKey!: string;
    /** Account Category */
    acct?: string | undefined;
    /** Account Class (L, B, E, etc) */
    AcctClass?: string | undefined;
    /** Account Type (EX or RV) */
    AcctType?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Amount  */
    amount?: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime?: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num?: number;
    /** Fiscal Period (YYYYMM) */
    FiscalNo?: string | undefined;
    /** GL Account number */
    GLAcct?: string | undefined;
    /** GL Subaccount number */
    GLSubAcct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime?: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Part Number */
    part_number?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** po Date of this transaction */
    po_date?: Date;
    /** ID of Project   */
    project?: string | undefined;
    /** promise Date of this transaction */
    promise_date?: Date;
    /** PO Number */
    PONumber?: string | undefined;
    /** request Date of this transaction */
    request_date?: Date;
    /** Source Number  */
    SourceNum?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date?: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** UOM (code) */
    UOM?: string | undefined;
    /** Units */
    units?: number;
    user1?: string | undefined;
    /** Vendor Number */
    VendorId?: string | undefined;
    /** Voucher Line */
    voucher_line?: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    EmployeeId?: string | undefined;
    /** Labor Class Code */
    LaborClass?: string | undefined;
    /** Rate (amount) */
    Rate?: number;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS?: boolean;
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Document Date */
    DocDate?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectCommitmentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.acct = _data["acct"];
            this.AcctClass = _data["AcctClass"];
            this.AcctType = _data["AcctType"];
            this.Acct_TranClass = _data["Acct_TranClass"];
            this.amount = _data["amount"];
            this.BaseCuryId = _data["BaseCuryId"];
            this.batch_id = _data["batch_id"];
            this.batch_type = _data["batch_type"];
            this.bill_batch_id = _data["bill_batch_id"];
            this.CpnyId = _data["CpnyId"];
            this.crtd_datetime = _data["crtd_datetime"] ? new Date(_data["crtd_datetime"].toString()) : <any>undefined;
            this.crtd_prog = _data["crtd_prog"];
            this.crtd_user = _data["crtd_user"];
            this.data1 = _data["data1"];
            this.detail_num = _data["detail_num"];
            this.FiscalNo = _data["FiscalNo"];
            this.GLAcct = _data["GLAcct"];
            this.GLSubAcct = _data["GLSubAcct"];
            this.lupd_datetime = _data["lupd_datetime"] ? new Date(_data["lupd_datetime"].toString()) : <any>undefined;
            this.lupd_prog = _data["lupd_prog"];
            this.lupd_user = _data["lupd_user"];
            this.part_number = _data["part_number"];
            this.pjt_entity = _data["pjt_entity"];
            this.po_date = _data["po_date"] ? new Date(_data["po_date"].toString()) : <any>undefined;
            this.project = _data["project"];
            this.promise_date = _data["promise_date"] ? new Date(_data["promise_date"].toString()) : <any>undefined;
            this.PONumber = _data["PONumber"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.SourceNum = _data["SourceNum"];
            this.system_cd = _data["system_cd"];
            this.trans_date = _data["trans_date"] ? new Date(_data["trans_date"].toString()) : <any>undefined;
            this.tr_comment = _data["tr_comment"];
            this.tr_status = _data["tr_status"];
            this.Subcontract = _data["Subcontract"];
            this.tr_id01 = _data["tr_id01"];
            this.InvoiceNumber = _data["InvoiceNumber"];
            this.UOM = _data["UOM"];
            this.units = _data["units"];
            this.user1 = _data["user1"];
            this.VendorId = _data["VendorId"];
            this.voucher_line = _data["voucher_line"];
            this.voucher_num = _data["voucher_num"];
            this.emp_name = _data["emp_name"];
            this.EmployeeId = _data["EmployeeId"];
            this.LaborClass = _data["LaborClass"];
            this.Rate = _data["Rate"];
            this.name = _data["name"];
            this.equip_id = _data["equip_id"];
            this.Descr = _data["Descr"];
            this.IsXTS = _data["IsXTS"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTitle = _data["DocTitle"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectCommitmentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCommitmentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["acct"] = this.acct;
        data["AcctClass"] = this.AcctClass;
        data["AcctType"] = this.AcctType;
        data["Acct_TranClass"] = this.Acct_TranClass;
        data["amount"] = this.amount;
        data["BaseCuryId"] = this.BaseCuryId;
        data["batch_id"] = this.batch_id;
        data["batch_type"] = this.batch_type;
        data["bill_batch_id"] = this.bill_batch_id;
        data["CpnyId"] = this.CpnyId;
        data["crtd_datetime"] = this.crtd_datetime ? this.crtd_datetime.toISOString() : <any>undefined;
        data["crtd_prog"] = this.crtd_prog;
        data["crtd_user"] = this.crtd_user;
        data["data1"] = this.data1;
        data["detail_num"] = this.detail_num;
        data["FiscalNo"] = this.FiscalNo;
        data["GLAcct"] = this.GLAcct;
        data["GLSubAcct"] = this.GLSubAcct;
        data["lupd_datetime"] = this.lupd_datetime ? this.lupd_datetime.toISOString() : <any>undefined;
        data["lupd_prog"] = this.lupd_prog;
        data["lupd_user"] = this.lupd_user;
        data["part_number"] = this.part_number;
        data["pjt_entity"] = this.pjt_entity;
        data["po_date"] = this.po_date ? this.po_date.toISOString() : <any>undefined;
        data["project"] = this.project;
        data["promise_date"] = this.promise_date ? this.promise_date.toISOString() : <any>undefined;
        data["PONumber"] = this.PONumber;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["SourceNum"] = this.SourceNum;
        data["system_cd"] = this.system_cd;
        data["trans_date"] = this.trans_date ? this.trans_date.toISOString() : <any>undefined;
        data["tr_comment"] = this.tr_comment;
        data["tr_status"] = this.tr_status;
        data["Subcontract"] = this.Subcontract;
        data["tr_id01"] = this.tr_id01;
        data["InvoiceNumber"] = this.InvoiceNumber;
        data["UOM"] = this.UOM;
        data["units"] = this.units;
        data["user1"] = this.user1;
        data["VendorId"] = this.VendorId;
        data["voucher_line"] = this.voucher_line;
        data["voucher_num"] = this.voucher_num;
        data["emp_name"] = this.emp_name;
        data["EmployeeId"] = this.EmployeeId;
        data["LaborClass"] = this.LaborClass;
        data["Rate"] = this.Rate;
        data["name"] = this.name;
        data["equip_id"] = this.equip_id;
        data["Descr"] = this.Descr;
        data["IsXTS"] = this.IsXTS;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTitle"] = this.DocTitle;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectCommitmentDetail {
        const json = this.toJSON();
        let result = new ProjectCommitmentDetail();
        result.init(json);
        return result;
    }
}

/** Read only description of an open committed cost posted to a project */
export interface IProjectCommitmentDetail {
    /** Key for this transaction (does not persist) */
    RowKey: string;
    /** Account Category */
    acct?: string | undefined;
    /** Account Class (L, B, E, etc) */
    AcctClass?: string | undefined;
    /** Account Type (EX or RV) */
    AcctType?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Amount  */
    amount?: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime?: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num?: number;
    /** Fiscal Period (YYYYMM) */
    FiscalNo?: string | undefined;
    /** GL Account number */
    GLAcct?: string | undefined;
    /** GL Subaccount number */
    GLSubAcct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime?: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Part Number */
    part_number?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** po Date of this transaction */
    po_date?: Date;
    /** ID of Project   */
    project?: string | undefined;
    /** promise Date of this transaction */
    promise_date?: Date;
    /** PO Number */
    PONumber?: string | undefined;
    /** request Date of this transaction */
    request_date?: Date;
    /** Source Number  */
    SourceNum?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date?: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** UOM (code) */
    UOM?: string | undefined;
    /** Units */
    units?: number;
    user1?: string | undefined;
    /** Vendor Number */
    VendorId?: string | undefined;
    /** Voucher Line */
    voucher_line?: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    EmployeeId?: string | undefined;
    /** Labor Class Code */
    LaborClass?: string | undefined;
    /** Rate (amount) */
    Rate?: number;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS?: boolean;
    /** Identifies a Document */
    DocMasterKey?: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Document Date */
    DocDate?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** Legacy Site Authentication */
export class SiteLogin implements ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed?: boolean;
    /** the offset from UT at the user device (typically negative for ET) */
    tzOffset?: number;

    constructor(data?: ISiteLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UID = _data["UID"];
            this.PW = _data["PW"];
            this.IsHashed = _data["IsHashed"];
            this.tzOffset = _data["tzOffset"];
        }
    }

    static fromJS(data: any): SiteLogin {
        data = typeof data === 'object' ? data : {};
        let result = new SiteLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UID"] = this.UID;
        data["PW"] = this.PW;
        data["IsHashed"] = this.IsHashed;
        data["tzOffset"] = this.tzOffset;
        return data;
    }

    clone(): SiteLogin {
        const json = this.toJSON();
        let result = new SiteLogin();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed?: boolean;
    /** the offset from UT at the user device (typically negative for ET) */
    tzOffset?: number;
}

/** Attributes describing the currently authenticated user */
export class CurrentUser implements ICurrentUser {
    /** User Key */
    UserKey?: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user must change PW ASAP */
    PWMustChange?: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset?: number;
    /** Password Aging is enabled for this user */
    PWAging?: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration?: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut?: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun?: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser?: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin?: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey?: string;
    /** This data is locked in memory */
    IsDSProtected?: boolean;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** when true, stay in power ux */
    PrefersPowerUX?: boolean;
    /** When set, this is the last project tracked  */
    LastProject?: string | undefined;
    /** When set, this is the last project tracked  */
    JQTheme?: string | undefined;
    /** When set, Track feature use (google analytics */
    MonitorFeatureUse?: boolean;
    /** When set, this is the doc type that should be used as a default */
    PriorityDocType?: string;
    /** 0==off; 1 == track; 2==static */
    PriorityDocTypeMode?: number;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** User Menu items */
    menuActions?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ICurrentUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserLoginName = _data["UserLoginName"];
            this.FullName = _data["FullName"];
            this.email = _data["email"];
            this.PWMustChange = _data["PWMustChange"];
            this.UserTimeZone = _data["UserTimeZone"];
            this.TZOffset = _data["TZOffset"];
            this.PWAging = _data["PWAging"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.IsLockedOut = _data["IsLockedOut"];
            this.PWExpires = _data["PWExpires"] ? new Date(_data["PWExpires"].toString()) : <any>undefined;
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SolomonUser = _data["SolomonUser"];
            this.IsFirstLogin = _data["IsFirstLogin"];
            this.MasterSession = _data["MasterSession"];
            this.UserSessionKey = _data["UserSessionKey"];
            this.IsDSProtected = _data["IsDSProtected"];
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.LockoutReason = _data["LockoutReason"];
            this.PrefersPowerUX = _data["PrefersPowerUX"];
            this.LastProject = _data["LastProject"];
            this.JQTheme = _data["JQTheme"];
            this.MonitorFeatureUse = _data["MonitorFeatureUse"];
            this.PriorityDocType = _data["PriorityDocType"];
            this.PriorityDocTypeMode = _data["PriorityDocTypeMode"];
            this.PictureURL = _data["PictureURL"];
            this.PDSKey = _data["PDSKey"];
            if (Array.isArray(_data["menuActions"])) {
                this.menuActions = [] as any;
                for (let item of _data["menuActions"])
                    this.menuActions!.push(MenuAction.fromJS(item));
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): CurrentUser {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserLoginName"] = this.UserLoginName;
        data["FullName"] = this.FullName;
        data["email"] = this.email;
        data["PWMustChange"] = this.PWMustChange;
        data["UserTimeZone"] = this.UserTimeZone;
        data["TZOffset"] = this.TZOffset;
        data["PWAging"] = this.PWAging;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["IsLockedOut"] = this.IsLockedOut;
        data["PWExpires"] = this.PWExpires ? this.PWExpires.toISOString() : <any>undefined;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SolomonUser"] = this.SolomonUser;
        data["IsFirstLogin"] = this.IsFirstLogin;
        data["MasterSession"] = this.MasterSession;
        data["UserSessionKey"] = this.UserSessionKey;
        data["IsDSProtected"] = this.IsDSProtected;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["LockoutReason"] = this.LockoutReason;
        data["PrefersPowerUX"] = this.PrefersPowerUX;
        data["LastProject"] = this.LastProject;
        data["JQTheme"] = this.JQTheme;
        data["MonitorFeatureUse"] = this.MonitorFeatureUse;
        data["PriorityDocType"] = this.PriorityDocType;
        data["PriorityDocTypeMode"] = this.PriorityDocTypeMode;
        data["PictureURL"] = this.PictureURL;
        data["PDSKey"] = this.PDSKey;
        if (Array.isArray(this.menuActions)) {
            data["menuActions"] = [];
            for (let item of this.menuActions)
                data["menuActions"].push(item.toJSON());
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): CurrentUser {
        const json = this.toJSON();
        let result = new CurrentUser();
        result.init(json);
        return result;
    }
}

/** Attributes describing the currently authenticated user */
export interface ICurrentUser {
    /** User Key */
    UserKey?: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user must change PW ASAP */
    PWMustChange?: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset?: number;
    /** Password Aging is enabled for this user */
    PWAging?: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration?: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut?: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun?: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser?: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin?: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey?: string;
    /** This data is locked in memory */
    IsDSProtected?: boolean;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** when true, stay in power ux */
    PrefersPowerUX?: boolean;
    /** When set, this is the last project tracked  */
    LastProject?: string | undefined;
    /** When set, this is the last project tracked  */
    JQTheme?: string | undefined;
    /** When set, Track feature use (google analytics */
    MonitorFeatureUse?: boolean;
    /** When set, this is the doc type that should be used as a default */
    PriorityDocType?: string;
    /** 0==off; 1 == track; 2==static */
    PriorityDocTypeMode?: number;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** User Menu items */
    menuActions?: MenuAction[] | undefined;
    /** eTag */
    ETag?: string | undefined;
}

export class PasswordConfiguredOptions implements IPasswordConfiguredOptions {

    constructor(data?: IPasswordConfiguredOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PasswordConfiguredOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordConfiguredOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): PasswordConfiguredOptions {
        const json = this.toJSON();
        let result = new PasswordConfiguredOptions();
        result.init(json);
        return result;
    }
}

export interface IPasswordConfiguredOptions {
}

/** Permission required flag -- bit flags can be combined */
export enum PermissionFlags {
    None = 0,
    Read = 1,
    Insert = 2,
    Update = 4,
    Delete = 8,
    Blanket = 16,
}

/** Describes permission being demanded and the context */
export class PermissionContext implements IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule!: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction!: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey?: string;
    /** Document Type */
    DocTypeKey?: string;
    /** Doc Reference (seldom used) */
    DocReference?: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded?: PermissionFlags;

    constructor(data?: IPermissionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.Project = _data["Project"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.PermissionNeeded = _data["PermissionNeeded"];
        }
    }

    static fromJS(data: any): PermissionContext {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["Project"] = this.Project;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["PermissionNeeded"] = this.PermissionNeeded;
        return data;
    }

    clone(): PermissionContext {
        const json = this.toJSON();
        let result = new PermissionContext();
        result.init(json);
        return result;
    }
}

/** Describes permission being demanded and the context */
export interface IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey?: string;
    /** Document Type */
    DocTypeKey?: string;
    /** Doc Reference (seldom used) */
    DocReference?: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded?: PermissionFlags;
}

/** Describes an Alert Condition */
export class UserAlert implements IUserAlert {
    /** Key for Alert */
    AlertKey?: string;
    /** Key for User for whom the alert was generated */
    UserKey?: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created?: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Document about which the alert was generated */
    DocMasterKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** When action is due */
    Due?: Date;
    /** Files attached to document */
    FilesAttached?: number;
    /** Document Display Value (Typically Title) */
    DocMasterKey_dv?: string | undefined;
    /** For Email Notification Type, when was the email sent */
    Notified?: Date;
    /** When was the alert viewed */
    Viewed?: Date;
    /** When closed (from document) */
    Closed?: Date;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUserAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AlertKey = _data["AlertKey"];
            this.UserKey = _data["UserKey"];
            this.Status = _data["Status"];
            this.NotificationType = _data["NotificationType"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.Description = _data["Description"];
            this.AlertText = _data["AlertText"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.Project = _data["Project"];
            this.Source = _data["Source"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.FilesAttached = _data["FilesAttached"];
            this.DocMasterKey_dv = _data["DocMasterKey_dv"];
            this.Notified = _data["Notified"] ? new Date(_data["Notified"].toString()) : <any>undefined;
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Project_dv = _data["Project_dv"];
            this.SourceKey = _data["SourceKey"];
            this.Info1 = _data["Info1"];
            this.Info2 = _data["Info2"];
            this.MsgType = _data["MsgType"];
            this.MsgKey = _data["MsgKey"];
            this.MsgSuffix = _data["MsgSuffix"];
            this.SIVAlert = _data["SIVAlert"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UserAlert {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AlertKey"] = this.AlertKey;
        data["UserKey"] = this.UserKey;
        data["Status"] = this.Status;
        data["NotificationType"] = this.NotificationType;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["Description"] = this.Description;
        data["AlertText"] = this.AlertText;
        data["DocMasterKey"] = this.DocMasterKey;
        data["Project"] = this.Project;
        data["Source"] = this.Source;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["FilesAttached"] = this.FilesAttached;
        data["DocMasterKey_dv"] = this.DocMasterKey_dv;
        data["Notified"] = this.Notified ? this.Notified.toISOString() : <any>undefined;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Project_dv"] = this.Project_dv;
        data["SourceKey"] = this.SourceKey;
        data["Info1"] = this.Info1;
        data["Info2"] = this.Info2;
        data["MsgType"] = this.MsgType;
        data["MsgKey"] = this.MsgKey;
        data["MsgSuffix"] = this.MsgSuffix;
        data["SIVAlert"] = this.SIVAlert;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UserAlert {
        const json = this.toJSON();
        let result = new UserAlert();
        result.init(json);
        return result;
    }
}

/** Describes an Alert Condition */
export interface IUserAlert {
    /** Key for Alert */
    AlertKey?: string;
    /** Key for User for whom the alert was generated */
    UserKey?: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created?: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Document about which the alert was generated */
    DocMasterKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** When action is due */
    Due?: Date;
    /** Files attached to document */
    FilesAttached?: number;
    /** Document Display Value (Typically Title) */
    DocMasterKey_dv?: string | undefined;
    /** For Email Notification Type, when was the email sent */
    Notified?: Date;
    /** When was the alert viewed */
    Viewed?: Date;
    /** When closed (from document) */
    Closed?: Date;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Returns data rows in three collections */
export class DataDifferential implements IDataDifferential {
    /** Collection of rows added (process last) */
    Add?: any[] | undefined;
    /** Collection of rows with new etags (replace) */
    Change?: any[] | undefined;
    /** Collection of keys removed (process first) */
    Remove?: string[] | undefined;

    constructor(data?: IDataDifferential) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Add"])) {
                this.Add = [] as any;
                for (let item of _data["Add"])
                    this.Add!.push(item);
            }
            if (Array.isArray(_data["Change"])) {
                this.Change = [] as any;
                for (let item of _data["Change"])
                    this.Change!.push(item);
            }
            if (Array.isArray(_data["Remove"])) {
                this.Remove = [] as any;
                for (let item of _data["Remove"])
                    this.Remove!.push(item);
            }
        }
    }

    static fromJS(data: any): DataDifferential {
        data = typeof data === 'object' ? data : {};
        let result = new DataDifferential();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.Add)) {
            data["Add"] = [];
            for (let item of this.Add)
                data["Add"].push(item);
        }
        if (Array.isArray(this.Change)) {
            data["Change"] = [];
            for (let item of this.Change)
                data["Change"].push(item);
        }
        if (Array.isArray(this.Remove)) {
            data["Remove"] = [];
            for (let item of this.Remove)
                data["Remove"].push(item);
        }
        return data;
    }

    clone(): DataDifferential {
        const json = this.toJSON();
        let result = new DataDifferential();
        result.init(json);
        return result;
    }
}

/** Returns data rows in three collections */
export interface IDataDifferential {
    /** Collection of rows added (process last) */
    Add?: any[] | undefined;
    /** Collection of rows with new etags (replace) */
    Change?: any[] | undefined;
    /** Collection of keys removed (process first) */
    Remove?: string[] | undefined;
}

/** Key Value pairs of Keys and ETags */
export class CurrentDataSummary implements ICurrentDataSummary {
    /** Key of Row/object */
    RowKey!: string;
    /** ETag of Row/object  */
    ETag!: string;

    constructor(data?: ICurrentDataSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): CurrentDataSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentDataSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): CurrentDataSummary {
        const json = this.toJSON();
        let result = new CurrentDataSummary();
        result.init(json);
        return result;
    }
}

/** Key Value pairs of Keys and ETags */
export interface ICurrentDataSummary {
    /** Key of Row/object */
    RowKey: string;
    /** ETag of Row/object  */
    ETag: string;
}

/** Information about file versions */
export class FileInformation implements IFileInformation {
    /** full path and name of this folder or fileKey.type */
    id?: string | undefined;
    /** Name of this object (file or folder) */
    value?: string | undefined;
    /** Name of this object (Same as Value) */
    Name?: string | undefined;
    /** File class  */
    type?: string | undefined;
    /** File type (pdf, docx, js,  etc)  Does not include period */
    FileType?: string | undefined;
    /** Identifies a file */
    FileKey?: string;
    /** Identifies a folder */
    FolderKey?: string;
    /** Size of the file (in bytes) */
    size?: number;
    /** Read only Size of the file with units */
    DisplaySize?: string | undefined;
    /** [Read Only] Catalog Date for this object */
    date?: Date | undefined;
    /** Malleable date, from the document header */
    DocDate?: Date | undefined;
    /** Malleable date, from the document header */
    Due?: Date | undefined;
    /** Malleable date, usually set to date of source file uploaded; for documents SourceDate */
    ReferenceDate?: Date | undefined;
    /** ID of Project  */
    Project?: string | undefined;
    /** Project Display Value */
    ProjectName?: string | undefined;
    /** highest revision number of binary changes.  Starts with 1 */
    LatestRevision?: number;
    /** revision number of approved revision (usually same as LatestRevision)  */
    ApprovedRevision?: number;
    /** Priority (applies to documents) */
    Priority?: number;
    /** DocNo from document header
             */
    DocNo?: string | undefined;
    /** Company Division ID (for documents)
             */
    DivisionID?: string | undefined;
    /** (read only) Display Value for who added the file
             */
    From?: string | undefined;
    /** Identifies source of object */
    FromUser?: string;
    /** Note when this object is attached to a document
             */
    AttachNote?: string | undefined;
    /** Read only display value for DocTypeKey associated with this object  
             */
    ProcessType?: string | undefined;
    /** Identifies a file */
    DocTypeKey?: string | undefined;
    /** MD5 hash of binary content 
             */
    MD5?: string | undefined;
    /** Cost Impact */
    CostImpact?: number;
    /** Latitude  */
    GeoLat?: number;
    /** Longitude */
    GeoLng?: number;
    /** Freeform keywords
             */
    Keywords?: string | undefined;
    /** Freeform other
             */
    Other?: string | undefined;
    /** Read only flag.  When true, this file is confidential (which restricts access) */
    Confidential?: boolean;
    /** Read only flag.  When true, this file is updated with data from source document */
    HasDynamicData?: boolean;
    /** Source Number associated with this version of the file
             */
    SourceNumber?: string | undefined;
    /** Source Batch associated with this version of the file
             */
    SourceBatch?: string | undefined;
    /** (read only) Display Value for contact named as source
             */
    SourceContact_dv?: string | undefined;
    /** Identifies source of object */
    SourceContact?: string | undefined;
    /** Identifies template */
    TemplateKey?: string | undefined;
    /** Display only template name
             */
    TemplateKey_dv?: string | undefined;
    /** Identifies Responsible Party (from document header) */
    ResponsibleParty?: string | undefined;
    /** Readonly: True if user can edit this file */
    CanEdit?: boolean;
    /** Readonly: True if user can move or rename this file */
    CanRename?: boolean;
    /** Readonly: True if user can view this file */
    CanView?: boolean;
    /** Document Status  (display only)  */
    StatusText?: string | undefined;
    /** Subtype (display only text)  */
    SubtypeText?: string | undefined;
    /** Checkout Status (null/I, O, U, L,) */
    CheckOutStatus?: string | undefined;
    /** Date of Check out */
    CheckedOut?: Date | undefined;
    /** Date of last Check In */
    CheckedIn?: Date | undefined;
    /** Identifies who has a file checked out  */
    CheckOutUser?: string | undefined;
    /** (read only) Display Value for contact that checked out this file
             */
    CheckOutUser_dv?: string | undefined;
    /** (read only) Display Value for contact named as alternate contact
             */
    AltFileContact_dv?: string | undefined;
    /** Identifies source of object */
    AltFileContact?: string;
    /** Users (file share) not implemented  */
    Users?: string[] | undefined;
    /** Nested Child folders (empty for a file) */
    data?: FileInformation[] | undefined;
    /** read only collection of information specific to the type of file (PDF, DOCX, etc).  See GetMeta method */
    MetaData?: { [key: string]: any; } | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IFileInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.Name = _data["Name"];
            this.type = _data["type"];
            this.FileType = _data["FileType"];
            this.FileKey = _data["FileKey"];
            this.FolderKey = _data["FolderKey"];
            this.size = _data["size"];
            this.DisplaySize = _data["DisplaySize"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.ReferenceDate = _data["ReferenceDate"] ? new Date(_data["ReferenceDate"].toString()) : <any>undefined;
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.LatestRevision = _data["LatestRevision"];
            this.ApprovedRevision = _data["ApprovedRevision"];
            this.Priority = _data["Priority"];
            this.DocNo = _data["DocNo"];
            this.DivisionID = _data["DivisionID"];
            this.From = _data["From"];
            this.FromUser = _data["FromUser"];
            this.AttachNote = _data["AttachNote"];
            this.ProcessType = _data["ProcessType"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.MD5 = _data["MD5"];
            this.CostImpact = _data["CostImpact"];
            this.GeoLat = _data["GeoLat"];
            this.GeoLng = _data["GeoLng"];
            this.Keywords = _data["Keywords"];
            this.Other = _data["Other"];
            this.Confidential = _data["Confidential"];
            this.HasDynamicData = _data["HasDynamicData"];
            this.SourceNumber = _data["SourceNumber"];
            this.SourceBatch = _data["SourceBatch"];
            this.SourceContact_dv = _data["SourceContact_dv"];
            this.SourceContact = _data["SourceContact"];
            this.TemplateKey = _data["TemplateKey"];
            this.TemplateKey_dv = _data["TemplateKey_dv"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.CanEdit = _data["CanEdit"];
            this.CanRename = _data["CanRename"];
            this.CanView = _data["CanView"];
            this.StatusText = _data["StatusText"];
            this.SubtypeText = _data["SubtypeText"];
            this.CheckOutStatus = _data["CheckOutStatus"];
            this.CheckedOut = _data["CheckedOut"] ? new Date(_data["CheckedOut"].toString()) : <any>undefined;
            this.CheckedIn = _data["CheckedIn"] ? new Date(_data["CheckedIn"].toString()) : <any>undefined;
            this.CheckOutUser = _data["CheckOutUser"];
            this.CheckOutUser_dv = _data["CheckOutUser_dv"];
            this.AltFileContact_dv = _data["AltFileContact_dv"];
            this.AltFileContact = _data["AltFileContact"];
            if (Array.isArray(_data["Users"])) {
                this.Users = [] as any;
                for (let item of _data["Users"])
                    this.Users!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FileInformation.fromJS(item));
            }
            if (_data["MetaData"]) {
                this.MetaData = {} as any;
                for (let key in _data["MetaData"]) {
                    if (_data["MetaData"].hasOwnProperty(key))
                        (<any>this.MetaData)![key] = _data["MetaData"][key];
                }
            }
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): FileInformation {
        data = typeof data === 'object' ? data : {};
        let result = new FileInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["Name"] = this.Name;
        data["type"] = this.type;
        data["FileType"] = this.FileType;
        data["FileKey"] = this.FileKey;
        data["FolderKey"] = this.FolderKey;
        data["size"] = this.size;
        data["DisplaySize"] = this.DisplaySize;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["ReferenceDate"] = this.ReferenceDate ? this.ReferenceDate.toISOString() : <any>undefined;
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["LatestRevision"] = this.LatestRevision;
        data["ApprovedRevision"] = this.ApprovedRevision;
        data["Priority"] = this.Priority;
        data["DocNo"] = this.DocNo;
        data["DivisionID"] = this.DivisionID;
        data["From"] = this.From;
        data["FromUser"] = this.FromUser;
        data["AttachNote"] = this.AttachNote;
        data["ProcessType"] = this.ProcessType;
        data["DocTypeKey"] = this.DocTypeKey;
        data["MD5"] = this.MD5;
        data["CostImpact"] = this.CostImpact;
        data["GeoLat"] = this.GeoLat;
        data["GeoLng"] = this.GeoLng;
        data["Keywords"] = this.Keywords;
        data["Other"] = this.Other;
        data["Confidential"] = this.Confidential;
        data["HasDynamicData"] = this.HasDynamicData;
        data["SourceNumber"] = this.SourceNumber;
        data["SourceBatch"] = this.SourceBatch;
        data["SourceContact_dv"] = this.SourceContact_dv;
        data["SourceContact"] = this.SourceContact;
        data["TemplateKey"] = this.TemplateKey;
        data["TemplateKey_dv"] = this.TemplateKey_dv;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["CanEdit"] = this.CanEdit;
        data["CanRename"] = this.CanRename;
        data["CanView"] = this.CanView;
        data["StatusText"] = this.StatusText;
        data["SubtypeText"] = this.SubtypeText;
        data["CheckOutStatus"] = this.CheckOutStatus;
        data["CheckedOut"] = this.CheckedOut ? this.CheckedOut.toISOString() : <any>undefined;
        data["CheckedIn"] = this.CheckedIn ? this.CheckedIn.toISOString() : <any>undefined;
        data["CheckOutUser"] = this.CheckOutUser;
        data["CheckOutUser_dv"] = this.CheckOutUser_dv;
        data["AltFileContact_dv"] = this.AltFileContact_dv;
        data["AltFileContact"] = this.AltFileContact;
        if (Array.isArray(this.Users)) {
            data["Users"] = [];
            for (let item of this.Users)
                data["Users"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (this.MetaData) {
            data["MetaData"] = {};
            for (let key in this.MetaData) {
                if (this.MetaData.hasOwnProperty(key))
                    (<any>data["MetaData"])[key] = (<any>this.MetaData)[key];
            }
        }
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): FileInformation {
        const json = this.toJSON();
        let result = new FileInformation();
        result.init(json);
        return result;
    }
}

/** Information about file versions */
export interface IFileInformation {
    /** full path and name of this folder or fileKey.type */
    id?: string | undefined;
    /** Name of this object (file or folder) */
    value?: string | undefined;
    /** Name of this object (Same as Value) */
    Name?: string | undefined;
    /** File class  */
    type?: string | undefined;
    /** File type (pdf, docx, js,  etc)  Does not include period */
    FileType?: string | undefined;
    /** Identifies a file */
    FileKey?: string;
    /** Identifies a folder */
    FolderKey?: string;
    /** Size of the file (in bytes) */
    size?: number;
    /** Read only Size of the file with units */
    DisplaySize?: string | undefined;
    /** [Read Only] Catalog Date for this object */
    date?: Date | undefined;
    /** Malleable date, from the document header */
    DocDate?: Date | undefined;
    /** Malleable date, from the document header */
    Due?: Date | undefined;
    /** Malleable date, usually set to date of source file uploaded; for documents SourceDate */
    ReferenceDate?: Date | undefined;
    /** ID of Project  */
    Project?: string | undefined;
    /** Project Display Value */
    ProjectName?: string | undefined;
    /** highest revision number of binary changes.  Starts with 1 */
    LatestRevision?: number;
    /** revision number of approved revision (usually same as LatestRevision)  */
    ApprovedRevision?: number;
    /** Priority (applies to documents) */
    Priority?: number;
    /** DocNo from document header
             */
    DocNo?: string | undefined;
    /** Company Division ID (for documents)
             */
    DivisionID?: string | undefined;
    /** (read only) Display Value for who added the file
             */
    From?: string | undefined;
    /** Identifies source of object */
    FromUser?: string;
    /** Note when this object is attached to a document
             */
    AttachNote?: string | undefined;
    /** Read only display value for DocTypeKey associated with this object  
             */
    ProcessType?: string | undefined;
    /** Identifies a file */
    DocTypeKey?: string | undefined;
    /** MD5 hash of binary content 
             */
    MD5?: string | undefined;
    /** Cost Impact */
    CostImpact?: number;
    /** Latitude  */
    GeoLat?: number;
    /** Longitude */
    GeoLng?: number;
    /** Freeform keywords
             */
    Keywords?: string | undefined;
    /** Freeform other
             */
    Other?: string | undefined;
    /** Read only flag.  When true, this file is confidential (which restricts access) */
    Confidential?: boolean;
    /** Read only flag.  When true, this file is updated with data from source document */
    HasDynamicData?: boolean;
    /** Source Number associated with this version of the file
             */
    SourceNumber?: string | undefined;
    /** Source Batch associated with this version of the file
             */
    SourceBatch?: string | undefined;
    /** (read only) Display Value for contact named as source
             */
    SourceContact_dv?: string | undefined;
    /** Identifies source of object */
    SourceContact?: string | undefined;
    /** Identifies template */
    TemplateKey?: string | undefined;
    /** Display only template name
             */
    TemplateKey_dv?: string | undefined;
    /** Identifies Responsible Party (from document header) */
    ResponsibleParty?: string | undefined;
    /** Readonly: True if user can edit this file */
    CanEdit?: boolean;
    /** Readonly: True if user can move or rename this file */
    CanRename?: boolean;
    /** Readonly: True if user can view this file */
    CanView?: boolean;
    /** Document Status  (display only)  */
    StatusText?: string | undefined;
    /** Subtype (display only text)  */
    SubtypeText?: string | undefined;
    /** Checkout Status (null/I, O, U, L,) */
    CheckOutStatus?: string | undefined;
    /** Date of Check out */
    CheckedOut?: Date | undefined;
    /** Date of last Check In */
    CheckedIn?: Date | undefined;
    /** Identifies who has a file checked out  */
    CheckOutUser?: string | undefined;
    /** (read only) Display Value for contact that checked out this file
             */
    CheckOutUser_dv?: string | undefined;
    /** (read only) Display Value for contact named as alternate contact
             */
    AltFileContact_dv?: string | undefined;
    /** Identifies source of object */
    AltFileContact?: string;
    /** Users (file share) not implemented  */
    Users?: string[] | undefined;
    /** Nested Child folders (empty for a file) */
    data?: FileInformation[] | undefined;
    /** read only collection of information specific to the type of file (PDF, DOCX, etc).  See GetMeta method */
    MetaData?: { [key: string]: any; } | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Various common filters - not every filter is supported by every query */
export class QueryFilters implements IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Document number (0001, 16%) */
    DocNoLike?: string | undefined;
    /** Key for a company; use 00000000-0000-0000-0000-000000000000 for unspecified */
    CompanyKey?: string | undefined;
    /** Key for a contact/person; Use 00000000-0000-0000-0000-000000000000 for unspecified */
    ContactKey?: string | undefined;
    /** Key for a the current or proxy user; Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key for a specific file */
    FileKey?: string | undefined;
    /** Key for a specific spitfire document */
    DocMasterKey?: string | undefined;
    /** Any, Approver, From, Responsible, Source, To */
    ContactScope?: string | undefined;
    /** When true, any contact at the same company matches */
    CompanyWide?: boolean;
    /** Key must match an existing document type */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Pair of dates. Applied to DocDate, or Catalog Date; Default is all dates */
    PrimaryDateRange?: DateRange | undefined;
    /** Pair of dates.  Applied to Doc Due Date or Catalog Reference Date; Default is all dates */
    RefDateRange?: DateRange | undefined;
    /** When true, results includes items marked as read; default is false */
    NewOnly?: boolean;
    /** When true, results includes items marked as closed; default is false */
    IncludeClosed?: boolean;
    /** When true, results includes items marked as hidden; default is false */
    IncludeHidden?: boolean;
    /** When true, results includes documents; default is false */
    IncludeDocs?: boolean;
    /** When true, results includes files; default is true */
    IncludeFiles?: boolean;
    /** When true, results are for display in a planroom; seldom used; default is false */
    ForPlanroom?: boolean;
    /** Contains text (for full text search) */
    ContainsText?: string | undefined;
    /** MD5 Hash (used with length for binary content equivalence) */
    HasHash?: string | undefined;
    DependsOn?: string[] | undefined;
    /** seed */
    MatchingSeed?: string | undefined;
    /** max number of results */
    ResultLimit?: number;
    /** Timeout Factor - when greater than 1, increase query timeout to n* factor;   */
    TimeoutFactor?: number;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;
    /** Key Value pairs of Keys and ETags, applicable to change/diffgram endpoints */
    ClientDataSummary?: CurrentDataSummary[] | undefined;

    constructor(data?: IQueryFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ProjectLike = _data["ProjectLike"];
            this.TitleLike = _data["TitleLike"];
            this.DocNoLike = _data["DocNoLike"];
            this.CompanyKey = _data["CompanyKey"];
            this.ContactKey = _data["ContactKey"];
            this.UserKey = _data["UserKey"];
            this.FileKey = _data["FileKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.ContactScope = _data["ContactScope"];
            this.CompanyWide = _data["CompanyWide"];
            this.ForDocType = _data["ForDocType"];
            this.ProgramKey = _data["ProgramKey"];
            this.PrimaryDateRange = _data["PrimaryDateRange"] ? DateRange.fromJS(_data["PrimaryDateRange"]) : <any>undefined;
            this.RefDateRange = _data["RefDateRange"] ? DateRange.fromJS(_data["RefDateRange"]) : <any>undefined;
            this.NewOnly = _data["NewOnly"];
            this.IncludeClosed = _data["IncludeClosed"];
            this.IncludeHidden = _data["IncludeHidden"];
            this.IncludeDocs = _data["IncludeDocs"];
            this.IncludeFiles = _data["IncludeFiles"];
            this.ForPlanroom = _data["ForPlanroom"];
            this.ContainsText = _data["ContainsText"];
            this.HasHash = _data["HasHash"];
            if (Array.isArray(_data["DependsOn"])) {
                this.DependsOn = [] as any;
                for (let item of _data["DependsOn"])
                    this.DependsOn!.push(item);
            }
            this.MatchingSeed = _data["MatchingSeed"];
            this.ResultLimit = _data["ResultLimit"];
            this.TimeoutFactor = _data["TimeoutFactor"];
            this.nvpFilters = _data["nvpFilters"];
            if (Array.isArray(_data["ClientDataSummary"])) {
                this.ClientDataSummary = [] as any;
                for (let item of _data["ClientDataSummary"])
                    this.ClientDataSummary!.push(CurrentDataSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryFilters {
        data = typeof data === 'object' ? data : {};
        let result = new QueryFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectLike"] = this.ProjectLike;
        data["TitleLike"] = this.TitleLike;
        data["DocNoLike"] = this.DocNoLike;
        data["CompanyKey"] = this.CompanyKey;
        data["ContactKey"] = this.ContactKey;
        data["UserKey"] = this.UserKey;
        data["FileKey"] = this.FileKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["ContactScope"] = this.ContactScope;
        data["CompanyWide"] = this.CompanyWide;
        data["ForDocType"] = this.ForDocType;
        data["ProgramKey"] = this.ProgramKey;
        data["PrimaryDateRange"] = this.PrimaryDateRange ? this.PrimaryDateRange.toJSON() : <any>undefined;
        data["RefDateRange"] = this.RefDateRange ? this.RefDateRange.toJSON() : <any>undefined;
        data["NewOnly"] = this.NewOnly;
        data["IncludeClosed"] = this.IncludeClosed;
        data["IncludeHidden"] = this.IncludeHidden;
        data["IncludeDocs"] = this.IncludeDocs;
        data["IncludeFiles"] = this.IncludeFiles;
        data["ForPlanroom"] = this.ForPlanroom;
        data["ContainsText"] = this.ContainsText;
        data["HasHash"] = this.HasHash;
        if (Array.isArray(this.DependsOn)) {
            data["DependsOn"] = [];
            for (let item of this.DependsOn)
                data["DependsOn"].push(item);
        }
        data["MatchingSeed"] = this.MatchingSeed;
        data["ResultLimit"] = this.ResultLimit;
        data["TimeoutFactor"] = this.TimeoutFactor;
        data["nvpFilters"] = this.nvpFilters;
        if (Array.isArray(this.ClientDataSummary)) {
            data["ClientDataSummary"] = [];
            for (let item of this.ClientDataSummary)
                data["ClientDataSummary"].push(item.toJSON());
        }
        return data;
    }

    clone(): QueryFilters {
        const json = this.toJSON();
        let result = new QueryFilters();
        result.init(json);
        return result;
    }
}

/** Various common filters - not every filter is supported by every query */
export interface IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Document number (0001, 16%) */
    DocNoLike?: string | undefined;
    /** Key for a company; use 00000000-0000-0000-0000-000000000000 for unspecified */
    CompanyKey?: string | undefined;
    /** Key for a contact/person; Use 00000000-0000-0000-0000-000000000000 for unspecified */
    ContactKey?: string | undefined;
    /** Key for a the current or proxy user; Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key for a specific file */
    FileKey?: string | undefined;
    /** Key for a specific spitfire document */
    DocMasterKey?: string | undefined;
    /** Any, Approver, From, Responsible, Source, To */
    ContactScope?: string | undefined;
    /** When true, any contact at the same company matches */
    CompanyWide?: boolean;
    /** Key must match an existing document type */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Pair of dates. Applied to DocDate, or Catalog Date; Default is all dates */
    PrimaryDateRange?: DateRange | undefined;
    /** Pair of dates.  Applied to Doc Due Date or Catalog Reference Date; Default is all dates */
    RefDateRange?: DateRange | undefined;
    /** When true, results includes items marked as read; default is false */
    NewOnly?: boolean;
    /** When true, results includes items marked as closed; default is false */
    IncludeClosed?: boolean;
    /** When true, results includes items marked as hidden; default is false */
    IncludeHidden?: boolean;
    /** When true, results includes documents; default is false */
    IncludeDocs?: boolean;
    /** When true, results includes files; default is true */
    IncludeFiles?: boolean;
    /** When true, results are for display in a planroom; seldom used; default is false */
    ForPlanroom?: boolean;
    /** Contains text (for full text search) */
    ContainsText?: string | undefined;
    /** MD5 Hash (used with length for binary content equivalence) */
    HasHash?: string | undefined;
    DependsOn?: string[] | undefined;
    /** seed */
    MatchingSeed?: string | undefined;
    /** max number of results */
    ResultLimit?: number;
    /** Timeout Factor - when greater than 1, increase query timeout to n* factor;   */
    TimeoutFactor?: number;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;
    /** Key Value pairs of Keys and ETags, applicable to change/diffgram endpoints */
    ClientDataSummary?: CurrentDataSummary[] | undefined;
}

/** From and Thru dates */
export class DateRange implements IDateRange {
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default is today */
    ThruDate?: Date | undefined;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRange {
        data = typeof data === 'object' ? data : {};
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): DateRange {
        const json = this.toJSON();
        let result = new DateRange();
        result.init(json);
        return result;
    }
}

/** From and Thru dates */
export interface IDateRange {
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default is today */
    ThruDate?: Date | undefined;
}

/** Information about catalog preset search settings */
export class CatalogPreset implements ICatalogPreset {
    /** id of this set */
    SetId?: string | undefined;
    /** days ago (if not zero) default is 400; if GT 20000101, interpreted as YYYYMMDD
applies to DUE date filtering */
    CreatedSinceDaysAgo?: number;
    /** days ago (if not zero) default is 400; if GT 20000101, interpreted as YYYYMMDD
applies to DUE date filtering */
    DueSinceDaysAgo?: number;
    /** Doc/Process type key; sets the filter */
    DocTypeKey?: string;
    /** When a key, sets the FOLDER FILTER for the search  (JavaScript, SOP, etc) */
    FolderKey?: string | undefined;
    /** When a key, sets the FOLDER FILTER for the search  (JavaScript, SOP, etc) */
    FolderPath?: string | undefined;
    /** When a key, sets the filter specified by UserFilterName  */
    UserFilterKey?: string | undefined;
    /** Specifies the filter for UserFilterKey (ResponsibleParty, SourceContact) */
    UserFilterName?: string | undefined;
    /** File Name (sets filter) */
    FileName?: string | undefined;
    /** Status (sets filter) */
    Status?: string | undefined;
    /** when true, allows upload (defaults true when FolderKey is specified, false otherwise); see PresetSearch | FileDrop */
    AllowUpload?: boolean;
    /** when true, sets the special "include closed" filter */
    IncludeClosed?: boolean;
    /** when true, includes documents in the search result (sets hidden filter) */
    IncludeDocuments?: boolean;
    /** when true, includes Files in the search result (sets hidden filter) */
    IncludeFiles?: boolean;
    /** Subtype (sets filter) */
    Subtype?: string | undefined;
    /** Page Title */
    PageTitle?: string | undefined;
    /** Project or mask; if ends with ! then the most recently tracked project is used;  sets the project filter */
    Project?: string | undefined;
    /** Max load; default is 4000 */
    SearchLimit?: number;
    /** Automatically Refresh every n minutes; zero if off  */
    RefreshEveryMinutes?: number;
    /** for example: DocDate DESC, Title */
    SortOn?: string | undefined;
    /** When a key, sets hidden WithAttachedFile filter and requires a relationship with specified file */
    WithAttachedFile?: string | undefined;
    /** Locked Filters by name */
    LockedFilterNames?: string[] | undefined;
    /** scripts to load */
    JSIncludes?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ICatalogPreset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.SetId = _data["SetId"];
            this.CreatedSinceDaysAgo = _data["CreatedSinceDaysAgo"];
            this.DueSinceDaysAgo = _data["DueSinceDaysAgo"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.FolderKey = _data["FolderKey"];
            this.FolderPath = _data["FolderPath"];
            this.UserFilterKey = _data["UserFilterKey"];
            this.UserFilterName = _data["UserFilterName"];
            this.FileName = _data["FileName"];
            this.Status = _data["Status"];
            this.AllowUpload = _data["AllowUpload"];
            this.IncludeClosed = _data["IncludeClosed"];
            this.IncludeDocuments = _data["IncludeDocuments"];
            this.IncludeFiles = _data["IncludeFiles"];
            this.Subtype = _data["Subtype"];
            this.PageTitle = _data["PageTitle"];
            this.Project = _data["Project"];
            this.SearchLimit = _data["SearchLimit"];
            this.RefreshEveryMinutes = _data["RefreshEveryMinutes"];
            this.SortOn = _data["SortOn"];
            this.WithAttachedFile = _data["WithAttachedFile"];
            if (Array.isArray(_data["LockedFilterNames"])) {
                this.LockedFilterNames = [] as any;
                for (let item of _data["LockedFilterNames"])
                    this.LockedFilterNames!.push(item);
            }
            this.JSIncludes = _data["JSIncludes"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): CatalogPreset {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogPreset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SetId"] = this.SetId;
        data["CreatedSinceDaysAgo"] = this.CreatedSinceDaysAgo;
        data["DueSinceDaysAgo"] = this.DueSinceDaysAgo;
        data["DocTypeKey"] = this.DocTypeKey;
        data["FolderKey"] = this.FolderKey;
        data["FolderPath"] = this.FolderPath;
        data["UserFilterKey"] = this.UserFilterKey;
        data["UserFilterName"] = this.UserFilterName;
        data["FileName"] = this.FileName;
        data["Status"] = this.Status;
        data["AllowUpload"] = this.AllowUpload;
        data["IncludeClosed"] = this.IncludeClosed;
        data["IncludeDocuments"] = this.IncludeDocuments;
        data["IncludeFiles"] = this.IncludeFiles;
        data["Subtype"] = this.Subtype;
        data["PageTitle"] = this.PageTitle;
        data["Project"] = this.Project;
        data["SearchLimit"] = this.SearchLimit;
        data["RefreshEveryMinutes"] = this.RefreshEveryMinutes;
        data["SortOn"] = this.SortOn;
        data["WithAttachedFile"] = this.WithAttachedFile;
        if (Array.isArray(this.LockedFilterNames)) {
            data["LockedFilterNames"] = [];
            for (let item of this.LockedFilterNames)
                data["LockedFilterNames"].push(item);
        }
        data["JSIncludes"] = this.JSIncludes;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): CatalogPreset {
        const json = this.toJSON();
        let result = new CatalogPreset();
        result.init(json);
        return result;
    }
}

/** Information about catalog preset search settings */
export interface ICatalogPreset {
    /** id of this set */
    SetId?: string | undefined;
    /** days ago (if not zero) default is 400; if GT 20000101, interpreted as YYYYMMDD
applies to DUE date filtering */
    CreatedSinceDaysAgo?: number;
    /** days ago (if not zero) default is 400; if GT 20000101, interpreted as YYYYMMDD
applies to DUE date filtering */
    DueSinceDaysAgo?: number;
    /** Doc/Process type key; sets the filter */
    DocTypeKey?: string;
    /** When a key, sets the FOLDER FILTER for the search  (JavaScript, SOP, etc) */
    FolderKey?: string | undefined;
    /** When a key, sets the FOLDER FILTER for the search  (JavaScript, SOP, etc) */
    FolderPath?: string | undefined;
    /** When a key, sets the filter specified by UserFilterName  */
    UserFilterKey?: string | undefined;
    /** Specifies the filter for UserFilterKey (ResponsibleParty, SourceContact) */
    UserFilterName?: string | undefined;
    /** File Name (sets filter) */
    FileName?: string | undefined;
    /** Status (sets filter) */
    Status?: string | undefined;
    /** when true, allows upload (defaults true when FolderKey is specified, false otherwise); see PresetSearch | FileDrop */
    AllowUpload?: boolean;
    /** when true, sets the special "include closed" filter */
    IncludeClosed?: boolean;
    /** when true, includes documents in the search result (sets hidden filter) */
    IncludeDocuments?: boolean;
    /** when true, includes Files in the search result (sets hidden filter) */
    IncludeFiles?: boolean;
    /** Subtype (sets filter) */
    Subtype?: string | undefined;
    /** Page Title */
    PageTitle?: string | undefined;
    /** Project or mask; if ends with ! then the most recently tracked project is used;  sets the project filter */
    Project?: string | undefined;
    /** Max load; default is 4000 */
    SearchLimit?: number;
    /** Automatically Refresh every n minutes; zero if off  */
    RefreshEveryMinutes?: number;
    /** for example: DocDate DESC, Title */
    SortOn?: string | undefined;
    /** When a key, sets hidden WithAttachedFile filter and requires a relationship with specified file */
    WithAttachedFile?: string | undefined;
    /** Locked Filters by name */
    LockedFilterNames?: string[] | undefined;
    /** scripts to load */
    JSIncludes?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Read only description of an cost transaction posted to a project */
export class FileAccessHistory implements IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID?: number;
    /** When this access transaction occurred */
    Accessed?: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache?: boolean;
    /** User Key  for this transaction  */
    UserKey!: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IFileAccessHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserName = _data["UserName"];
            this.FileName = _data["FileName"];
            this.RevID = _data["RevID"];
            this.Accessed = _data["Accessed"] ? new Date(_data["Accessed"].toString()) : <any>undefined;
            this.AccessType = _data["AccessType"];
            this.WithDocument = _data["WithDocument"];
            this.AccessInfo = _data["AccessInfo"];
            this.UsedCache = _data["UsedCache"];
            this.UserKey = _data["UserKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): FileAccessHistory {
        data = typeof data === 'object' ? data : {};
        let result = new FileAccessHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.UserName;
        data["FileName"] = this.FileName;
        data["RevID"] = this.RevID;
        data["Accessed"] = this.Accessed ? this.Accessed.toISOString() : <any>undefined;
        data["AccessType"] = this.AccessType;
        data["WithDocument"] = this.WithDocument;
        data["AccessInfo"] = this.AccessInfo;
        data["UsedCache"] = this.UsedCache;
        data["UserKey"] = this.UserKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): FileAccessHistory {
        const json = this.toJSON();
        let result = new FileAccessHistory();
        result.init(json);
        return result;
    }
}

/** Read only description of an cost transaction posted to a project */
export interface IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID?: number;
    /** When this access transaction occurred */
    Accessed?: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache?: boolean;
    /** User Key  for this transaction  */
    UserKey: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Information about file versions */
export class FileVersion implements IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey?: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID?: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged?: Date;
    /** When Approved */
    Approved?: Date;
    /** User that approved this */
    ApprovedBy?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize?: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion?: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IFileVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.FileVerKey = _data["FileVerKey"];
            this.RevID = _data["RevID"];
            this.DataHash = _data["DataHash"];
            this.SourceRevision = _data["SourceRevision"];
            this.Cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.Approved = _data["Approved"] ? new Date(_data["Approved"].toString()) : <any>undefined;
            this.ApprovedBy = _data["ApprovedBy"];
            this.FromUser = _data["FromUser"];
            this.TxtData = _data["TxtData"];
            this.BinSize = _data["BinSize"];
            this.IsCurrentApprovedVersion = _data["IsCurrentApprovedVersion"];
            this.NoCanDelete = _data["NoCanDelete"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): FileVersion {
        data = typeof data === 'object' ? data : {};
        let result = new FileVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileVerKey"] = this.FileVerKey;
        data["RevID"] = this.RevID;
        data["DataHash"] = this.DataHash;
        data["SourceRevision"] = this.SourceRevision;
        data["Cataloged"] = this.Cataloged ? this.Cataloged.toISOString() : <any>undefined;
        data["Approved"] = this.Approved ? this.Approved.toISOString() : <any>undefined;
        data["ApprovedBy"] = this.ApprovedBy;
        data["FromUser"] = this.FromUser;
        data["TxtData"] = this.TxtData;
        data["BinSize"] = this.BinSize;
        data["IsCurrentApprovedVersion"] = this.IsCurrentApprovedVersion;
        data["NoCanDelete"] = this.NoCanDelete;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): FileVersion {
        const json = this.toJSON();
        let result = new FileVersion();
        result.init(json);
        return result;
    }
}

/** Information about file versions */
export interface IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey?: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID?: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged?: Date;
    /** When Approved */
    Approved?: Date;
    /** User that approved this */
    ApprovedBy?: string;
    /** Links to a user/contact  */
    FromUser?: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize?: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion?: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Represents an action result for a <see cref="F:System.Net.HttpStatusCode.Redirect"/>. */
export class RedirectResult implements IRedirectResult {
    /** Gets the location at which the content has been created. */
    Location?: string | undefined;
    /** Gets the request message which led to this result. */
    Request?: HttpRequestMessage | undefined;

    constructor(data?: IRedirectResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Location = _data["Location"];
            this.Request = _data["Request"] ? HttpRequestMessage.fromJS(_data["Request"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RedirectResult {
        data = typeof data === 'object' ? data : {};
        let result = new RedirectResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Location"] = this.Location;
        data["Request"] = this.Request ? this.Request.toJSON() : <any>undefined;
        return data;
    }

    clone(): RedirectResult {
        const json = this.toJSON();
        let result = new RedirectResult();
        result.init(json);
        return result;
    }
}

/** Represents an action result for a <see cref="F:System.Net.HttpStatusCode.Redirect"/>. */
export interface IRedirectResult {
    /** Gets the location at which the content has been created. */
    Location?: string | undefined;
    /** Gets the request message which led to this result. */
    Request?: HttpRequestMessage | undefined;
}

export class HttpRequestMessage implements IHttpRequestMessage {
    Version?: Version | undefined;
    Content?: HttpContent | undefined;
    Method?: HttpMethod | undefined;
    RequestUri?: string | undefined;
    Headers?: HttpRequestHeaders | undefined;
    Properties?: { [key: string]: any; } | undefined;

    constructor(data?: IHttpRequestMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Version = _data["Version"] ? Version.fromJS(_data["Version"]) : <any>undefined;
            this.Content = _data["Content"] ? HttpContent.fromJS(_data["Content"]) : <any>undefined;
            this.Method = _data["Method"] ? HttpMethod.fromJS(_data["Method"]) : <any>undefined;
            this.RequestUri = _data["RequestUri"];
            this.Headers = _data["Headers"] ? HttpRequestHeaders.fromJS(_data["Headers"]) : <any>undefined;
            if (_data["Properties"]) {
                this.Properties = {} as any;
                for (let key in _data["Properties"]) {
                    if (_data["Properties"].hasOwnProperty(key))
                        (<any>this.Properties)![key] = _data["Properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): HttpRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Version"] = this.Version ? this.Version.toJSON() : <any>undefined;
        data["Content"] = this.Content ? this.Content.toJSON() : <any>undefined;
        data["Method"] = this.Method ? this.Method.toJSON() : <any>undefined;
        data["RequestUri"] = this.RequestUri;
        data["Headers"] = this.Headers ? this.Headers.toJSON() : <any>undefined;
        if (this.Properties) {
            data["Properties"] = {};
            for (let key in this.Properties) {
                if (this.Properties.hasOwnProperty(key))
                    (<any>data["Properties"])[key] = (<any>this.Properties)[key];
            }
        }
        return data;
    }

    clone(): HttpRequestMessage {
        const json = this.toJSON();
        let result = new HttpRequestMessage();
        result.init(json);
        return result;
    }
}

export interface IHttpRequestMessage {
    Version?: Version | undefined;
    Content?: HttpContent | undefined;
    Method?: HttpMethod | undefined;
    RequestUri?: string | undefined;
    Headers?: HttpRequestHeaders | undefined;
    Properties?: { [key: string]: any; } | undefined;
}

export class Version implements IVersion {
    Major?: number;
    Minor?: number;
    Build?: number;
    Revision?: number;
    MajorRevision?: number;
    MinorRevision?: number;

    constructor(data?: IVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Major = _data["Major"];
            this.Minor = _data["Minor"];
            this.Build = _data["Build"];
            this.Revision = _data["Revision"];
            this.MajorRevision = _data["MajorRevision"];
            this.MinorRevision = _data["MinorRevision"];
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Major"] = this.Major;
        data["Minor"] = this.Minor;
        data["Build"] = this.Build;
        data["Revision"] = this.Revision;
        data["MajorRevision"] = this.MajorRevision;
        data["MinorRevision"] = this.MinorRevision;
        return data;
    }

    clone(): Version {
        const json = this.toJSON();
        let result = new Version();
        result.init(json);
        return result;
    }
}

export interface IVersion {
    Major?: number;
    Minor?: number;
    Build?: number;
    Revision?: number;
    MajorRevision?: number;
    MinorRevision?: number;
}

export abstract class HttpContent implements IHttpContent {
    Headers?: HttpContentHeaders | undefined;

    constructor(data?: IHttpContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Headers = _data["Headers"] ? HttpContentHeaders.fromJS(_data["Headers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpContent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpContent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Headers"] = this.Headers ? this.Headers.toJSON() : <any>undefined;
        return data;
    }

    clone(): HttpContent {
        throw new Error("The abstract class 'HttpContent' cannot be instantiated.");
    }
}

export interface IHttpContent {
    Headers?: HttpContentHeaders | undefined;
}

export class Anonymous implements IAnonymous {
    Allow?: string[] | undefined;
    ContentDisposition?: ContentDispositionHeaderValue | undefined;
    ContentEncoding?: string[] | undefined;
    ContentLanguage?: string[] | undefined;
    ContentLength?: number | undefined;
    ContentLocation?: string | undefined;
    ContentMD5?: string | undefined;
    ContentRange?: ContentRangeHeaderValue | undefined;
    ContentType?: MediaTypeHeaderValue | undefined;
    Expires?: Date | undefined;
    LastModified?: Date | undefined;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Allow"])) {
                this.Allow = [] as any;
                for (let item of _data["Allow"])
                    this.Allow!.push(item);
            }
            this.ContentDisposition = _data["ContentDisposition"] ? ContentDispositionHeaderValue.fromJS(_data["ContentDisposition"]) : <any>undefined;
            if (Array.isArray(_data["ContentEncoding"])) {
                this.ContentEncoding = [] as any;
                for (let item of _data["ContentEncoding"])
                    this.ContentEncoding!.push(item);
            }
            if (Array.isArray(_data["ContentLanguage"])) {
                this.ContentLanguage = [] as any;
                for (let item of _data["ContentLanguage"])
                    this.ContentLanguage!.push(item);
            }
            this.ContentLength = _data["ContentLength"];
            this.ContentLocation = _data["ContentLocation"];
            this.ContentMD5 = _data["ContentMD5"];
            this.ContentRange = _data["ContentRange"] ? ContentRangeHeaderValue.fromJS(_data["ContentRange"]) : <any>undefined;
            this.ContentType = _data["ContentType"] ? MediaTypeHeaderValue.fromJS(_data["ContentType"]) : <any>undefined;
            this.Expires = _data["Expires"] ? new Date(_data["Expires"].toString()) : <any>undefined;
            this.LastModified = _data["LastModified"] ? new Date(_data["LastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.Allow)) {
            data["Allow"] = [];
            for (let item of this.Allow)
                data["Allow"].push(item);
        }
        data["ContentDisposition"] = this.ContentDisposition ? this.ContentDisposition.toJSON() : <any>undefined;
        if (Array.isArray(this.ContentEncoding)) {
            data["ContentEncoding"] = [];
            for (let item of this.ContentEncoding)
                data["ContentEncoding"].push(item);
        }
        if (Array.isArray(this.ContentLanguage)) {
            data["ContentLanguage"] = [];
            for (let item of this.ContentLanguage)
                data["ContentLanguage"].push(item);
        }
        data["ContentLength"] = this.ContentLength;
        data["ContentLocation"] = this.ContentLocation;
        data["ContentMD5"] = this.ContentMD5;
        data["ContentRange"] = this.ContentRange ? this.ContentRange.toJSON() : <any>undefined;
        data["ContentType"] = this.ContentType ? this.ContentType.toJSON() : <any>undefined;
        data["Expires"] = this.Expires ? this.Expires.toISOString() : <any>undefined;
        data["LastModified"] = this.LastModified ? this.LastModified.toISOString() : <any>undefined;
        return data;
    }

    clone(): Anonymous {
        const json = this.toJSON();
        let result = new Anonymous();
        result.init(json);
        return result;
    }
}

export interface IAnonymous {
    Allow?: string[] | undefined;
    ContentDisposition?: ContentDispositionHeaderValue | undefined;
    ContentEncoding?: string[] | undefined;
    ContentLanguage?: string[] | undefined;
    ContentLength?: number | undefined;
    ContentLocation?: string | undefined;
    ContentMD5?: string | undefined;
    ContentRange?: ContentRangeHeaderValue | undefined;
    ContentType?: MediaTypeHeaderValue | undefined;
    Expires?: Date | undefined;
    LastModified?: Date | undefined;
}

export class HttpContentHeaders extends Anonymous implements IHttpContentHeaders {

    [key: string]: any;

    constructor(data?: IHttpContentHeaders) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HttpContentHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContentHeaders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }

    clone(): HttpContentHeaders {
        const json = this.toJSON();
        let result = new HttpContentHeaders();
        result.init(json);
        return result;
    }
}

export interface IHttpContentHeaders extends IAnonymous {

    [key: string]: any;
}

export class ContentDispositionHeaderValue implements IContentDispositionHeaderValue {
    DispositionType?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;
    Name?: string | undefined;
    FileName?: string | undefined;
    FileNameStar?: string | undefined;
    CreationDate?: Date | undefined;
    ModificationDate?: Date | undefined;
    ReadDate?: Date | undefined;
    Size?: number | undefined;

    constructor(data?: IContentDispositionHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DispositionType = _data["DispositionType"];
            if (Array.isArray(_data["Parameters"])) {
                this.Parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.Parameters!.push(NameValueHeaderValue.fromJS(item));
            }
            this.Name = _data["Name"];
            this.FileName = _data["FileName"];
            this.FileNameStar = _data["FileNameStar"];
            this.CreationDate = _data["CreationDate"] ? new Date(_data["CreationDate"].toString()) : <any>undefined;
            this.ModificationDate = _data["ModificationDate"] ? new Date(_data["ModificationDate"].toString()) : <any>undefined;
            this.ReadDate = _data["ReadDate"] ? new Date(_data["ReadDate"].toString()) : <any>undefined;
            this.Size = _data["Size"];
        }
    }

    static fromJS(data: any): ContentDispositionHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDispositionHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DispositionType"] = this.DispositionType;
        if (Array.isArray(this.Parameters)) {
            data["Parameters"] = [];
            for (let item of this.Parameters)
                data["Parameters"].push(item.toJSON());
        }
        data["Name"] = this.Name;
        data["FileName"] = this.FileName;
        data["FileNameStar"] = this.FileNameStar;
        data["CreationDate"] = this.CreationDate ? this.CreationDate.toISOString() : <any>undefined;
        data["ModificationDate"] = this.ModificationDate ? this.ModificationDate.toISOString() : <any>undefined;
        data["ReadDate"] = this.ReadDate ? this.ReadDate.toISOString() : <any>undefined;
        data["Size"] = this.Size;
        return data;
    }

    clone(): ContentDispositionHeaderValue {
        const json = this.toJSON();
        let result = new ContentDispositionHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IContentDispositionHeaderValue {
    DispositionType?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;
    Name?: string | undefined;
    FileName?: string | undefined;
    FileNameStar?: string | undefined;
    CreationDate?: Date | undefined;
    ModificationDate?: Date | undefined;
    ReadDate?: Date | undefined;
    Size?: number | undefined;
}

export class NameValueHeaderValue implements INameValueHeaderValue {
    Name?: string | undefined;
    Value?: string | undefined;

    constructor(data?: INameValueHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Name = _data["Name"];
            this.Value = _data["Value"];
        }
    }

    static fromJS(data: any): NameValueHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.Name;
        data["Value"] = this.Value;
        return data;
    }

    clone(): NameValueHeaderValue {
        const json = this.toJSON();
        let result = new NameValueHeaderValue();
        result.init(json);
        return result;
    }
}

export interface INameValueHeaderValue {
    Name?: string | undefined;
    Value?: string | undefined;
}

export class ContentRangeHeaderValue implements IContentRangeHeaderValue {
    Unit?: string | undefined;
    From?: number | undefined;
    To?: number | undefined;
    Length?: number | undefined;
    HasLength?: boolean;
    HasRange?: boolean;

    constructor(data?: IContentRangeHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Unit = _data["Unit"];
            this.From = _data["From"];
            this.To = _data["To"];
            this.Length = _data["Length"];
            this.HasLength = _data["HasLength"];
            this.HasRange = _data["HasRange"];
        }
    }

    static fromJS(data: any): ContentRangeHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRangeHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Unit"] = this.Unit;
        data["From"] = this.From;
        data["To"] = this.To;
        data["Length"] = this.Length;
        data["HasLength"] = this.HasLength;
        data["HasRange"] = this.HasRange;
        return data;
    }

    clone(): ContentRangeHeaderValue {
        const json = this.toJSON();
        let result = new ContentRangeHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IContentRangeHeaderValue {
    Unit?: string | undefined;
    From?: number | undefined;
    To?: number | undefined;
    Length?: number | undefined;
    HasLength?: boolean;
    HasRange?: boolean;
}

export class MediaTypeHeaderValue implements IMediaTypeHeaderValue {
    CharSet?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;
    MediaType?: string | undefined;

    constructor(data?: IMediaTypeHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.CharSet = _data["CharSet"];
            if (Array.isArray(_data["Parameters"])) {
                this.Parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.Parameters!.push(NameValueHeaderValue.fromJS(item));
            }
            this.MediaType = _data["MediaType"];
        }
    }

    static fromJS(data: any): MediaTypeHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new MediaTypeHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CharSet"] = this.CharSet;
        if (Array.isArray(this.Parameters)) {
            data["Parameters"] = [];
            for (let item of this.Parameters)
                data["Parameters"].push(item.toJSON());
        }
        data["MediaType"] = this.MediaType;
        return data;
    }

    clone(): MediaTypeHeaderValue {
        const json = this.toJSON();
        let result = new MediaTypeHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IMediaTypeHeaderValue {
    CharSet?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;
    MediaType?: string | undefined;
}

export class KeyValuePairOfStringAndIEnumerableOfString implements IKeyValuePairOfStringAndIEnumerableOfString {
    Key?: string | undefined;
    Value?: string[] | undefined;

    constructor(data?: IKeyValuePairOfStringAndIEnumerableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Key = _data["Key"];
            if (Array.isArray(_data["Value"])) {
                this.Value = [] as any;
                for (let item of _data["Value"])
                    this.Value!.push(item);
            }
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndIEnumerableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndIEnumerableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.Key;
        if (Array.isArray(this.Value)) {
            data["Value"] = [];
            for (let item of this.Value)
                data["Value"].push(item);
        }
        return data;
    }

    clone(): KeyValuePairOfStringAndIEnumerableOfString {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringAndIEnumerableOfString();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringAndIEnumerableOfString {
    Key?: string | undefined;
    Value?: string[] | undefined;
}

export class HttpMethod implements IHttpMethod {
    Method?: string | undefined;

    constructor(data?: IHttpMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Method = _data["Method"];
        }
    }

    static fromJS(data: any): HttpMethod {
        data = typeof data === 'object' ? data : {};
        let result = new HttpMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Method"] = this.Method;
        return data;
    }

    clone(): HttpMethod {
        const json = this.toJSON();
        let result = new HttpMethod();
        result.init(json);
        return result;
    }
}

export interface IHttpMethod {
    Method?: string | undefined;
}

export class Anonymous2 implements IAnonymous2 {
    Accept?: MediaTypeWithQualityHeaderValue[] | undefined;
    AcceptCharset?: StringWithQualityHeaderValue[] | undefined;
    AcceptEncoding?: StringWithQualityHeaderValue[] | undefined;
    AcceptLanguage?: StringWithQualityHeaderValue[] | undefined;
    Authorization?: AuthenticationHeaderValue | undefined;
    Expect?: NameValueWithParametersHeaderValue[] | undefined;
    ExpectContinue?: boolean | undefined;
    From?: string | undefined;
    Host?: string | undefined;
    IfMatch?: EntityTagHeaderValue[] | undefined;
    IfModifiedSince?: Date | undefined;
    IfNoneMatch?: EntityTagHeaderValue[] | undefined;
    IfRange?: RangeConditionHeaderValue | undefined;
    IfUnmodifiedSince?: Date | undefined;
    MaxForwards?: number | undefined;
    ProxyAuthorization?: AuthenticationHeaderValue | undefined;
    Range?: RangeHeaderValue | undefined;
    Referrer?: string | undefined;
    TE?: TransferCodingWithQualityHeaderValue[] | undefined;
    UserAgent?: ProductInfoHeaderValue[] | undefined;
    CacheControl?: CacheControlHeaderValue | undefined;
    Connection?: string[] | undefined;
    ConnectionClose?: boolean | undefined;
    Date?: Date | undefined;
    Pragma?: NameValueHeaderValue[] | undefined;
    Trailer?: string[] | undefined;
    TransferEncoding?: TransferCodingHeaderValue[] | undefined;
    TransferEncodingChunked?: boolean | undefined;
    Upgrade?: ProductHeaderValue[] | undefined;
    Via?: ViaHeaderValue[] | undefined;
    Warning?: WarningHeaderValue[] | undefined;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Accept"])) {
                this.Accept = [] as any;
                for (let item of _data["Accept"])
                    this.Accept!.push(MediaTypeWithQualityHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["AcceptCharset"])) {
                this.AcceptCharset = [] as any;
                for (let item of _data["AcceptCharset"])
                    this.AcceptCharset!.push(StringWithQualityHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["AcceptEncoding"])) {
                this.AcceptEncoding = [] as any;
                for (let item of _data["AcceptEncoding"])
                    this.AcceptEncoding!.push(StringWithQualityHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["AcceptLanguage"])) {
                this.AcceptLanguage = [] as any;
                for (let item of _data["AcceptLanguage"])
                    this.AcceptLanguage!.push(StringWithQualityHeaderValue.fromJS(item));
            }
            this.Authorization = _data["Authorization"] ? AuthenticationHeaderValue.fromJS(_data["Authorization"]) : <any>undefined;
            if (Array.isArray(_data["Expect"])) {
                this.Expect = [] as any;
                for (let item of _data["Expect"])
                    this.Expect!.push(NameValueWithParametersHeaderValue.fromJS(item));
            }
            this.ExpectContinue = _data["ExpectContinue"];
            this.From = _data["From"];
            this.Host = _data["Host"];
            if (Array.isArray(_data["IfMatch"])) {
                this.IfMatch = [] as any;
                for (let item of _data["IfMatch"])
                    this.IfMatch!.push(EntityTagHeaderValue.fromJS(item));
            }
            this.IfModifiedSince = _data["IfModifiedSince"] ? new Date(_data["IfModifiedSince"].toString()) : <any>undefined;
            if (Array.isArray(_data["IfNoneMatch"])) {
                this.IfNoneMatch = [] as any;
                for (let item of _data["IfNoneMatch"])
                    this.IfNoneMatch!.push(EntityTagHeaderValue.fromJS(item));
            }
            this.IfRange = _data["IfRange"] ? RangeConditionHeaderValue.fromJS(_data["IfRange"]) : <any>undefined;
            this.IfUnmodifiedSince = _data["IfUnmodifiedSince"] ? new Date(_data["IfUnmodifiedSince"].toString()) : <any>undefined;
            this.MaxForwards = _data["MaxForwards"];
            this.ProxyAuthorization = _data["ProxyAuthorization"] ? AuthenticationHeaderValue.fromJS(_data["ProxyAuthorization"]) : <any>undefined;
            this.Range = _data["Range"] ? RangeHeaderValue.fromJS(_data["Range"]) : <any>undefined;
            this.Referrer = _data["Referrer"];
            if (Array.isArray(_data["TE"])) {
                this.TE = [] as any;
                for (let item of _data["TE"])
                    this.TE!.push(TransferCodingWithQualityHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["UserAgent"])) {
                this.UserAgent = [] as any;
                for (let item of _data["UserAgent"])
                    this.UserAgent!.push(ProductInfoHeaderValue.fromJS(item));
            }
            this.CacheControl = _data["CacheControl"] ? CacheControlHeaderValue.fromJS(_data["CacheControl"]) : <any>undefined;
            if (Array.isArray(_data["Connection"])) {
                this.Connection = [] as any;
                for (let item of _data["Connection"])
                    this.Connection!.push(item);
            }
            this.ConnectionClose = _data["ConnectionClose"];
            this.Date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["Pragma"])) {
                this.Pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.Pragma!.push(NameValueHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Trailer"])) {
                this.Trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.Trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.TransferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.TransferEncoding!.push(TransferCodingHeaderValue.fromJS(item));
            }
            this.TransferEncodingChunked = _data["TransferEncodingChunked"];
            if (Array.isArray(_data["Upgrade"])) {
                this.Upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.Upgrade!.push(ProductHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Via"])) {
                this.Via = [] as any;
                for (let item of _data["Via"])
                    this.Via!.push(ViaHeaderValue.fromJS(item));
            }
            if (Array.isArray(_data["Warning"])) {
                this.Warning = [] as any;
                for (let item of _data["Warning"])
                    this.Warning!.push(WarningHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.Accept)) {
            data["Accept"] = [];
            for (let item of this.Accept)
                data["Accept"].push(item.toJSON());
        }
        if (Array.isArray(this.AcceptCharset)) {
            data["AcceptCharset"] = [];
            for (let item of this.AcceptCharset)
                data["AcceptCharset"].push(item.toJSON());
        }
        if (Array.isArray(this.AcceptEncoding)) {
            data["AcceptEncoding"] = [];
            for (let item of this.AcceptEncoding)
                data["AcceptEncoding"].push(item.toJSON());
        }
        if (Array.isArray(this.AcceptLanguage)) {
            data["AcceptLanguage"] = [];
            for (let item of this.AcceptLanguage)
                data["AcceptLanguage"].push(item.toJSON());
        }
        data["Authorization"] = this.Authorization ? this.Authorization.toJSON() : <any>undefined;
        if (Array.isArray(this.Expect)) {
            data["Expect"] = [];
            for (let item of this.Expect)
                data["Expect"].push(item.toJSON());
        }
        data["ExpectContinue"] = this.ExpectContinue;
        data["From"] = this.From;
        data["Host"] = this.Host;
        if (Array.isArray(this.IfMatch)) {
            data["IfMatch"] = [];
            for (let item of this.IfMatch)
                data["IfMatch"].push(item.toJSON());
        }
        data["IfModifiedSince"] = this.IfModifiedSince ? this.IfModifiedSince.toISOString() : <any>undefined;
        if (Array.isArray(this.IfNoneMatch)) {
            data["IfNoneMatch"] = [];
            for (let item of this.IfNoneMatch)
                data["IfNoneMatch"].push(item.toJSON());
        }
        data["IfRange"] = this.IfRange ? this.IfRange.toJSON() : <any>undefined;
        data["IfUnmodifiedSince"] = this.IfUnmodifiedSince ? this.IfUnmodifiedSince.toISOString() : <any>undefined;
        data["MaxForwards"] = this.MaxForwards;
        data["ProxyAuthorization"] = this.ProxyAuthorization ? this.ProxyAuthorization.toJSON() : <any>undefined;
        data["Range"] = this.Range ? this.Range.toJSON() : <any>undefined;
        data["Referrer"] = this.Referrer;
        if (Array.isArray(this.TE)) {
            data["TE"] = [];
            for (let item of this.TE)
                data["TE"].push(item.toJSON());
        }
        if (Array.isArray(this.UserAgent)) {
            data["UserAgent"] = [];
            for (let item of this.UserAgent)
                data["UserAgent"].push(item.toJSON());
        }
        data["CacheControl"] = this.CacheControl ? this.CacheControl.toJSON() : <any>undefined;
        if (Array.isArray(this.Connection)) {
            data["Connection"] = [];
            for (let item of this.Connection)
                data["Connection"].push(item);
        }
        data["ConnectionClose"] = this.ConnectionClose;
        data["Date"] = this.Date ? this.Date.toISOString() : <any>undefined;
        if (Array.isArray(this.Pragma)) {
            data["Pragma"] = [];
            for (let item of this.Pragma)
                data["Pragma"].push(item.toJSON());
        }
        if (Array.isArray(this.Trailer)) {
            data["Trailer"] = [];
            for (let item of this.Trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.TransferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.TransferEncoding)
                data["TransferEncoding"].push(item.toJSON());
        }
        data["TransferEncodingChunked"] = this.TransferEncodingChunked;
        if (Array.isArray(this.Upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.Upgrade)
                data["Upgrade"].push(item.toJSON());
        }
        if (Array.isArray(this.Via)) {
            data["Via"] = [];
            for (let item of this.Via)
                data["Via"].push(item.toJSON());
        }
        if (Array.isArray(this.Warning)) {
            data["Warning"] = [];
            for (let item of this.Warning)
                data["Warning"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous2 {
        const json = this.toJSON();
        let result = new Anonymous2();
        result.init(json);
        return result;
    }
}

export interface IAnonymous2 {
    Accept?: MediaTypeWithQualityHeaderValue[] | undefined;
    AcceptCharset?: StringWithQualityHeaderValue[] | undefined;
    AcceptEncoding?: StringWithQualityHeaderValue[] | undefined;
    AcceptLanguage?: StringWithQualityHeaderValue[] | undefined;
    Authorization?: AuthenticationHeaderValue | undefined;
    Expect?: NameValueWithParametersHeaderValue[] | undefined;
    ExpectContinue?: boolean | undefined;
    From?: string | undefined;
    Host?: string | undefined;
    IfMatch?: EntityTagHeaderValue[] | undefined;
    IfModifiedSince?: Date | undefined;
    IfNoneMatch?: EntityTagHeaderValue[] | undefined;
    IfRange?: RangeConditionHeaderValue | undefined;
    IfUnmodifiedSince?: Date | undefined;
    MaxForwards?: number | undefined;
    ProxyAuthorization?: AuthenticationHeaderValue | undefined;
    Range?: RangeHeaderValue | undefined;
    Referrer?: string | undefined;
    TE?: TransferCodingWithQualityHeaderValue[] | undefined;
    UserAgent?: ProductInfoHeaderValue[] | undefined;
    CacheControl?: CacheControlHeaderValue | undefined;
    Connection?: string[] | undefined;
    ConnectionClose?: boolean | undefined;
    Date?: Date | undefined;
    Pragma?: NameValueHeaderValue[] | undefined;
    Trailer?: string[] | undefined;
    TransferEncoding?: TransferCodingHeaderValue[] | undefined;
    TransferEncodingChunked?: boolean | undefined;
    Upgrade?: ProductHeaderValue[] | undefined;
    Via?: ViaHeaderValue[] | undefined;
    Warning?: WarningHeaderValue[] | undefined;
}

export class HttpRequestHeaders extends Anonymous2 implements IHttpRequestHeaders {

    [key: string]: any;

    constructor(data?: IHttpRequestHeaders) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HttpRequestHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequestHeaders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }

    clone(): HttpRequestHeaders {
        const json = this.toJSON();
        let result = new HttpRequestHeaders();
        result.init(json);
        return result;
    }
}

export interface IHttpRequestHeaders extends IAnonymous2 {

    [key: string]: any;
}

export class MediaTypeWithQualityHeaderValue extends MediaTypeHeaderValue implements IMediaTypeWithQualityHeaderValue {
    Quality?: number | undefined;

    constructor(data?: IMediaTypeWithQualityHeaderValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.Quality = _data["Quality"];
        }
    }

    static fromJS(data: any): MediaTypeWithQualityHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new MediaTypeWithQualityHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Quality"] = this.Quality;
        super.toJSON(data);
        return data;
    }

    clone(): MediaTypeWithQualityHeaderValue {
        const json = this.toJSON();
        let result = new MediaTypeWithQualityHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IMediaTypeWithQualityHeaderValue extends IMediaTypeHeaderValue {
    Quality?: number | undefined;
}

export class StringWithQualityHeaderValue implements IStringWithQualityHeaderValue {
    Value?: string | undefined;
    Quality?: number | undefined;

    constructor(data?: IStringWithQualityHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Value = _data["Value"];
            this.Quality = _data["Quality"];
        }
    }

    static fromJS(data: any): StringWithQualityHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new StringWithQualityHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.Value;
        data["Quality"] = this.Quality;
        return data;
    }

    clone(): StringWithQualityHeaderValue {
        const json = this.toJSON();
        let result = new StringWithQualityHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IStringWithQualityHeaderValue {
    Value?: string | undefined;
    Quality?: number | undefined;
}

export class AuthenticationHeaderValue implements IAuthenticationHeaderValue {
    Scheme?: string | undefined;
    Parameter?: string | undefined;

    constructor(data?: IAuthenticationHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Scheme = _data["Scheme"];
            this.Parameter = _data["Parameter"];
        }
    }

    static fromJS(data: any): AuthenticationHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Scheme"] = this.Scheme;
        data["Parameter"] = this.Parameter;
        return data;
    }

    clone(): AuthenticationHeaderValue {
        const json = this.toJSON();
        let result = new AuthenticationHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IAuthenticationHeaderValue {
    Scheme?: string | undefined;
    Parameter?: string | undefined;
}

export class NameValueWithParametersHeaderValue extends NameValueHeaderValue implements INameValueWithParametersHeaderValue {
    Parameters?: NameValueHeaderValue[] | undefined;

    constructor(data?: INameValueWithParametersHeaderValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["Parameters"])) {
                this.Parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.Parameters!.push(NameValueHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueWithParametersHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueWithParametersHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.Parameters)) {
            data["Parameters"] = [];
            for (let item of this.Parameters)
                data["Parameters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): NameValueWithParametersHeaderValue {
        const json = this.toJSON();
        let result = new NameValueWithParametersHeaderValue();
        result.init(json);
        return result;
    }
}

export interface INameValueWithParametersHeaderValue extends INameValueHeaderValue {
    Parameters?: NameValueHeaderValue[] | undefined;
}

export class EntityTagHeaderValue implements IEntityTagHeaderValue {
    Tag?: string | undefined;
    IsWeak?: boolean;

    constructor(data?: IEntityTagHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Tag = _data["Tag"];
            this.IsWeak = _data["IsWeak"];
        }
    }

    static fromJS(data: any): EntityTagHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Tag"] = this.Tag;
        data["IsWeak"] = this.IsWeak;
        return data;
    }

    clone(): EntityTagHeaderValue {
        const json = this.toJSON();
        let result = new EntityTagHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IEntityTagHeaderValue {
    Tag?: string | undefined;
    IsWeak?: boolean;
}

export class RangeConditionHeaderValue implements IRangeConditionHeaderValue {
    Date?: Date | undefined;
    EntityTag?: EntityTagHeaderValue | undefined;

    constructor(data?: IRangeConditionHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            this.EntityTag = _data["EntityTag"] ? EntityTagHeaderValue.fromJS(_data["EntityTag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RangeConditionHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new RangeConditionHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Date"] = this.Date ? this.Date.toISOString() : <any>undefined;
        data["EntityTag"] = this.EntityTag ? this.EntityTag.toJSON() : <any>undefined;
        return data;
    }

    clone(): RangeConditionHeaderValue {
        const json = this.toJSON();
        let result = new RangeConditionHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IRangeConditionHeaderValue {
    Date?: Date | undefined;
    EntityTag?: EntityTagHeaderValue | undefined;
}

export class RangeHeaderValue implements IRangeHeaderValue {
    Unit?: string | undefined;
    Ranges?: RangeItemHeaderValue[] | undefined;

    constructor(data?: IRangeHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Unit = _data["Unit"];
            if (Array.isArray(_data["Ranges"])) {
                this.Ranges = [] as any;
                for (let item of _data["Ranges"])
                    this.Ranges!.push(RangeItemHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RangeHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new RangeHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Unit"] = this.Unit;
        if (Array.isArray(this.Ranges)) {
            data["Ranges"] = [];
            for (let item of this.Ranges)
                data["Ranges"].push(item.toJSON());
        }
        return data;
    }

    clone(): RangeHeaderValue {
        const json = this.toJSON();
        let result = new RangeHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IRangeHeaderValue {
    Unit?: string | undefined;
    Ranges?: RangeItemHeaderValue[] | undefined;
}

export class RangeItemHeaderValue implements IRangeItemHeaderValue {
    From?: number | undefined;
    To?: number | undefined;

    constructor(data?: IRangeItemHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.From = _data["From"];
            this.To = _data["To"];
        }
    }

    static fromJS(data: any): RangeItemHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new RangeItemHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["From"] = this.From;
        data["To"] = this.To;
        return data;
    }

    clone(): RangeItemHeaderValue {
        const json = this.toJSON();
        let result = new RangeItemHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IRangeItemHeaderValue {
    From?: number | undefined;
    To?: number | undefined;
}

export class TransferCodingHeaderValue implements ITransferCodingHeaderValue {
    Value?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;

    constructor(data?: ITransferCodingHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Value = _data["Value"];
            if (Array.isArray(_data["Parameters"])) {
                this.Parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.Parameters!.push(NameValueHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransferCodingHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new TransferCodingHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.Value;
        if (Array.isArray(this.Parameters)) {
            data["Parameters"] = [];
            for (let item of this.Parameters)
                data["Parameters"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransferCodingHeaderValue {
        const json = this.toJSON();
        let result = new TransferCodingHeaderValue();
        result.init(json);
        return result;
    }
}

export interface ITransferCodingHeaderValue {
    Value?: string | undefined;
    Parameters?: NameValueHeaderValue[] | undefined;
}

export class TransferCodingWithQualityHeaderValue extends TransferCodingHeaderValue implements ITransferCodingWithQualityHeaderValue {
    Quality?: number | undefined;

    constructor(data?: ITransferCodingWithQualityHeaderValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.Quality = _data["Quality"];
        }
    }

    static fromJS(data: any): TransferCodingWithQualityHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new TransferCodingWithQualityHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Quality"] = this.Quality;
        super.toJSON(data);
        return data;
    }

    clone(): TransferCodingWithQualityHeaderValue {
        const json = this.toJSON();
        let result = new TransferCodingWithQualityHeaderValue();
        result.init(json);
        return result;
    }
}

export interface ITransferCodingWithQualityHeaderValue extends ITransferCodingHeaderValue {
    Quality?: number | undefined;
}

export class ProductInfoHeaderValue implements IProductInfoHeaderValue {
    Product?: ProductHeaderValue | undefined;
    Comment?: string | undefined;

    constructor(data?: IProductInfoHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Product = _data["Product"] ? ProductHeaderValue.fromJS(_data["Product"]) : <any>undefined;
            this.Comment = _data["Comment"];
        }
    }

    static fromJS(data: any): ProductInfoHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Product"] = this.Product ? this.Product.toJSON() : <any>undefined;
        data["Comment"] = this.Comment;
        return data;
    }

    clone(): ProductInfoHeaderValue {
        const json = this.toJSON();
        let result = new ProductInfoHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IProductInfoHeaderValue {
    Product?: ProductHeaderValue | undefined;
    Comment?: string | undefined;
}

export class ProductHeaderValue implements IProductHeaderValue {
    Name?: string | undefined;
    Version?: string | undefined;

    constructor(data?: IProductHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Name = _data["Name"];
            this.Version = _data["Version"];
        }
    }

    static fromJS(data: any): ProductHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ProductHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.Name;
        data["Version"] = this.Version;
        return data;
    }

    clone(): ProductHeaderValue {
        const json = this.toJSON();
        let result = new ProductHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IProductHeaderValue {
    Name?: string | undefined;
    Version?: string | undefined;
}

export class CacheControlHeaderValue implements ICacheControlHeaderValue {
    NoCache?: boolean;
    NoCacheHeaders?: string[] | undefined;
    NoStore?: boolean;
    MaxAge?: string | undefined;
    SharedMaxAge?: string | undefined;
    MaxStale?: boolean;
    MaxStaleLimit?: string | undefined;
    MinFresh?: string | undefined;
    NoTransform?: boolean;
    OnlyIfCached?: boolean;
    Public?: boolean;
    Private?: boolean;
    PrivateHeaders?: string[] | undefined;
    MustRevalidate?: boolean;
    ProxyRevalidate?: boolean;
    Extensions?: NameValueHeaderValue[] | undefined;

    constructor(data?: ICacheControlHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NoCache = _data["NoCache"];
            if (Array.isArray(_data["NoCacheHeaders"])) {
                this.NoCacheHeaders = [] as any;
                for (let item of _data["NoCacheHeaders"])
                    this.NoCacheHeaders!.push(item);
            }
            this.NoStore = _data["NoStore"];
            this.MaxAge = _data["MaxAge"];
            this.SharedMaxAge = _data["SharedMaxAge"];
            this.MaxStale = _data["MaxStale"];
            this.MaxStaleLimit = _data["MaxStaleLimit"];
            this.MinFresh = _data["MinFresh"];
            this.NoTransform = _data["NoTransform"];
            this.OnlyIfCached = _data["OnlyIfCached"];
            this.Public = _data["Public"];
            this.Private = _data["Private"];
            if (Array.isArray(_data["PrivateHeaders"])) {
                this.PrivateHeaders = [] as any;
                for (let item of _data["PrivateHeaders"])
                    this.PrivateHeaders!.push(item);
            }
            this.MustRevalidate = _data["MustRevalidate"];
            this.ProxyRevalidate = _data["ProxyRevalidate"];
            if (Array.isArray(_data["Extensions"])) {
                this.Extensions = [] as any;
                for (let item of _data["Extensions"])
                    this.Extensions!.push(NameValueHeaderValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CacheControlHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new CacheControlHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NoCache"] = this.NoCache;
        if (Array.isArray(this.NoCacheHeaders)) {
            data["NoCacheHeaders"] = [];
            for (let item of this.NoCacheHeaders)
                data["NoCacheHeaders"].push(item);
        }
        data["NoStore"] = this.NoStore;
        data["MaxAge"] = this.MaxAge;
        data["SharedMaxAge"] = this.SharedMaxAge;
        data["MaxStale"] = this.MaxStale;
        data["MaxStaleLimit"] = this.MaxStaleLimit;
        data["MinFresh"] = this.MinFresh;
        data["NoTransform"] = this.NoTransform;
        data["OnlyIfCached"] = this.OnlyIfCached;
        data["Public"] = this.Public;
        data["Private"] = this.Private;
        if (Array.isArray(this.PrivateHeaders)) {
            data["PrivateHeaders"] = [];
            for (let item of this.PrivateHeaders)
                data["PrivateHeaders"].push(item);
        }
        data["MustRevalidate"] = this.MustRevalidate;
        data["ProxyRevalidate"] = this.ProxyRevalidate;
        if (Array.isArray(this.Extensions)) {
            data["Extensions"] = [];
            for (let item of this.Extensions)
                data["Extensions"].push(item.toJSON());
        }
        return data;
    }

    clone(): CacheControlHeaderValue {
        const json = this.toJSON();
        let result = new CacheControlHeaderValue();
        result.init(json);
        return result;
    }
}

export interface ICacheControlHeaderValue {
    NoCache?: boolean;
    NoCacheHeaders?: string[] | undefined;
    NoStore?: boolean;
    MaxAge?: string | undefined;
    SharedMaxAge?: string | undefined;
    MaxStale?: boolean;
    MaxStaleLimit?: string | undefined;
    MinFresh?: string | undefined;
    NoTransform?: boolean;
    OnlyIfCached?: boolean;
    Public?: boolean;
    Private?: boolean;
    PrivateHeaders?: string[] | undefined;
    MustRevalidate?: boolean;
    ProxyRevalidate?: boolean;
    Extensions?: NameValueHeaderValue[] | undefined;
}

export class ViaHeaderValue implements IViaHeaderValue {
    ProtocolName?: string | undefined;
    ProtocolVersion?: string | undefined;
    ReceivedBy?: string | undefined;
    Comment?: string | undefined;

    constructor(data?: IViaHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ProtocolName = _data["ProtocolName"];
            this.ProtocolVersion = _data["ProtocolVersion"];
            this.ReceivedBy = _data["ReceivedBy"];
            this.Comment = _data["Comment"];
        }
    }

    static fromJS(data: any): ViaHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ViaHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProtocolName"] = this.ProtocolName;
        data["ProtocolVersion"] = this.ProtocolVersion;
        data["ReceivedBy"] = this.ReceivedBy;
        data["Comment"] = this.Comment;
        return data;
    }

    clone(): ViaHeaderValue {
        const json = this.toJSON();
        let result = new ViaHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IViaHeaderValue {
    ProtocolName?: string | undefined;
    ProtocolVersion?: string | undefined;
    ReceivedBy?: string | undefined;
    Comment?: string | undefined;
}

export class WarningHeaderValue implements IWarningHeaderValue {
    Code?: number;
    Agent?: string | undefined;
    Text?: string | undefined;
    Date?: Date | undefined;

    constructor(data?: IWarningHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Code = _data["Code"];
            this.Agent = _data["Agent"];
            this.Text = _data["Text"];
            this.Date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WarningHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new WarningHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.Code;
        data["Agent"] = this.Agent;
        data["Text"] = this.Text;
        data["Date"] = this.Date ? this.Date.toISOString() : <any>undefined;
        return data;
    }

    clone(): WarningHeaderValue {
        const json = this.toJSON();
        let result = new WarningHeaderValue();
        result.init(json);
        return result;
    }
}

export interface IWarningHeaderValue {
    Code?: number;
    Agent?: string | undefined;
    Text?: string | undefined;
    Date?: Date | undefined;
}

export class XferFilesStatus implements IXferFilesStatus {
    name?: string | undefined;
    key?: string | undefined;
    size?: number;
    progress?: string | undefined;
    error?: string | undefined;

    constructor(data?: IXferFilesStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
            this.size = _data["size"];
            this.progress = _data["progress"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): XferFilesStatus {
        data = typeof data === 'object' ? data : {};
        let result = new XferFilesStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        data["size"] = this.size;
        data["progress"] = this.progress;
        data["error"] = this.error;
        return data;
    }

    clone(): XferFilesStatus {
        const json = this.toJSON();
        let result = new XferFilesStatus();
        result.init(json);
        return result;
    }
}

export interface IXferFilesStatus {
    name?: string | undefined;
    key?: string | undefined;
    size?: number;
    progress?: string | undefined;
    error?: string | undefined;
}

/** Summary of Project Process (Document) types */
export class TypeSummary implements ITypeSummary {
    /** Key for Process Type */
    DocTypeKey!: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open?: number;
    /** Number of documents closed */
    cnt_closed?: number;
    /** Number of documents overdue */
    cnt_overdue?: number;
    /** Number of documents due soon */
    cnt_DueSoon?: number;
    /** Number of days tile due */
    DaysTillDue?: number;
    /** User has permission to create  */
    CanAdd?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ITypeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.cnt_open = _data["cnt_open"];
            this.cnt_closed = _data["cnt_closed"];
            this.cnt_overdue = _data["cnt_overdue"];
            this.cnt_DueSoon = _data["cnt_DueSoon"];
            this.DaysTillDue = _data["DaysTillDue"];
            this.CanAdd = _data["CanAdd"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): TypeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new TypeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["cnt_open"] = this.cnt_open;
        data["cnt_closed"] = this.cnt_closed;
        data["cnt_overdue"] = this.cnt_overdue;
        data["cnt_DueSoon"] = this.cnt_DueSoon;
        data["DaysTillDue"] = this.DaysTillDue;
        data["CanAdd"] = this.CanAdd;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): TypeSummary {
        const json = this.toJSON();
        let result = new TypeSummary();
        result.init(json);
        return result;
    }
}

/** Summary of Project Process (Document) types */
export interface ITypeSummary {
    /** Key for Process Type */
    DocTypeKey: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open?: number;
    /** Number of documents closed */
    cnt_closed?: number;
    /** Number of documents overdue */
    cnt_overdue?: number;
    /** Number of documents due soon */
    cnt_DueSoon?: number;
    /** Number of days tile due */
    DaysTillDue?: number;
    /** User has permission to create  */
    CanAdd?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Process Document on a Project */
export class ProjectDocsOfType implements IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey!: string;
    /** Type of Process */
    DocTypeKey?: string;
    /** Key to Process Reference */
    DocReference?: string;
    /** Document Date (header) */
    DocDate?: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority?: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential?: boolean;
    /** Key to Contact document was "from") */
    FromUser?: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** (Read only) Resolved name of Responsible Party */
    ResponsibleParty_dv?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty?: string;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company?: string;
    /** Resolved Company Name  of the source Contact  */
    Company_dv?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** When the document/process is due */
    Due?: Date | undefined;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Specification */
    Specification?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved Subtype description */
    Subtype_dv?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact?: number;
    /** Custom Amount */
    csAmount?: number;
    /** Bond */
    Bond?: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** (read only) Display Value for contact named as source
             */
    SourceContact_dv?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact?: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq?: number;
    /** Number of stages of routing  */
    MaxStage?: number;
    /** How many files are attached */
    FilesAttached?: number;
    /** (read only) Display Value for user that last changed status
             */
    LastStatusBy_dv?: string | undefined;
    /** Key of User that last changed document status */
    LastStatusBy?: string;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectDocsOfType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.Title = _data["Title"];
            this.Priority = _data["Priority"];
            this.Confidential = _data["Confidential"];
            this.FromUser = _data["FromUser"];
            this.SortFrom = _data["SortFrom"];
            this.ResponsibleParty_dv = _data["ResponsibleParty_dv"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.Company = _data["Company"];
            this.Company_dv = _data["Company_dv"];
            this.ToUser = _data["ToUser"];
            this.SortTo = _data["SortTo"];
            this.Author = _data["Author"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Project = _data["Project"];
            this.Specification = _data["Specification"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.Subtype = _data["Subtype"];
            this.Subtype_dv = _data["Subtype_dv"];
            this.Status = _data["Status"];
            this.CostImpact = _data["CostImpact"];
            this.csAmount = _data["csAmount"];
            this.Bond = _data["Bond"];
            this.Subsegment = _data["Subsegment"];
            this.ContractType = _data["ContractType"];
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.PayItemNumber = _data["PayItemNumber"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.SourceContact_dv = _data["SourceContact_dv"];
            this.SourceContact = _data["SourceContact"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.MaxStage = _data["MaxStage"];
            this.FilesAttached = _data["FilesAttached"];
            this.LastStatusBy_dv = _data["LastStatusBy_dv"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectDocsOfType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDocsOfType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["Title"] = this.Title;
        data["Priority"] = this.Priority;
        data["Confidential"] = this.Confidential;
        data["FromUser"] = this.FromUser;
        data["SortFrom"] = this.SortFrom;
        data["ResponsibleParty_dv"] = this.ResponsibleParty_dv;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["Company"] = this.Company;
        data["Company_dv"] = this.Company_dv;
        data["ToUser"] = this.ToUser;
        data["SortTo"] = this.SortTo;
        data["Author"] = this.Author;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Project"] = this.Project;
        data["Specification"] = this.Specification;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["Subtype"] = this.Subtype;
        data["Subtype_dv"] = this.Subtype_dv;
        data["Status"] = this.Status;
        data["CostImpact"] = this.CostImpact;
        data["csAmount"] = this.csAmount;
        data["Bond"] = this.Bond;
        data["Subsegment"] = this.Subsegment;
        data["ContractType"] = this.ContractType;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["PayItemNumber"] = this.PayItemNumber;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["SourceContact_dv"] = this.SourceContact_dv;
        data["SourceContact"] = this.SourceContact;
        data["CurrentSeq"] = this.CurrentSeq;
        data["MaxStage"] = this.MaxStage;
        data["FilesAttached"] = this.FilesAttached;
        data["LastStatusBy_dv"] = this.LastStatusBy_dv;
        data["LastStatusBy"] = this.LastStatusBy;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectDocsOfType {
        const json = this.toJSON();
        let result = new ProjectDocsOfType();
        result.init(json);
        return result;
    }
}

/** Process Document on a Project */
export interface IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey: string;
    /** Type of Process */
    DocTypeKey?: string;
    /** Key to Process Reference */
    DocReference?: string;
    /** Document Date (header) */
    DocDate?: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority?: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential?: boolean;
    /** Key to Contact document was "from") */
    FromUser?: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** (Read only) Resolved name of Responsible Party */
    ResponsibleParty_dv?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty?: string;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company?: string;
    /** Resolved Company Name  of the source Contact  */
    Company_dv?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** When the document/process is due */
    Due?: Date | undefined;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Specification */
    Specification?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved Subtype description */
    Subtype_dv?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact?: number;
    /** Custom Amount */
    csAmount?: number;
    /** Bond */
    Bond?: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** (read only) Display Value for contact named as source
             */
    SourceContact_dv?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact?: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq?: number;
    /** Number of stages of routing  */
    MaxStage?: number;
    /** How many files are attached */
    FilesAttached?: number;
    /** (read only) Display Value for user that last changed status
             */
    LastStatusBy_dv?: string | undefined;
    /** Key of User that last changed document status */
    LastStatusBy?: string;
    /** eTag */
    ETag?: string | undefined;
}

/** Details a single line in a project budget at a point in time */
export class ProjectSnapshot implements IProjectSnapshot {
    /** Key for this line */
    ForecastRowKey!: string;
    /** Key for this (ProjEntity) cost code group */
    TaskRowKey!: string;
    /** Key for this snapshot */
    DocRevKey!: string;
    /** (R)ow or (T)ask */
    RowType?: string | undefined;
    /** WB (Cost) Code including mask characters */
    ProjEntity?: string | undefined;
    /** Account  (must be unique within ProjEntity group) */
    AccountCategory?: string | undefined;
    /** Account  class (labor, burden, etc) */
    Acct_Class?: string | undefined;
    /** Account  Type (RV, EX) */
    Acct_Type?: string | undefined;
    /** sequences the accounts within each ProjEntity Group */
    Acct_Sort?: number;
    /** Optional Billing Code that specifies the roll up group for a set of ProjEntity */
    BillingCode?: string | undefined;
    /** FP, CP etc */
    CostingMethod?: string | undefined;
    /** Y or N */
    Projected?: string | undefined;
    /** forecasting threshold,  0 to 1; typically 0.15 */
    Threshold?: number;
    /** EAC Revenue */
    BudgetedRevenue?: number;
    /** original revenue */
    OriginalRevenue?: number;
    /** EAC Cost */
    CurrentBudget?: number;
    /** Original Budget for Cost */
    OriginalBudget?: number;
    /** Typically current-original */
    BudgetRevision?: number;
    /** EAC Approved CO */
    ApprovedCO?: number;
    /** CO that are still not pending (see rules) */
    VerbalCO?: number;
    /** CO costs that are pending but not approved */
    PendingCO?: number;
    /** CO Revenue */
    ApprovedCORevenue?: number;
    /** CO revenue that is pending */
    PendingCORevenue?: number;
    /** Prior FAC revenue (kin to CurrentBudget) */
    PriorFACRevenue?: number;
    /** Original Units */
    OriginalUnits?: number;
    /** Change in  Units */
    RevisionUnits?: number;
    /** Units to Date  */
    ActualUnits?: number;
    /** Cost to date */
    ActualToDate?: number;
    /** Open commitment amount; similar to remaining to pay but as reported by accounting peer */
    CommittedToDate?: number;
    /** Actual costs in the prior fiscal year */
    ActualPY?: number;
    /** Actual costs in the prior fiscal period */
    ActualPP?: number;
    /** Actual costs in the current fiscal year */
    ActualCY?: number;
    /** Actual costs in the current fiscal period */
    ActualCP?: number;
    /** Actual units in the prior fiscal year */
    ActualUnitsPY?: number;
    /** Actual units in the prior fiscal period */
    ActualUnitsPP?: number;
    /** Actual units in the current fiscal year */
    ActualUnitsCY?: number;
    /** Actual units in the current fiscal period */
    ActualUnitsCP?: number;
    /** charges */
    ChargesToDate?: number;
    /** open work order amount */
    OpenWO?: number;
    /** completed work order */
    CompletedWO?: number;
    /** open work order units */
    OpenWOUnits?: number;
    /** completed work order units */
    CompletedWOUnits?: number;
    /** Name of vendor after buyout or "Multiple" */
    VendorName?: string | undefined;
    /** Original Subcontract Amount  */
    OriginalSC?: number;
    /** approved subcontract CO amount */
    ApprovedSCO?: number;
    /** pending subcontact changes */
    PendingSCO?: number;
    /** subcontact changes that are not yet pending (see probability rules) */
    PotentialSCO?: number;
    /** Subcontract Retention */
    SCPayReqRetention?: number;
    /** Subcontract amount approved as completed/paid */
    SCPayReqTotal?: number;
    /** Subcontract amount paid */
    SCPayReqPaid?: number;
    /** Subcontract amount held in retention */
    SCPPRRetention?: number;
    /** Subcontract amount pending approval for payment */
    PendingPayAmount?: number;
    /** Similar to open commitment this is (OriginalSC + ApprovedSCO) - SCPayReqTotal */
    SCRemainingPay?: number;
    /** FAC - Actual */
    PriorFTC?: number;
    /** Previously established percent complete */
    PriorPercentComplete?: number;
    /** Prior FAC revenue (kin to CurrentBudget) */
    PriorFAC?: number;
    /** Prior FAC units   */
    PriorFACUnits?: number;
    /** Amount billed */
    BTDRevenue?: number;
    /** Number of accounts in this ProjEntity group */
    ChildCnt?: number;
    /** Date */
    LastPosting?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Unit of Measure (SF, EA, etc) */
    UOM?: string | undefined;
    /** Description */
    Notes?: string | undefined;
    /** Description */
    TrackingNotes?: string | undefined;
    /** Description */
    czUDSAmt1?: number;
    /** Description */
    czUDSAmt2?: number;
    /** Description */
    czUDSAmt3?: number;
    /** Description */
    czUDSText1?: string | undefined;
    /** Description */
    czUDSText2?: string | undefined;
    /** manually specified completed units */
    DeclaredUnits?: number;
    /** manually specified percent complete */
    DeclaredPercentComplete?: number;
    /** for internal use */
    ChangeFACorFTC?: number;
    /** for internal use */
    ChangePercentComplete?: number;
    /** for internal use */
    ChangeTaskProductionUnits?: number;
    /** for internal use */
    ChangeAmount?: number;
    /** for internal use */
    ChangeProductionRate?: number;
    /** for internal use */
    ChangeAccountProductionUnits?: number;
    /** for internal use */
    ChangeDollarsPerUnit?: number;
    /** for internal use */
    ChangeHrsPerUnit?: number;
    /** for internal use */
    ChangeUnitsPerHr?: number;
    /** for internal use */
    ChangeProductivityFactor?: number;
    /** for internal use */
    ChangeWorkingFAC?: number;
    /** for internal use */
    ChangeWorkingFACUnits?: number;
    /** for internal use */
    ChangeWorkingPercentComplete?: number;
    /** for internal use */
    ChangeWorkingAmountGL?: number;
    /** for internal use */
    ChangeWorkingProdUnitGL?: number;
    /** for internal use */
    ChangeWorkingUnitGL?: number;
    /** for internal use */
    ChangeBudgetType?: number;
    /** for internal use */
    ChangeBudgetAmount?: number;
    /** for internal use */
    ChangeBudgetUnit?: number;
    /** for internal use */
    ChangeByUserKey?: string | undefined;
    /** for internal use */
    PriorChangeKey?: string | undefined;
    /** for internal use */
    PriorBudgetChangeKey?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectSnapshot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ForecastRowKey = _data["ForecastRowKey"];
            this.TaskRowKey = _data["TaskRowKey"];
            this.DocRevKey = _data["DocRevKey"];
            this.RowType = _data["RowType"];
            this.ProjEntity = _data["ProjEntity"];
            this.AccountCategory = _data["AccountCategory"];
            this.Acct_Class = _data["Acct_Class"];
            this.Acct_Type = _data["Acct_Type"];
            this.Acct_Sort = _data["Acct_Sort"];
            this.BillingCode = _data["BillingCode"];
            this.CostingMethod = _data["CostingMethod"];
            this.Projected = _data["Projected"];
            this.Threshold = _data["Threshold"];
            this.BudgetedRevenue = _data["BudgetedRevenue"];
            this.OriginalRevenue = _data["OriginalRevenue"];
            this.CurrentBudget = _data["CurrentBudget"];
            this.OriginalBudget = _data["OriginalBudget"];
            this.BudgetRevision = _data["BudgetRevision"];
            this.ApprovedCO = _data["ApprovedCO"];
            this.VerbalCO = _data["VerbalCO"];
            this.PendingCO = _data["PendingCO"];
            this.ApprovedCORevenue = _data["ApprovedCORevenue"];
            this.PendingCORevenue = _data["PendingCORevenue"];
            this.PriorFACRevenue = _data["PriorFACRevenue"];
            this.OriginalUnits = _data["OriginalUnits"];
            this.RevisionUnits = _data["RevisionUnits"];
            this.ActualUnits = _data["ActualUnits"];
            this.ActualToDate = _data["ActualToDate"];
            this.CommittedToDate = _data["CommittedToDate"];
            this.ActualPY = _data["ActualPY"];
            this.ActualPP = _data["ActualPP"];
            this.ActualCY = _data["ActualCY"];
            this.ActualCP = _data["ActualCP"];
            this.ActualUnitsPY = _data["ActualUnitsPY"];
            this.ActualUnitsPP = _data["ActualUnitsPP"];
            this.ActualUnitsCY = _data["ActualUnitsCY"];
            this.ActualUnitsCP = _data["ActualUnitsCP"];
            this.ChargesToDate = _data["ChargesToDate"];
            this.OpenWO = _data["OpenWO"];
            this.CompletedWO = _data["CompletedWO"];
            this.OpenWOUnits = _data["OpenWOUnits"];
            this.CompletedWOUnits = _data["CompletedWOUnits"];
            this.VendorName = _data["VendorName"];
            this.OriginalSC = _data["OriginalSC"];
            this.ApprovedSCO = _data["ApprovedSCO"];
            this.PendingSCO = _data["PendingSCO"];
            this.PotentialSCO = _data["PotentialSCO"];
            this.SCPayReqRetention = _data["SCPayReqRetention"];
            this.SCPayReqTotal = _data["SCPayReqTotal"];
            this.SCPayReqPaid = _data["SCPayReqPaid"];
            this.SCPPRRetention = _data["SCPPRRetention"];
            this.PendingPayAmount = _data["PendingPayAmount"];
            this.SCRemainingPay = _data["SCRemainingPay"];
            this.PriorFTC = _data["PriorFTC"];
            this.PriorPercentComplete = _data["PriorPercentComplete"];
            this.PriorFAC = _data["PriorFAC"];
            this.PriorFACUnits = _data["PriorFACUnits"];
            this.BTDRevenue = _data["BTDRevenue"];
            this.ChildCnt = _data["ChildCnt"];
            this.LastPosting = _data["LastPosting"];
            this.Description = _data["Description"];
            this.UOM = _data["UOM"];
            this.Notes = _data["Notes"];
            this.TrackingNotes = _data["TrackingNotes"];
            this.czUDSAmt1 = _data["czUDSAmt1"];
            this.czUDSAmt2 = _data["czUDSAmt2"];
            this.czUDSAmt3 = _data["czUDSAmt3"];
            this.czUDSText1 = _data["czUDSText1"];
            this.czUDSText2 = _data["czUDSText2"];
            this.DeclaredUnits = _data["DeclaredUnits"];
            this.DeclaredPercentComplete = _data["DeclaredPercentComplete"];
            this.ChangeFACorFTC = _data["ChangeFACorFTC"];
            this.ChangePercentComplete = _data["ChangePercentComplete"];
            this.ChangeTaskProductionUnits = _data["ChangeTaskProductionUnits"];
            this.ChangeAmount = _data["ChangeAmount"];
            this.ChangeProductionRate = _data["ChangeProductionRate"];
            this.ChangeAccountProductionUnits = _data["ChangeAccountProductionUnits"];
            this.ChangeDollarsPerUnit = _data["ChangeDollarsPerUnit"];
            this.ChangeHrsPerUnit = _data["ChangeHrsPerUnit"];
            this.ChangeUnitsPerHr = _data["ChangeUnitsPerHr"];
            this.ChangeProductivityFactor = _data["ChangeProductivityFactor"];
            this.ChangeWorkingFAC = _data["ChangeWorkingFAC"];
            this.ChangeWorkingFACUnits = _data["ChangeWorkingFACUnits"];
            this.ChangeWorkingPercentComplete = _data["ChangeWorkingPercentComplete"];
            this.ChangeWorkingAmountGL = _data["ChangeWorkingAmountGL"];
            this.ChangeWorkingProdUnitGL = _data["ChangeWorkingProdUnitGL"];
            this.ChangeWorkingUnitGL = _data["ChangeWorkingUnitGL"];
            this.ChangeBudgetType = _data["ChangeBudgetType"];
            this.ChangeBudgetAmount = _data["ChangeBudgetAmount"];
            this.ChangeBudgetUnit = _data["ChangeBudgetUnit"];
            this.ChangeByUserKey = _data["ChangeByUserKey"];
            this.PriorChangeKey = _data["PriorChangeKey"];
            this.PriorBudgetChangeKey = _data["PriorBudgetChangeKey"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectSnapshot {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSnapshot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ForecastRowKey"] = this.ForecastRowKey;
        data["TaskRowKey"] = this.TaskRowKey;
        data["DocRevKey"] = this.DocRevKey;
        data["RowType"] = this.RowType;
        data["ProjEntity"] = this.ProjEntity;
        data["AccountCategory"] = this.AccountCategory;
        data["Acct_Class"] = this.Acct_Class;
        data["Acct_Type"] = this.Acct_Type;
        data["Acct_Sort"] = this.Acct_Sort;
        data["BillingCode"] = this.BillingCode;
        data["CostingMethod"] = this.CostingMethod;
        data["Projected"] = this.Projected;
        data["Threshold"] = this.Threshold;
        data["BudgetedRevenue"] = this.BudgetedRevenue;
        data["OriginalRevenue"] = this.OriginalRevenue;
        data["CurrentBudget"] = this.CurrentBudget;
        data["OriginalBudget"] = this.OriginalBudget;
        data["BudgetRevision"] = this.BudgetRevision;
        data["ApprovedCO"] = this.ApprovedCO;
        data["VerbalCO"] = this.VerbalCO;
        data["PendingCO"] = this.PendingCO;
        data["ApprovedCORevenue"] = this.ApprovedCORevenue;
        data["PendingCORevenue"] = this.PendingCORevenue;
        data["PriorFACRevenue"] = this.PriorFACRevenue;
        data["OriginalUnits"] = this.OriginalUnits;
        data["RevisionUnits"] = this.RevisionUnits;
        data["ActualUnits"] = this.ActualUnits;
        data["ActualToDate"] = this.ActualToDate;
        data["CommittedToDate"] = this.CommittedToDate;
        data["ActualPY"] = this.ActualPY;
        data["ActualPP"] = this.ActualPP;
        data["ActualCY"] = this.ActualCY;
        data["ActualCP"] = this.ActualCP;
        data["ActualUnitsPY"] = this.ActualUnitsPY;
        data["ActualUnitsPP"] = this.ActualUnitsPP;
        data["ActualUnitsCY"] = this.ActualUnitsCY;
        data["ActualUnitsCP"] = this.ActualUnitsCP;
        data["ChargesToDate"] = this.ChargesToDate;
        data["OpenWO"] = this.OpenWO;
        data["CompletedWO"] = this.CompletedWO;
        data["OpenWOUnits"] = this.OpenWOUnits;
        data["CompletedWOUnits"] = this.CompletedWOUnits;
        data["VendorName"] = this.VendorName;
        data["OriginalSC"] = this.OriginalSC;
        data["ApprovedSCO"] = this.ApprovedSCO;
        data["PendingSCO"] = this.PendingSCO;
        data["PotentialSCO"] = this.PotentialSCO;
        data["SCPayReqRetention"] = this.SCPayReqRetention;
        data["SCPayReqTotal"] = this.SCPayReqTotal;
        data["SCPayReqPaid"] = this.SCPayReqPaid;
        data["SCPPRRetention"] = this.SCPPRRetention;
        data["PendingPayAmount"] = this.PendingPayAmount;
        data["SCRemainingPay"] = this.SCRemainingPay;
        data["PriorFTC"] = this.PriorFTC;
        data["PriorPercentComplete"] = this.PriorPercentComplete;
        data["PriorFAC"] = this.PriorFAC;
        data["PriorFACUnits"] = this.PriorFACUnits;
        data["BTDRevenue"] = this.BTDRevenue;
        data["ChildCnt"] = this.ChildCnt;
        data["LastPosting"] = this.LastPosting;
        data["Description"] = this.Description;
        data["UOM"] = this.UOM;
        data["Notes"] = this.Notes;
        data["TrackingNotes"] = this.TrackingNotes;
        data["czUDSAmt1"] = this.czUDSAmt1;
        data["czUDSAmt2"] = this.czUDSAmt2;
        data["czUDSAmt3"] = this.czUDSAmt3;
        data["czUDSText1"] = this.czUDSText1;
        data["czUDSText2"] = this.czUDSText2;
        data["DeclaredUnits"] = this.DeclaredUnits;
        data["DeclaredPercentComplete"] = this.DeclaredPercentComplete;
        data["ChangeFACorFTC"] = this.ChangeFACorFTC;
        data["ChangePercentComplete"] = this.ChangePercentComplete;
        data["ChangeTaskProductionUnits"] = this.ChangeTaskProductionUnits;
        data["ChangeAmount"] = this.ChangeAmount;
        data["ChangeProductionRate"] = this.ChangeProductionRate;
        data["ChangeAccountProductionUnits"] = this.ChangeAccountProductionUnits;
        data["ChangeDollarsPerUnit"] = this.ChangeDollarsPerUnit;
        data["ChangeHrsPerUnit"] = this.ChangeHrsPerUnit;
        data["ChangeUnitsPerHr"] = this.ChangeUnitsPerHr;
        data["ChangeProductivityFactor"] = this.ChangeProductivityFactor;
        data["ChangeWorkingFAC"] = this.ChangeWorkingFAC;
        data["ChangeWorkingFACUnits"] = this.ChangeWorkingFACUnits;
        data["ChangeWorkingPercentComplete"] = this.ChangeWorkingPercentComplete;
        data["ChangeWorkingAmountGL"] = this.ChangeWorkingAmountGL;
        data["ChangeWorkingProdUnitGL"] = this.ChangeWorkingProdUnitGL;
        data["ChangeWorkingUnitGL"] = this.ChangeWorkingUnitGL;
        data["ChangeBudgetType"] = this.ChangeBudgetType;
        data["ChangeBudgetAmount"] = this.ChangeBudgetAmount;
        data["ChangeBudgetUnit"] = this.ChangeBudgetUnit;
        data["ChangeByUserKey"] = this.ChangeByUserKey;
        data["PriorChangeKey"] = this.PriorChangeKey;
        data["PriorBudgetChangeKey"] = this.PriorBudgetChangeKey;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectSnapshot {
        const json = this.toJSON();
        let result = new ProjectSnapshot();
        result.init(json);
        return result;
    }
}

/** Details a single line in a project budget at a point in time */
export interface IProjectSnapshot {
    /** Key for this line */
    ForecastRowKey: string;
    /** Key for this (ProjEntity) cost code group */
    TaskRowKey: string;
    /** Key for this snapshot */
    DocRevKey: string;
    /** (R)ow or (T)ask */
    RowType?: string | undefined;
    /** WB (Cost) Code including mask characters */
    ProjEntity?: string | undefined;
    /** Account  (must be unique within ProjEntity group) */
    AccountCategory?: string | undefined;
    /** Account  class (labor, burden, etc) */
    Acct_Class?: string | undefined;
    /** Account  Type (RV, EX) */
    Acct_Type?: string | undefined;
    /** sequences the accounts within each ProjEntity Group */
    Acct_Sort?: number;
    /** Optional Billing Code that specifies the roll up group for a set of ProjEntity */
    BillingCode?: string | undefined;
    /** FP, CP etc */
    CostingMethod?: string | undefined;
    /** Y or N */
    Projected?: string | undefined;
    /** forecasting threshold,  0 to 1; typically 0.15 */
    Threshold?: number;
    /** EAC Revenue */
    BudgetedRevenue?: number;
    /** original revenue */
    OriginalRevenue?: number;
    /** EAC Cost */
    CurrentBudget?: number;
    /** Original Budget for Cost */
    OriginalBudget?: number;
    /** Typically current-original */
    BudgetRevision?: number;
    /** EAC Approved CO */
    ApprovedCO?: number;
    /** CO that are still not pending (see rules) */
    VerbalCO?: number;
    /** CO costs that are pending but not approved */
    PendingCO?: number;
    /** CO Revenue */
    ApprovedCORevenue?: number;
    /** CO revenue that is pending */
    PendingCORevenue?: number;
    /** Prior FAC revenue (kin to CurrentBudget) */
    PriorFACRevenue?: number;
    /** Original Units */
    OriginalUnits?: number;
    /** Change in  Units */
    RevisionUnits?: number;
    /** Units to Date  */
    ActualUnits?: number;
    /** Cost to date */
    ActualToDate?: number;
    /** Open commitment amount; similar to remaining to pay but as reported by accounting peer */
    CommittedToDate?: number;
    /** Actual costs in the prior fiscal year */
    ActualPY?: number;
    /** Actual costs in the prior fiscal period */
    ActualPP?: number;
    /** Actual costs in the current fiscal year */
    ActualCY?: number;
    /** Actual costs in the current fiscal period */
    ActualCP?: number;
    /** Actual units in the prior fiscal year */
    ActualUnitsPY?: number;
    /** Actual units in the prior fiscal period */
    ActualUnitsPP?: number;
    /** Actual units in the current fiscal year */
    ActualUnitsCY?: number;
    /** Actual units in the current fiscal period */
    ActualUnitsCP?: number;
    /** charges */
    ChargesToDate?: number;
    /** open work order amount */
    OpenWO?: number;
    /** completed work order */
    CompletedWO?: number;
    /** open work order units */
    OpenWOUnits?: number;
    /** completed work order units */
    CompletedWOUnits?: number;
    /** Name of vendor after buyout or "Multiple" */
    VendorName?: string | undefined;
    /** Original Subcontract Amount  */
    OriginalSC?: number;
    /** approved subcontract CO amount */
    ApprovedSCO?: number;
    /** pending subcontact changes */
    PendingSCO?: number;
    /** subcontact changes that are not yet pending (see probability rules) */
    PotentialSCO?: number;
    /** Subcontract Retention */
    SCPayReqRetention?: number;
    /** Subcontract amount approved as completed/paid */
    SCPayReqTotal?: number;
    /** Subcontract amount paid */
    SCPayReqPaid?: number;
    /** Subcontract amount held in retention */
    SCPPRRetention?: number;
    /** Subcontract amount pending approval for payment */
    PendingPayAmount?: number;
    /** Similar to open commitment this is (OriginalSC + ApprovedSCO) - SCPayReqTotal */
    SCRemainingPay?: number;
    /** FAC - Actual */
    PriorFTC?: number;
    /** Previously established percent complete */
    PriorPercentComplete?: number;
    /** Prior FAC revenue (kin to CurrentBudget) */
    PriorFAC?: number;
    /** Prior FAC units   */
    PriorFACUnits?: number;
    /** Amount billed */
    BTDRevenue?: number;
    /** Number of accounts in this ProjEntity group */
    ChildCnt?: number;
    /** Date */
    LastPosting?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Unit of Measure (SF, EA, etc) */
    UOM?: string | undefined;
    /** Description */
    Notes?: string | undefined;
    /** Description */
    TrackingNotes?: string | undefined;
    /** Description */
    czUDSAmt1?: number;
    /** Description */
    czUDSAmt2?: number;
    /** Description */
    czUDSAmt3?: number;
    /** Description */
    czUDSText1?: string | undefined;
    /** Description */
    czUDSText2?: string | undefined;
    /** manually specified completed units */
    DeclaredUnits?: number;
    /** manually specified percent complete */
    DeclaredPercentComplete?: number;
    /** for internal use */
    ChangeFACorFTC?: number;
    /** for internal use */
    ChangePercentComplete?: number;
    /** for internal use */
    ChangeTaskProductionUnits?: number;
    /** for internal use */
    ChangeAmount?: number;
    /** for internal use */
    ChangeProductionRate?: number;
    /** for internal use */
    ChangeAccountProductionUnits?: number;
    /** for internal use */
    ChangeDollarsPerUnit?: number;
    /** for internal use */
    ChangeHrsPerUnit?: number;
    /** for internal use */
    ChangeUnitsPerHr?: number;
    /** for internal use */
    ChangeProductivityFactor?: number;
    /** for internal use */
    ChangeWorkingFAC?: number;
    /** for internal use */
    ChangeWorkingFACUnits?: number;
    /** for internal use */
    ChangeWorkingPercentComplete?: number;
    /** for internal use */
    ChangeWorkingAmountGL?: number;
    /** for internal use */
    ChangeWorkingProdUnitGL?: number;
    /** for internal use */
    ChangeWorkingUnitGL?: number;
    /** for internal use */
    ChangeBudgetType?: number;
    /** for internal use */
    ChangeBudgetAmount?: number;
    /** for internal use */
    ChangeBudgetUnit?: number;
    /** for internal use */
    ChangeByUserKey?: string | undefined;
    /** for internal use */
    PriorChangeKey?: string | undefined;
    /** for internal use */
    PriorBudgetChangeKey?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Details changes to a single line in a project budget since a specific snapshot */
export class ProjectSnapshotDelta implements IProjectSnapshotDelta {
    /** WB (Cost) Code including mask characters */
    WBCode?: string | undefined;
    /** Account  (must be unique within ProjEntity group) */
    WBAcct?: string | undefined;
    /** EAC Amount posted to this line */
    PostedAmt?: number;
    /** EAC Units posted to this line */
    PostedQty?: number;
    /** EAC Amount pending to this line */
    UnpostedAmt?: number;
    /** EAC Units pending to this line */
    UnpostedQty?: number;
    /** FAC Amount posted to this line */
    FACPostedAmt?: number;
    /** FAC Units posted to this line */
    FACPostedQty?: number;
    /** FAC Amount pending to this line */
    FACUnpostedAmt?: number;
    /** FAC Units pending to this line */
    FACUnpostedQty?: number;
    /** Number of eac or fac revisions summarized here */
    RevCnt?: number;
    /** Bit mask that indicates what types of amounts are summarized: 2=EAC;4=FAC; 256=Actual to date; 512= Open Commitment */
    RevMask?: number;
    /** The DocNo of the first BR that changed this line after the reference snapshot */
    FirstDocNo?: string | undefined;
    /** new EAC amount for this line */
    TargetEAC?: number;
    /** new EAC Units for this line */
    TargetQTY?: number;
    /** new FAC amount for this line */
    TargetFAC?: number;
    /** new FAC Units for this line */
    TargetFACQTY?: number;
    /** new PTD actual amount for this line */
    TargetActual?: number;
    /** new PTD actual units for this line */
    TargetActQty?: number;
    /** new PTD open commitment amount for this line */
    TargetOpenCMT?: number;
    /** new PTD open commitment units */
    TargetCMTQty?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectSnapshotDelta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.WBCode = _data["WBCode"];
            this.WBAcct = _data["WBAcct"];
            this.PostedAmt = _data["PostedAmt"];
            this.PostedQty = _data["PostedQty"];
            this.UnpostedAmt = _data["UnpostedAmt"];
            this.UnpostedQty = _data["UnpostedQty"];
            this.FACPostedAmt = _data["FACPostedAmt"];
            this.FACPostedQty = _data["FACPostedQty"];
            this.FACUnpostedAmt = _data["FACUnpostedAmt"];
            this.FACUnpostedQty = _data["FACUnpostedQty"];
            this.RevCnt = _data["RevCnt"];
            this.RevMask = _data["RevMask"];
            this.FirstDocNo = _data["FirstDocNo"];
            this.TargetEAC = _data["TargetEAC"];
            this.TargetQTY = _data["TargetQTY"];
            this.TargetFAC = _data["TargetFAC"];
            this.TargetFACQTY = _data["TargetFACQTY"];
            this.TargetActual = _data["TargetActual"];
            this.TargetActQty = _data["TargetActQty"];
            this.TargetOpenCMT = _data["TargetOpenCMT"];
            this.TargetCMTQty = _data["TargetCMTQty"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectSnapshotDelta {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSnapshotDelta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["WBCode"] = this.WBCode;
        data["WBAcct"] = this.WBAcct;
        data["PostedAmt"] = this.PostedAmt;
        data["PostedQty"] = this.PostedQty;
        data["UnpostedAmt"] = this.UnpostedAmt;
        data["UnpostedQty"] = this.UnpostedQty;
        data["FACPostedAmt"] = this.FACPostedAmt;
        data["FACPostedQty"] = this.FACPostedQty;
        data["FACUnpostedAmt"] = this.FACUnpostedAmt;
        data["FACUnpostedQty"] = this.FACUnpostedQty;
        data["RevCnt"] = this.RevCnt;
        data["RevMask"] = this.RevMask;
        data["FirstDocNo"] = this.FirstDocNo;
        data["TargetEAC"] = this.TargetEAC;
        data["TargetQTY"] = this.TargetQTY;
        data["TargetFAC"] = this.TargetFAC;
        data["TargetFACQTY"] = this.TargetFACQTY;
        data["TargetActual"] = this.TargetActual;
        data["TargetActQty"] = this.TargetActQty;
        data["TargetOpenCMT"] = this.TargetOpenCMT;
        data["TargetCMTQty"] = this.TargetCMTQty;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectSnapshotDelta {
        const json = this.toJSON();
        let result = new ProjectSnapshotDelta();
        result.init(json);
        return result;
    }
}

/** Details changes to a single line in a project budget since a specific snapshot */
export interface IProjectSnapshotDelta {
    /** WB (Cost) Code including mask characters */
    WBCode?: string | undefined;
    /** Account  (must be unique within ProjEntity group) */
    WBAcct?: string | undefined;
    /** EAC Amount posted to this line */
    PostedAmt?: number;
    /** EAC Units posted to this line */
    PostedQty?: number;
    /** EAC Amount pending to this line */
    UnpostedAmt?: number;
    /** EAC Units pending to this line */
    UnpostedQty?: number;
    /** FAC Amount posted to this line */
    FACPostedAmt?: number;
    /** FAC Units posted to this line */
    FACPostedQty?: number;
    /** FAC Amount pending to this line */
    FACUnpostedAmt?: number;
    /** FAC Units pending to this line */
    FACUnpostedQty?: number;
    /** Number of eac or fac revisions summarized here */
    RevCnt?: number;
    /** Bit mask that indicates what types of amounts are summarized: 2=EAC;4=FAC; 256=Actual to date; 512= Open Commitment */
    RevMask?: number;
    /** The DocNo of the first BR that changed this line after the reference snapshot */
    FirstDocNo?: string | undefined;
    /** new EAC amount for this line */
    TargetEAC?: number;
    /** new EAC Units for this line */
    TargetQTY?: number;
    /** new FAC amount for this line */
    TargetFAC?: number;
    /** new FAC Units for this line */
    TargetFACQTY?: number;
    /** new PTD actual amount for this line */
    TargetActual?: number;
    /** new PTD actual units for this line */
    TargetActQty?: number;
    /** new PTD open commitment amount for this line */
    TargetOpenCMT?: number;
    /** new PTD open commitment units */
    TargetCMTQty?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** General abstract information about a BFA document */
export class BFAAbstract implements IBFAAbstract {
    /** Project ID */
    Project!: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** PA, BU, FC */
    BFAMode!: string;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** For example 0TSK and its valid choices */
    SegmentLookups?: { [key: string]: { [key: string]: string; }; } | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Default for projected (Y/N)  */
    ProjectedDefault?: string | undefined;
    /** Default for forecast threshold */
    ForecastThreshold?: number;
    /** Default Cost Code Description */
    DefaultWBCodeDescription?: string | undefined;
    /** Count of Documents Matching this BFA mode */
    DocumentCount?: number;
    /** Count of Approved Documents matching this BFA mode */
    ApprovedCount?: number;
    /** UpdateMask */
    UpdateMask?: number;
    /** UpdateFlag (L if UpdateMask has bits 1 and 2; U otherwise) */
    UpdateFlag?: string;
    /** Doc Type Key for budget or forecast; See BudgetConfig | UDSSourceMode  */
    UDSSourceMode?: string | undefined;
    /** When true, BFA uses third group level; See BudgetConfig | Show3Groups */
    ShowThreeGroups?: boolean;
    /** When greater than zero, bit flags for each segment (1,2,4,8,16,32) */
    WBSRelaxValidation?: number;
    /** key of latest document matching this BFA mode */
    LatestDocumentKey?: string;
    /** Contract Value */
    ContractValue?: number;
    /** Revenue */
    Revenue?: number;
    /** Original Expense Budget Amount */
    OriginalExpenseBudget?: number;
    /** EAC budget amount */
    EACExpenseBudget?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IBFAAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.BFAMode = _data["BFAMode"];
            this.SubtypeDescription = _data["SubtypeDescription"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.ProjectIDMask = _data["ProjectIDMask"];
            this.WBCodeMask = _data["WBCodeMask"];
            this.ProjectSegmentSeparator = _data["ProjectSegmentSeparator"];
            this.WBCodeSegmentSeparator = _data["WBCodeSegmentSeparator"];
            this.FiscalPeriodThisDocument = _data["FiscalPeriodThisDocument"];
            this.FiscalPeriodCurrent = _data["FiscalPeriodCurrent"];
            if (_data["SegmentLookups"]) {
                this.SegmentLookups = {} as any;
                for (let key in _data["SegmentLookups"]) {
                    if (_data["SegmentLookups"].hasOwnProperty(key))
                        (<any>this.SegmentLookups)![key] = _data["SegmentLookups"][key] !== undefined ? _data["SegmentLookups"][key] : {};
                }
            }
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        (<any>this.OtherProperties)![key] = _data["OtherProperties"][key];
                }
            }
            this.ProjectedDefault = _data["ProjectedDefault"];
            this.ForecastThreshold = _data["ForecastThreshold"];
            this.DefaultWBCodeDescription = _data["DefaultWBCodeDescription"];
            this.DocumentCount = _data["DocumentCount"];
            this.ApprovedCount = _data["ApprovedCount"];
            this.UpdateMask = _data["UpdateMask"];
            this.UpdateFlag = _data["UpdateFlag"];
            this.UDSSourceMode = _data["UDSSourceMode"];
            this.ShowThreeGroups = _data["ShowThreeGroups"];
            this.WBSRelaxValidation = _data["WBSRelaxValidation"];
            this.LatestDocumentKey = _data["LatestDocumentKey"];
            this.ContractValue = _data["ContractValue"];
            this.Revenue = _data["Revenue"];
            this.OriginalExpenseBudget = _data["OriginalExpenseBudget"];
            this.EACExpenseBudget = _data["EACExpenseBudget"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): BFAAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new BFAAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["BFAMode"] = this.BFAMode;
        data["SubtypeDescription"] = this.SubtypeDescription;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["ProjectIDMask"] = this.ProjectIDMask;
        data["WBCodeMask"] = this.WBCodeMask;
        data["ProjectSegmentSeparator"] = this.ProjectSegmentSeparator;
        data["WBCodeSegmentSeparator"] = this.WBCodeSegmentSeparator;
        data["FiscalPeriodThisDocument"] = this.FiscalPeriodThisDocument;
        data["FiscalPeriodCurrent"] = this.FiscalPeriodCurrent;
        if (this.SegmentLookups) {
            data["SegmentLookups"] = {};
            for (let key in this.SegmentLookups) {
                if (this.SegmentLookups.hasOwnProperty(key))
                    (<any>data["SegmentLookups"])[key] = (<any>this.SegmentLookups)[key];
            }
        }
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    (<any>data["OtherProperties"])[key] = (<any>this.OtherProperties)[key];
            }
        }
        data["ProjectedDefault"] = this.ProjectedDefault;
        data["ForecastThreshold"] = this.ForecastThreshold;
        data["DefaultWBCodeDescription"] = this.DefaultWBCodeDescription;
        data["DocumentCount"] = this.DocumentCount;
        data["ApprovedCount"] = this.ApprovedCount;
        data["UpdateMask"] = this.UpdateMask;
        data["UpdateFlag"] = this.UpdateFlag;
        data["UDSSourceMode"] = this.UDSSourceMode;
        data["ShowThreeGroups"] = this.ShowThreeGroups;
        data["WBSRelaxValidation"] = this.WBSRelaxValidation;
        data["LatestDocumentKey"] = this.LatestDocumentKey;
        data["ContractValue"] = this.ContractValue;
        data["Revenue"] = this.Revenue;
        data["OriginalExpenseBudget"] = this.OriginalExpenseBudget;
        data["EACExpenseBudget"] = this.EACExpenseBudget;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): BFAAbstract {
        const json = this.toJSON();
        let result = new BFAAbstract();
        result.init(json);
        return result;
    }
}

/** General abstract information about a BFA document */
export interface IBFAAbstract {
    /** Project ID */
    Project: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** PA, BU, FC */
    BFAMode: string;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** For example 0TSK and its valid choices */
    SegmentLookups?: { [key: string]: { [key: string]: string; }; } | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Default for projected (Y/N)  */
    ProjectedDefault?: string | undefined;
    /** Default for forecast threshold */
    ForecastThreshold?: number;
    /** Default Cost Code Description */
    DefaultWBCodeDescription?: string | undefined;
    /** Count of Documents Matching this BFA mode */
    DocumentCount?: number;
    /** Count of Approved Documents matching this BFA mode */
    ApprovedCount?: number;
    /** UpdateMask */
    UpdateMask?: number;
    /** UpdateFlag (L if UpdateMask has bits 1 and 2; U otherwise) */
    UpdateFlag?: string;
    /** Doc Type Key for budget or forecast; See BudgetConfig | UDSSourceMode  */
    UDSSourceMode?: string | undefined;
    /** When true, BFA uses third group level; See BudgetConfig | Show3Groups */
    ShowThreeGroups?: boolean;
    /** When greater than zero, bit flags for each segment (1,2,4,8,16,32) */
    WBSRelaxValidation?: number;
    /** key of latest document matching this BFA mode */
    LatestDocumentKey?: string;
    /** Contract Value */
    ContractValue?: number;
    /** Revenue */
    Revenue?: number;
    /** Original Expense Budget Amount */
    OriginalExpenseBudget?: number;
    /** EAC budget amount */
    EACExpenseBudget?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** General abstract information about an SOV document */
export class SOVAbstract implements ISOVAbstract {
    /** Project ID */
    Project!: string;
    /** Various Project Attributes  */
    ProjectDetails?: ProjectAbstract | undefined;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** returns true if units are enabled by SOVCONFIG | SOVWithUnits for this subtype */
    DisplayUnits?: boolean;
    /** returns true if original line value tracking is enabled by SOVCONFIG | TrackOriginal for this subtype */
    TrackOriginalSOV?: boolean;
    /** returns true if multiple SOV chains are enabled by SOVCONFIG | SOVPlural for this subtype */
    SOVPlural?: boolean;
    /** returns true if GL is Account Category is enabled by SOVCONFIG | RevenueAccountByBillingCode for this subtype */
    SOVGLAccNbrFromBC?: boolean;
    /** returns true if AllowPostToAnyPeriod is enabled by BudgetConfig | AllowPriorPeriods   */
    AllowPostToAnyPeriod?: boolean;
    /** returns true if AllowPostToAnyPeriod is enabled by SOVCONFIG | BFCL-Enabled for this subtype */
    CommitmentAutoFill?: boolean;
    /** returns true if tax retention when released is enabled by SOVCONFIG | TaxRetentionWhenReleased for this subtype */
    TaxRetentionWhenReleased?: boolean;
    /** returns true if tax retention when released is enabled by SOVCONFIG | SOVCOLineMerge for this subtype */
    COSOVLineMerge?: boolean;
    /** returns true if Project Setup can have zero item is enabled by ProjectConfig | AllowNoItems   */
    ProjectSetupCommitWithoutItems?: boolean;
    /** Source Number field from Project Setup */
    ProjectSourceDocNO?: string | undefined;
    /** Alias for DMK for Project Setup document */
    ProjectDocMasterKey?: string;
    /** Alias for ProjectDetails.DocState */
    DocState?: string | undefined;
    /** Alias for ProjectDetails.Subtype */
    ProjectSubtype?: string | undefined;
    /** Alias for ProjectDetails.ProjectTitle (from project setup) */
    ProjectName?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectID?: string | undefined;
    /** Alias for ProjectDetails.ProjectFinishDate  */
    ProjectFinishDate?: Date | undefined;
    /** Alias for ProjectDetails.ProjectFinishDate  */
    ProjectStartDate?: Date | undefined;
    /** Returns true if this project is connected to an XTS peer */
    ProjectIntegrationIsXTS?: boolean;
    /** returns same as DV("ProjectSignOff", projectid, Nothing) */
    ProjectSignOff?: Date | undefined;
    /** returns same as DV("ProjectPayNumber", projectid, Nothing) */
    ProjectContractFor?: string | undefined;
    /** This value is never set */
    ProjectContractDate?: Date | undefined;
    /** returns same as DV("ProjectParent", projectid, Nothing) */
    ParentProjectNumber?: string | undefined;
    /** returns title of Parent Project (see ParentProjectNumber) */
    ParentProjectName?: string | undefined;
    /** Customer ID, alias for From Project Setup Source Contact */
    ProjectCustomer?: string | undefined;
    /** Name of Responsible Party contact from Project Setup  */
    BillerName?: string | undefined;
    /** Returns any available peer AR Bill Information  */
    BillInfo?: string | undefined;
    /** Returns CWRetention from Project Setup like dv("ProjectCW", projectID, Nothing) */
    ProjectSetupWorkRetention?: number;
    /** Returns SMWRetention from Project Setup like dv("ProjectSM", projectID, Nothing) */
    ProjectSetupMaterialRetention?: number;
    /** Returns TaxID from Project Setup  like dv("ProjectTaxID",projectid,nothing) */
    ProjectSetupTaxID?: string | undefined;
    /** Returns TaxRate from Project Setup like dv("ProjectTaxRate", projectID, Nothing) */
    ProjectSetupTaxRate?: number;
    /** Returns TaxRate from tax rate table based on tax id from Project Setup like dv("TaxRate", tax-id, Nothing) */
    TheTableRate?: number;
    /** Returns description of Owner Direct Account Category ???  */
    InitialOwnerDirectPayDescription?: string | undefined;
    /** Returns description Highest line number of this SOV */
    HighPreviousLineNo?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisSOV?: string | undefined;
    /** The max percent a line can be billed (SOVConfig | MaxPercent) */
    MaxPercentage?: number;
    /** SOVConfig | RevenueWBCode for this project subtype */
    InitialRevenueEntity?: string | undefined;
    /** SOVConfig | RevenueAccount for this project subtype */
    InitialAccountCategory?: string | undefined;
    /** SOVConfig | SOVExportToFB  for this project subtype */
    ExportTriggerStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ISOVAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectDetails = _data["ProjectDetails"] ? ProjectAbstract.fromJS(_data["ProjectDetails"]) : <any>undefined;
            this.SubtypeDescription = _data["SubtypeDescription"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.ProjectIDMask = _data["ProjectIDMask"];
            this.WBCodeMask = _data["WBCodeMask"];
            this.ProjectSegmentSeparator = _data["ProjectSegmentSeparator"];
            this.WBCodeSegmentSeparator = _data["WBCodeSegmentSeparator"];
            this.FiscalPeriodThisDocument = _data["FiscalPeriodThisDocument"];
            this.FiscalPeriodCurrent = _data["FiscalPeriodCurrent"];
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        (<any>this.OtherProperties)![key] = _data["OtherProperties"][key];
                }
            }
            this.DisplayUnits = _data["DisplayUnits"];
            this.TrackOriginalSOV = _data["TrackOriginalSOV"];
            this.SOVPlural = _data["SOVPlural"];
            this.SOVGLAccNbrFromBC = _data["SOVGLAccNbrFromBC"];
            this.AllowPostToAnyPeriod = _data["AllowPostToAnyPeriod"];
            this.CommitmentAutoFill = _data["CommitmentAutoFill"];
            this.TaxRetentionWhenReleased = _data["TaxRetentionWhenReleased"];
            this.COSOVLineMerge = _data["COSOVLineMerge"];
            this.ProjectSetupCommitWithoutItems = _data["ProjectSetupCommitWithoutItems"];
            this.ProjectSourceDocNO = _data["ProjectSourceDocNO"];
            this.ProjectDocMasterKey = _data["ProjectDocMasterKey"];
            this.DocState = _data["DocState"];
            this.ProjectSubtype = _data["ProjectSubtype"];
            this.ProjectName = _data["ProjectName"];
            this.ProjectID = _data["ProjectID"];
            this.ProjectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.ProjectStartDate = _data["ProjectStartDate"] ? new Date(_data["ProjectStartDate"].toString()) : <any>undefined;
            this.ProjectIntegrationIsXTS = _data["ProjectIntegrationIsXTS"];
            this.ProjectSignOff = _data["ProjectSignOff"] ? new Date(_data["ProjectSignOff"].toString()) : <any>undefined;
            this.ProjectContractFor = _data["ProjectContractFor"];
            this.ProjectContractDate = _data["ProjectContractDate"] ? new Date(_data["ProjectContractDate"].toString()) : <any>undefined;
            this.ParentProjectNumber = _data["ParentProjectNumber"];
            this.ParentProjectName = _data["ParentProjectName"];
            this.ProjectCustomer = _data["ProjectCustomer"];
            this.BillerName = _data["BillerName"];
            this.BillInfo = _data["BillInfo"];
            this.ProjectSetupWorkRetention = _data["ProjectSetupWorkRetention"];
            this.ProjectSetupMaterialRetention = _data["ProjectSetupMaterialRetention"];
            this.ProjectSetupTaxID = _data["ProjectSetupTaxID"];
            this.ProjectSetupTaxRate = _data["ProjectSetupTaxRate"];
            this.TheTableRate = _data["TheTableRate"];
            this.InitialOwnerDirectPayDescription = _data["InitialOwnerDirectPayDescription"];
            this.HighPreviousLineNo = _data["HighPreviousLineNo"];
            this.FiscalPeriodThisSOV = _data["FiscalPeriodThisSOV"];
            this.MaxPercentage = _data["MaxPercentage"];
            this.InitialRevenueEntity = _data["InitialRevenueEntity"];
            this.InitialAccountCategory = _data["InitialAccountCategory"];
            this.ExportTriggerStatus = _data["ExportTriggerStatus"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): SOVAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new SOVAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectDetails"] = this.ProjectDetails ? this.ProjectDetails.toJSON() : <any>undefined;
        data["SubtypeDescription"] = this.SubtypeDescription;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["ProjectIDMask"] = this.ProjectIDMask;
        data["WBCodeMask"] = this.WBCodeMask;
        data["ProjectSegmentSeparator"] = this.ProjectSegmentSeparator;
        data["WBCodeSegmentSeparator"] = this.WBCodeSegmentSeparator;
        data["FiscalPeriodThisDocument"] = this.FiscalPeriodThisDocument;
        data["FiscalPeriodCurrent"] = this.FiscalPeriodCurrent;
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    (<any>data["OtherProperties"])[key] = (<any>this.OtherProperties)[key];
            }
        }
        data["DisplayUnits"] = this.DisplayUnits;
        data["TrackOriginalSOV"] = this.TrackOriginalSOV;
        data["SOVPlural"] = this.SOVPlural;
        data["SOVGLAccNbrFromBC"] = this.SOVGLAccNbrFromBC;
        data["AllowPostToAnyPeriod"] = this.AllowPostToAnyPeriod;
        data["CommitmentAutoFill"] = this.CommitmentAutoFill;
        data["TaxRetentionWhenReleased"] = this.TaxRetentionWhenReleased;
        data["COSOVLineMerge"] = this.COSOVLineMerge;
        data["ProjectSetupCommitWithoutItems"] = this.ProjectSetupCommitWithoutItems;
        data["ProjectSourceDocNO"] = this.ProjectSourceDocNO;
        data["ProjectDocMasterKey"] = this.ProjectDocMasterKey;
        data["DocState"] = this.DocState;
        data["ProjectSubtype"] = this.ProjectSubtype;
        data["ProjectName"] = this.ProjectName;
        data["ProjectID"] = this.ProjectID;
        data["ProjectFinishDate"] = this.ProjectFinishDate ? this.ProjectFinishDate.toISOString() : <any>undefined;
        data["ProjectStartDate"] = this.ProjectStartDate ? this.ProjectStartDate.toISOString() : <any>undefined;
        data["ProjectIntegrationIsXTS"] = this.ProjectIntegrationIsXTS;
        data["ProjectSignOff"] = this.ProjectSignOff ? this.ProjectSignOff.toISOString() : <any>undefined;
        data["ProjectContractFor"] = this.ProjectContractFor;
        data["ProjectContractDate"] = this.ProjectContractDate ? this.ProjectContractDate.toISOString() : <any>undefined;
        data["ParentProjectNumber"] = this.ParentProjectNumber;
        data["ParentProjectName"] = this.ParentProjectName;
        data["ProjectCustomer"] = this.ProjectCustomer;
        data["BillerName"] = this.BillerName;
        data["BillInfo"] = this.BillInfo;
        data["ProjectSetupWorkRetention"] = this.ProjectSetupWorkRetention;
        data["ProjectSetupMaterialRetention"] = this.ProjectSetupMaterialRetention;
        data["ProjectSetupTaxID"] = this.ProjectSetupTaxID;
        data["ProjectSetupTaxRate"] = this.ProjectSetupTaxRate;
        data["TheTableRate"] = this.TheTableRate;
        data["InitialOwnerDirectPayDescription"] = this.InitialOwnerDirectPayDescription;
        data["HighPreviousLineNo"] = this.HighPreviousLineNo;
        data["FiscalPeriodThisSOV"] = this.FiscalPeriodThisSOV;
        data["MaxPercentage"] = this.MaxPercentage;
        data["InitialRevenueEntity"] = this.InitialRevenueEntity;
        data["InitialAccountCategory"] = this.InitialAccountCategory;
        data["ExportTriggerStatus"] = this.ExportTriggerStatus;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): SOVAbstract {
        const json = this.toJSON();
        let result = new SOVAbstract();
        result.init(json);
        return result;
    }
}

/** General abstract information about an SOV document */
export interface ISOVAbstract {
    /** Project ID */
    Project: string;
    /** Various Project Attributes  */
    ProjectDetails?: ProjectAbstract | undefined;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** returns true if units are enabled by SOVCONFIG | SOVWithUnits for this subtype */
    DisplayUnits?: boolean;
    /** returns true if original line value tracking is enabled by SOVCONFIG | TrackOriginal for this subtype */
    TrackOriginalSOV?: boolean;
    /** returns true if multiple SOV chains are enabled by SOVCONFIG | SOVPlural for this subtype */
    SOVPlural?: boolean;
    /** returns true if GL is Account Category is enabled by SOVCONFIG | RevenueAccountByBillingCode for this subtype */
    SOVGLAccNbrFromBC?: boolean;
    /** returns true if AllowPostToAnyPeriod is enabled by BudgetConfig | AllowPriorPeriods   */
    AllowPostToAnyPeriod?: boolean;
    /** returns true if AllowPostToAnyPeriod is enabled by SOVCONFIG | BFCL-Enabled for this subtype */
    CommitmentAutoFill?: boolean;
    /** returns true if tax retention when released is enabled by SOVCONFIG | TaxRetentionWhenReleased for this subtype */
    TaxRetentionWhenReleased?: boolean;
    /** returns true if tax retention when released is enabled by SOVCONFIG | SOVCOLineMerge for this subtype */
    COSOVLineMerge?: boolean;
    /** returns true if Project Setup can have zero item is enabled by ProjectConfig | AllowNoItems   */
    ProjectSetupCommitWithoutItems?: boolean;
    /** Source Number field from Project Setup */
    ProjectSourceDocNO?: string | undefined;
    /** Alias for DMK for Project Setup document */
    ProjectDocMasterKey?: string;
    /** Alias for ProjectDetails.DocState */
    DocState?: string | undefined;
    /** Alias for ProjectDetails.Subtype */
    ProjectSubtype?: string | undefined;
    /** Alias for ProjectDetails.ProjectTitle (from project setup) */
    ProjectName?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectID?: string | undefined;
    /** Alias for ProjectDetails.ProjectFinishDate  */
    ProjectFinishDate?: Date | undefined;
    /** Alias for ProjectDetails.ProjectFinishDate  */
    ProjectStartDate?: Date | undefined;
    /** Returns true if this project is connected to an XTS peer */
    ProjectIntegrationIsXTS?: boolean;
    /** returns same as DV("ProjectSignOff", projectid, Nothing) */
    ProjectSignOff?: Date | undefined;
    /** returns same as DV("ProjectPayNumber", projectid, Nothing) */
    ProjectContractFor?: string | undefined;
    /** This value is never set */
    ProjectContractDate?: Date | undefined;
    /** returns same as DV("ProjectParent", projectid, Nothing) */
    ParentProjectNumber?: string | undefined;
    /** returns title of Parent Project (see ParentProjectNumber) */
    ParentProjectName?: string | undefined;
    /** Customer ID, alias for From Project Setup Source Contact */
    ProjectCustomer?: string | undefined;
    /** Name of Responsible Party contact from Project Setup  */
    BillerName?: string | undefined;
    /** Returns any available peer AR Bill Information  */
    BillInfo?: string | undefined;
    /** Returns CWRetention from Project Setup like dv("ProjectCW", projectID, Nothing) */
    ProjectSetupWorkRetention?: number;
    /** Returns SMWRetention from Project Setup like dv("ProjectSM", projectID, Nothing) */
    ProjectSetupMaterialRetention?: number;
    /** Returns TaxID from Project Setup  like dv("ProjectTaxID",projectid,nothing) */
    ProjectSetupTaxID?: string | undefined;
    /** Returns TaxRate from Project Setup like dv("ProjectTaxRate", projectID, Nothing) */
    ProjectSetupTaxRate?: number;
    /** Returns TaxRate from tax rate table based on tax id from Project Setup like dv("TaxRate", tax-id, Nothing) */
    TheTableRate?: number;
    /** Returns description of Owner Direct Account Category ???  */
    InitialOwnerDirectPayDescription?: string | undefined;
    /** Returns description Highest line number of this SOV */
    HighPreviousLineNo?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisSOV?: string | undefined;
    /** The max percent a line can be billed (SOVConfig | MaxPercent) */
    MaxPercentage?: number;
    /** SOVConfig | RevenueWBCode for this project subtype */
    InitialRevenueEntity?: string | undefined;
    /** SOVConfig | RevenueAccount for this project subtype */
    InitialAccountCategory?: string | undefined;
    /** SOVConfig | SOVExportToFB  for this project subtype */
    ExportTriggerStatus?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** General abstract information about an Period Distribution document */
export class PeriodDistributionAbstract implements IPeriodDistributionAbstract {
    /** Project ID */
    Project!: string;
    /** Various Project Attributes  */
    ProjectDetails?: ProjectAbstract | undefined;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** returns -1 to 100 from BudgetConfig | BillingUplift */
    RevenueUpliftPercent?: number;
    /** returns -1 to 100 from BudgetConfig | ActualDistributionLag */
    ActualDistributionLagPeriods?: number;
    /** returns -11 to 11 from BudgetConfig | FiscalYearOffset */
    FiscalYearMonthOffset?: number;
    /** When true, the word Revenue is replaced by Billing  BudgetConfig | PeriodRevenueLabel */
    UseBillingLabelForRevenue?: boolean;
    /** Alias for ProjectDetails.ProjectTitle (from project setup) */
    ProjectName?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectID?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectFinishDate?: Date | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectCloseoutDate?: Date | undefined;
    /** returns same as DV("ProjectSignOff", projectid, Nothing) */
    ProjectSignOff?: Date;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IPeriodDistributionAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectDetails = _data["ProjectDetails"] ? ProjectAbstract.fromJS(_data["ProjectDetails"]) : <any>undefined;
            this.SubtypeDescription = _data["SubtypeDescription"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.ProjectIDMask = _data["ProjectIDMask"];
            this.WBCodeMask = _data["WBCodeMask"];
            this.ProjectSegmentSeparator = _data["ProjectSegmentSeparator"];
            this.WBCodeSegmentSeparator = _data["WBCodeSegmentSeparator"];
            this.FiscalPeriodThisDocument = _data["FiscalPeriodThisDocument"];
            this.FiscalPeriodCurrent = _data["FiscalPeriodCurrent"];
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        (<any>this.OtherProperties)![key] = _data["OtherProperties"][key];
                }
            }
            this.RevenueUpliftPercent = _data["RevenueUpliftPercent"];
            this.ActualDistributionLagPeriods = _data["ActualDistributionLagPeriods"];
            this.FiscalYearMonthOffset = _data["FiscalYearMonthOffset"];
            this.UseBillingLabelForRevenue = _data["UseBillingLabelForRevenue"];
            this.ProjectName = _data["ProjectName"];
            this.ProjectID = _data["ProjectID"];
            this.ProjectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.ProjectCloseoutDate = _data["ProjectCloseoutDate"] ? new Date(_data["ProjectCloseoutDate"].toString()) : <any>undefined;
            this.ProjectSignOff = _data["ProjectSignOff"] ? new Date(_data["ProjectSignOff"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): PeriodDistributionAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodDistributionAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectDetails"] = this.ProjectDetails ? this.ProjectDetails.toJSON() : <any>undefined;
        data["SubtypeDescription"] = this.SubtypeDescription;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["ProjectIDMask"] = this.ProjectIDMask;
        data["WBCodeMask"] = this.WBCodeMask;
        data["ProjectSegmentSeparator"] = this.ProjectSegmentSeparator;
        data["WBCodeSegmentSeparator"] = this.WBCodeSegmentSeparator;
        data["FiscalPeriodThisDocument"] = this.FiscalPeriodThisDocument;
        data["FiscalPeriodCurrent"] = this.FiscalPeriodCurrent;
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    (<any>data["OtherProperties"])[key] = (<any>this.OtherProperties)[key];
            }
        }
        data["RevenueUpliftPercent"] = this.RevenueUpliftPercent;
        data["ActualDistributionLagPeriods"] = this.ActualDistributionLagPeriods;
        data["FiscalYearMonthOffset"] = this.FiscalYearMonthOffset;
        data["UseBillingLabelForRevenue"] = this.UseBillingLabelForRevenue;
        data["ProjectName"] = this.ProjectName;
        data["ProjectID"] = this.ProjectID;
        data["ProjectFinishDate"] = this.ProjectFinishDate ? this.ProjectFinishDate.toISOString() : <any>undefined;
        data["ProjectCloseoutDate"] = this.ProjectCloseoutDate ? this.ProjectCloseoutDate.toISOString() : <any>undefined;
        data["ProjectSignOff"] = this.ProjectSignOff ? this.ProjectSignOff.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): PeriodDistributionAbstract {
        const json = this.toJSON();
        let result = new PeriodDistributionAbstract();
        result.init(json);
        return result;
    }
}

/** General abstract information about an Period Distribution document */
export interface IPeriodDistributionAbstract {
    /** Project ID */
    Project: string;
    /** Various Project Attributes  */
    ProjectDetails?: ProjectAbstract | undefined;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Returns fiscal period from this document  */
    FiscalPeriodThisDocument?: string | undefined;
    /** Returns current fiscal period */
    FiscalPeriodCurrent?: string | undefined;
    /** Additional Name-Value Pairs */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** returns -1 to 100 from BudgetConfig | BillingUplift */
    RevenueUpliftPercent?: number;
    /** returns -1 to 100 from BudgetConfig | ActualDistributionLag */
    ActualDistributionLagPeriods?: number;
    /** returns -11 to 11 from BudgetConfig | FiscalYearOffset */
    FiscalYearMonthOffset?: number;
    /** When true, the word Revenue is replaced by Billing  BudgetConfig | PeriodRevenueLabel */
    UseBillingLabelForRevenue?: boolean;
    /** Alias for ProjectDetails.ProjectTitle (from project setup) */
    ProjectName?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectID?: string | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectFinishDate?: Date | undefined;
    /** Alias for ProjectDetails.ProjectIDMasked  */
    ProjectCloseoutDate?: Date | undefined;
    /** returns same as DV("ProjectSignOff", projectid, Nothing) */
    ProjectSignOff?: Date;
    /** eTag */
    ETag?: string | undefined;
}

/** Information required for an export */
export class ExportRequest implements IExportRequest {
    /** Target FN (optional, no path) */
    ExportTargetFileName?: string | undefined;
    /** Key of template or empty key  */
    TemplateId?: string | undefined;
    /** Time Limit in minutes */
    TimeLimit?: number;
    /** Collection of columns to be exported */
    ColumnCFG?: UIDisplayConfigBasics[] | undefined;
    /** Specifies which rows to export.  If empty, exports all rows */
    WhichRows?: CurrentDataSummary[] | undefined;
    /** all the data  */
    Data?: any[] | undefined;

    constructor(data?: IExportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ExportTargetFileName = _data["ExportTargetFileName"];
            this.TemplateId = _data["TemplateId"];
            this.TimeLimit = _data["TimeLimit"];
            if (Array.isArray(_data["ColumnCFG"])) {
                this.ColumnCFG = [] as any;
                for (let item of _data["ColumnCFG"])
                    this.ColumnCFG!.push(UIDisplayConfigBasics.fromJS(item));
            }
            if (Array.isArray(_data["WhichRows"])) {
                this.WhichRows = [] as any;
                for (let item of _data["WhichRows"])
                    this.WhichRows!.push(CurrentDataSummary.fromJS(item));
            }
            if (Array.isArray(_data["Data"])) {
                this.Data = [] as any;
                for (let item of _data["Data"])
                    this.Data!.push(item);
            }
        }
    }

    static fromJS(data: any): ExportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ExportTargetFileName"] = this.ExportTargetFileName;
        data["TemplateId"] = this.TemplateId;
        data["TimeLimit"] = this.TimeLimit;
        if (Array.isArray(this.ColumnCFG)) {
            data["ColumnCFG"] = [];
            for (let item of this.ColumnCFG)
                data["ColumnCFG"].push(item.toJSON());
        }
        if (Array.isArray(this.WhichRows)) {
            data["WhichRows"] = [];
            for (let item of this.WhichRows)
                data["WhichRows"].push(item.toJSON());
        }
        if (Array.isArray(this.Data)) {
            data["Data"] = [];
            for (let item of this.Data)
                data["Data"].push(item);
        }
        return data;
    }

    clone(): ExportRequest {
        const json = this.toJSON();
        let result = new ExportRequest();
        result.init(json);
        return result;
    }
}

/** Information required for an export */
export interface IExportRequest {
    /** Target FN (optional, no path) */
    ExportTargetFileName?: string | undefined;
    /** Key of template or empty key  */
    TemplateId?: string | undefined;
    /** Time Limit in minutes */
    TimeLimit?: number;
    /** Collection of columns to be exported */
    ColumnCFG?: UIDisplayConfigBasics[] | undefined;
    /** Specifies which rows to export.  If empty, exports all rows */
    WhichRows?: CurrentDataSummary[] | undefined;
    /** all the data  */
    Data?: any[] | undefined;
}

/** Describes the basic configuration for a UI element */
export class UIDisplayConfigBasics implements IUIDisplayConfigBasics {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUIDisplayConfigBasics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartConfigKey = _data["PartConfigKey"];
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.Label = _data["Label"];
            this.DisplayFormat = _data["DisplayFormat"];
            this.Width = _data["Width"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UIDisplayConfigBasics {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayConfigBasics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.PartConfigKey;
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["Label"] = this.Label;
        data["DisplayFormat"] = this.DisplayFormat;
        data["Width"] = this.Width;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UIDisplayConfigBasics {
        const json = this.toJSON();
        let result = new UIDisplayConfigBasics();
        result.init(json);
        return result;
    }
}

/** Describes the basic configuration for a UI element */
export interface IUIDisplayConfigBasics {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes a Part, including the fields available to this user */
export class UIDisplayPart implements IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** What field typically filters this part (often DocTypeKey) */
    FilterParam?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explanation or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for WebIX UI */
    wbxUI?: boolean;
    /** For client side cache expiration (when the stored value is less than the current value, reload) */
    LVMagicNumber?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUIDisplayPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartName = _data["PartName"];
            this.FilterParam = _data["FilterParam"];
            this.DisplayName = _data["DisplayName"];
            this.Description = _data["Description"];
            this.GetAPI = _data["GetAPI"];
            this.PartType = _data["PartType"];
            this.ViaUI = _data["ViaUI"];
            this.Active = _data["Active"];
            this.SortHint = _data["SortHint"];
            if (Array.isArray(_data["UIItems"])) {
                this.UIItems = [] as any;
                for (let item of _data["UIItems"])
                    this.UIItems!.push(UIDisplayConfig.fromJS(item));
            }
            if (Array.isArray(_data["UIFilters"])) {
                this.UIFilters = [] as any;
                for (let item of _data["UIFilters"])
                    this.UIFilters!.push(UIDisplayFilter.fromJS(item));
            }
            this.wbxUI = _data["wbxUI"];
            this.LVMagicNumber = _data["LVMagicNumber"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UIDisplayPart {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartName"] = this.PartName;
        data["FilterParam"] = this.FilterParam;
        data["DisplayName"] = this.DisplayName;
        data["Description"] = this.Description;
        data["GetAPI"] = this.GetAPI;
        data["PartType"] = this.PartType;
        data["ViaUI"] = this.ViaUI;
        data["Active"] = this.Active;
        data["SortHint"] = this.SortHint;
        if (Array.isArray(this.UIItems)) {
            data["UIItems"] = [];
            for (let item of this.UIItems)
                data["UIItems"].push(item.toJSON());
        }
        if (Array.isArray(this.UIFilters)) {
            data["UIFilters"] = [];
            for (let item of this.UIFilters)
                data["UIFilters"].push(item.toJSON());
        }
        data["wbxUI"] = this.wbxUI;
        data["LVMagicNumber"] = this.LVMagicNumber;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UIDisplayPart {
        const json = this.toJSON();
        let result = new UIDisplayPart();
        result.init(json);
        return result;
    }
}

/** Describes a Part, including the fields available to this user */
export interface IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** What field typically filters this part (often DocTypeKey) */
    FilterParam?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explanation or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for WebIX UI */
    wbxUI?: boolean;
    /** For client side cache expiration (when the stored value is less than the current value, reload) */
    LVMagicNumber?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export class UIDisplayConfig implements IUIDisplayConfig {
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** When true, field is visible by default */
    DefaultVisible?: boolean;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** Bit coded information about field behavior (legacy UI) */
    UIFlags?: number;
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo?: number;
    /** For controlling sequence (tab order) */
    SeqData?: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore?: number;
    /** When TRUE, UI will be read only */
    IsReadOnly?: boolean;
    /** Controls the default visible attribute   */
    Visible?: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML?: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -> contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** 0 — the default – no validation
2 — Numeric
3 — Any Date(implicit date range validation may also apply); see also CSS=uiAnyDate(above)
4 — Future Date(implicit date range validation may also apply)
5 — Positive Numeric
6 — Integer
7 — Positive Integer
8 — Until Date(any date up to including today) (implicit date range validation may also apply, see kba-01336)
16 — Non empty */
    ValidationMode?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** Name of a js type */
    DataType?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** Parent Filters (semicolon separated) */
    ParentFilters?: string | undefined;
    /** UI Tip text */
    TipText?: string | undefined;
    /** Max characters, for character types, this is from database size */
    MaxChars?: number;
    /** When true, the user cannot show or hide this column.  Server config is locked */
    VisibleLocked?: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault?: boolean;
    /** RX Pattern.  If specified, proposed values must match */
    RXPattern?: string | undefined;
    /** When set, display an info-pop style add on along side this ui elment.  Content comes from the specified peer data field */
    ShowInfoPop?: string | undefined;
    /** Indicates if this column is part of the default sort A for Ascending, D for Descending */
    SortFlag?: string | undefined;
    /** 0 for none, empty typically defaults to excelFilter.  
other possibilities
'spitfireDateRangeFilter' // for datetime type
'spitfireDynamicTextFilter'  // for long text fields, w/wo HTML, UIType=freeform, css uiText
'spitfireTextFilter' // not currently used
'spitfireSingleSelectFilter' // for css uiSingle 
'spitfireMultiSelectFilter' // for css uiMulti
'spitfireTrueFalseSingleSelectFilter' // for DataType Boolean, uiType Checkbox, CSS uiBool
'spitfirePriorityMultiSelectFilter'  */
    ClientFilter?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width?: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** When true, configurable for WebIX UI */
    WbxUI?: boolean;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUIDisplayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.DefaultVisible = _data["DefaultVisible"];
            this.ViaUI = _data["ViaUI"];
            this.UIFlags = _data["UIFlags"];
            this.PartConfigKey = _data["PartConfigKey"];
            this.Label = _data["Label"];
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.SeqData = _data["SeqData"];
            this.RequiredBefore = _data["RequiredBefore"];
            this.IsReadOnly = _data["IsReadOnly"];
            this.Visible = _data["Visible"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.HTML = _data["HTML"];
            this.Overlay = _data["Overlay"];
            this.ShownWhen = _data["ShownWhen"];
            this.ValidateAgainst = _data["ValidateAgainst"];
            this.ValidateTextAgainst = _data["ValidateTextAgainst"];
            this.ValidationMax = _data["ValidationMax"];
            this.ValidationMin = _data["ValidationMin"];
            this.ValidationMode = _data["ValidationMode"];
            this.DisplayFormat = _data["DisplayFormat"];
            this.DataType = _data["DataType"];
            this.LookupName = _data["LookupName"];
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        (<any>this.OtherProperties)![key] = _data["OtherProperties"][key];
                }
            }
            this.ClickAction = _data["ClickAction"];
            this.ParentFilters = _data["ParentFilters"];
            this.TipText = _data["TipText"];
            this.MaxChars = _data["MaxChars"];
            this.VisibleLocked = _data["VisibleLocked"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.RXPattern = _data["RXPattern"];
            this.ShowInfoPop = _data["ShowInfoPop"];
            this.SortFlag = _data["SortFlag"];
            this.ClientFilter = _data["ClientFilter"];
            this.Width = _data["Width"];
            this.WidthCSS = _data["WidthCSS"];
            this.WbxUI = _data["WbxUI"];
            this.UIType = _data["UIType"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UIDisplayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["DefaultVisible"] = this.DefaultVisible;
        data["ViaUI"] = this.ViaUI;
        data["UIFlags"] = this.UIFlags;
        data["PartConfigKey"] = this.PartConfigKey;
        data["Label"] = this.Label;
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["SeqData"] = this.SeqData;
        data["RequiredBefore"] = this.RequiredBefore;
        data["IsReadOnly"] = this.IsReadOnly;
        data["Visible"] = this.Visible;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["HTML"] = this.HTML;
        data["Overlay"] = this.Overlay;
        data["ShownWhen"] = this.ShownWhen;
        data["ValidateAgainst"] = this.ValidateAgainst;
        data["ValidateTextAgainst"] = this.ValidateTextAgainst;
        data["ValidationMax"] = this.ValidationMax;
        data["ValidationMin"] = this.ValidationMin;
        data["ValidationMode"] = this.ValidationMode;
        data["DisplayFormat"] = this.DisplayFormat;
        data["DataType"] = this.DataType;
        data["LookupName"] = this.LookupName;
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    (<any>data["OtherProperties"])[key] = (<any>this.OtherProperties)[key];
            }
        }
        data["ClickAction"] = this.ClickAction;
        data["ParentFilters"] = this.ParentFilters;
        data["TipText"] = this.TipText;
        data["MaxChars"] = this.MaxChars;
        data["VisibleLocked"] = this.VisibleLocked;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["RXPattern"] = this.RXPattern;
        data["ShowInfoPop"] = this.ShowInfoPop;
        data["SortFlag"] = this.SortFlag;
        data["ClientFilter"] = this.ClientFilter;
        data["Width"] = this.Width;
        data["WidthCSS"] = this.WidthCSS;
        data["WbxUI"] = this.WbxUI;
        data["UIType"] = this.UIType;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UIDisplayConfig {
        const json = this.toJSON();
        let result = new UIDisplayConfig();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export interface IUIDisplayConfig {
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** When true, field is visible by default */
    DefaultVisible?: boolean;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** Bit coded information about field behavior (legacy UI) */
    UIFlags?: number;
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo?: number;
    /** For controlling sequence (tab order) */
    SeqData?: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore?: number;
    /** When TRUE, UI will be read only */
    IsReadOnly?: boolean;
    /** Controls the default visible attribute   */
    Visible?: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML?: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -> contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** 0 — the default – no validation
2 — Numeric
3 — Any Date(implicit date range validation may also apply); see also CSS=uiAnyDate(above)
4 — Future Date(implicit date range validation may also apply)
5 — Positive Numeric
6 — Integer
7 — Positive Integer
8 — Until Date(any date up to including today) (implicit date range validation may also apply, see kba-01336)
16 — Non empty */
    ValidationMode?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** Name of a js type */
    DataType?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** Parent Filters (semicolon separated) */
    ParentFilters?: string | undefined;
    /** UI Tip text */
    TipText?: string | undefined;
    /** Max characters, for character types, this is from database size */
    MaxChars?: number;
    /** When true, the user cannot show or hide this column.  Server config is locked */
    VisibleLocked?: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault?: boolean;
    /** RX Pattern.  If specified, proposed values must match */
    RXPattern?: string | undefined;
    /** When set, display an info-pop style add on along side this ui elment.  Content comes from the specified peer data field */
    ShowInfoPop?: string | undefined;
    /** Indicates if this column is part of the default sort A for Ascending, D for Descending */
    SortFlag?: string | undefined;
    /** 0 for none, empty typically defaults to excelFilter.  
other possibilities
'spitfireDateRangeFilter' // for datetime type
'spitfireDynamicTextFilter'  // for long text fields, w/wo HTML, UIType=freeform, css uiText
'spitfireTextFilter' // not currently used
'spitfireSingleSelectFilter' // for css uiSingle 
'spitfireMultiSelectFilter' // for css uiMulti
'spitfireTrueFalseSingleSelectFilter' // for DataType Boolean, uiType Checkbox, CSS uiBool
'spitfirePriorityMultiSelectFilter'  */
    ClientFilter?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width?: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** When true, configurable for WebIX UI */
    WbxUI?: boolean;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export class UIDisplayFilter implements IUIDisplayFilter {
    /** The visible label for this entry */
    Label?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** UI Tip text */
    TipText?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo?: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible?: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault?: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -> contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** When true, configurable for WebIX UI */
    WbxUI?: boolean;
    /** When true, field is visible by default */
    DefaultVisible?: boolean;
    /** Bit coded information about field behavior (legacy UI) */
    UIFlags?: number;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUIDisplayFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Label = _data["Label"];
            this.DisplayFormat = _data["DisplayFormat"];
            this.ItemName = _data["ItemName"];
            this.PartConfigKey = _data["PartConfigKey"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.LookupName = _data["LookupName"];
            this.UIType = _data["UIType"];
            if (_data["AuxData"]) {
                this.AuxData = {} as any;
                for (let key in _data["AuxData"]) {
                    if (_data["AuxData"].hasOwnProperty(key))
                        (<any>this.AuxData)![key] = _data["AuxData"][key];
                }
            }
            this.TipText = _data["TipText"];
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.DefaultValue = _data["DefaultValue"];
            this.Visible = _data["Visible"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.Overlay = _data["Overlay"];
            this.ShownWhen = _data["ShownWhen"];
            this.ValidateAgainst = _data["ValidateAgainst"];
            this.ValidateTextAgainst = _data["ValidateTextAgainst"];
            this.ValidationMax = _data["ValidationMax"];
            this.ValidationMin = _data["ValidationMin"];
            if (Array.isArray(_data["Choices"])) {
                this.Choices = [] as any;
                for (let item of _data["Choices"])
                    this.Choices!.push(Suggestion.fromJS(item));
            }
            this.ViaUI = _data["ViaUI"];
            this.WbxUI = _data["WbxUI"];
            this.DefaultVisible = _data["DefaultVisible"];
            this.UIFlags = _data["UIFlags"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UIDisplayFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Label"] = this.Label;
        data["DisplayFormat"] = this.DisplayFormat;
        data["ItemName"] = this.ItemName;
        data["PartConfigKey"] = this.PartConfigKey;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["LookupName"] = this.LookupName;
        data["UIType"] = this.UIType;
        if (this.AuxData) {
            data["AuxData"] = {};
            for (let key in this.AuxData) {
                if (this.AuxData.hasOwnProperty(key))
                    (<any>data["AuxData"])[key] = (<any>this.AuxData)[key];
            }
        }
        data["TipText"] = this.TipText;
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["DefaultValue"] = this.DefaultValue;
        data["Visible"] = this.Visible;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["Overlay"] = this.Overlay;
        data["ShownWhen"] = this.ShownWhen;
        data["ValidateAgainst"] = this.ValidateAgainst;
        data["ValidateTextAgainst"] = this.ValidateTextAgainst;
        data["ValidationMax"] = this.ValidationMax;
        data["ValidationMin"] = this.ValidationMin;
        if (Array.isArray(this.Choices)) {
            data["Choices"] = [];
            for (let item of this.Choices)
                data["Choices"].push(item.toJSON());
        }
        data["ViaUI"] = this.ViaUI;
        data["WbxUI"] = this.WbxUI;
        data["DefaultVisible"] = this.DefaultVisible;
        data["UIFlags"] = this.UIFlags;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UIDisplayFilter {
        const json = this.toJSON();
        let result = new UIDisplayFilter();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export interface IUIDisplayFilter {
    /** The visible label for this entry */
    Label?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey?: string;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** UI Tip text */
    TipText?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo?: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible?: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault?: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -> contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI?: boolean;
    /** When true, configurable for WebIX UI */
    WbxUI?: boolean;
    /** When true, field is visible by default */
    DefaultVisible?: boolean;
    /** Bit coded information about field behavior (legacy UI) */
    UIFlags?: number;
    /** eTag */
    ETag?: string | undefined;
}

/** A change to a system field value */
export class FieldAudit implements IFieldAudit {
    /** when the change was persisted */
    ChangeWhen?: Date;
    /** string representation of the prior field value */
    PriorValue?: any | undefined;
    /** string representation of the new field value */
    NewValue?: string | undefined;
    /** user that made the change */
    ByUser?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IFieldAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ChangeWhen = _data["ChangeWhen"] ? new Date(_data["ChangeWhen"].toString()) : <any>undefined;
            this.PriorValue = _data["PriorValue"];
            this.NewValue = _data["NewValue"];
            this.ByUser = _data["ByUser"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): FieldAudit {
        data = typeof data === 'object' ? data : {};
        let result = new FieldAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ChangeWhen"] = this.ChangeWhen ? this.ChangeWhen.toISOString() : <any>undefined;
        data["PriorValue"] = this.PriorValue;
        data["NewValue"] = this.NewValue;
        data["ByUser"] = this.ByUser;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): FieldAudit {
        const json = this.toJSON();
        let result = new FieldAudit();
        result.init(json);
        return result;
    }
}

/** A change to a system field value */
export interface IFieldAudit {
    /** when the change was persisted */
    ChangeWhen?: Date;
    /** string representation of the prior field value */
    PriorValue?: any | undefined;
    /** string representation of the new field value */
    NewValue?: string | undefined;
    /** user that made the change */
    ByUser?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Parameters for a Displayable Value request */
export class DVRequest implements IDVRequest {
    /** ID of this request (returned with the result) */
    RequestID!: string;
    /** Name of DV to be resolved */
    DVName!: string;
    /** seed */
    MatchingValue?: string | undefined;
    DependsOn?: string[] | undefined;
    /** Data Context (not often used with most DV requests) */
    DataContext?: string | undefined;

    constructor(data?: IDVRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RequestID = _data["RequestID"];
            this.DVName = _data["DVName"];
            this.MatchingValue = _data["MatchingValue"];
            if (Array.isArray(_data["DependsOn"])) {
                this.DependsOn = [] as any;
                for (let item of _data["DependsOn"])
                    this.DependsOn!.push(item);
            }
            this.DataContext = _data["DataContext"];
        }
    }

    static fromJS(data: any): DVRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DVRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RequestID"] = this.RequestID;
        data["DVName"] = this.DVName;
        data["MatchingValue"] = this.MatchingValue;
        if (Array.isArray(this.DependsOn)) {
            data["DependsOn"] = [];
            for (let item of this.DependsOn)
                data["DependsOn"].push(item);
        }
        data["DataContext"] = this.DataContext;
        return data;
    }

    clone(): DVRequest {
        const json = this.toJSON();
        let result = new DVRequest();
        result.init(json);
        return result;
    }
}

/** Parameters for a Displayable Value request */
export interface IDVRequest {
    /** ID of this request (returned with the result) */
    RequestID: string;
    /** Name of DV to be resolved */
    DVName: string;
    /** seed */
    MatchingValue?: string | undefined;
    DependsOn?: string[] | undefined;
    /** Data Context (not often used with most DV requests) */
    DataContext?: string | undefined;
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export class CodeChoice implements ICodeChoice {
    /** Name for a set of choices */
    SetName!: string;
    /** Code */
    Code!: string;
    /** Display Value  */
    Description!: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active?: boolean;
    /** True if code is allowed for new records */
    OnAdd?: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ICodeChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.SetName = _data["SetName"];
            this.Code = _data["Code"];
            this.Description = _data["Description"];
            this.NextSet = _data["NextSet"];
            this.Active = _data["Active"];
            this.OnAdd = _data["OnAdd"];
            this.CodeFlag = _data["CodeFlag"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): CodeChoice {
        data = typeof data === 'object' ? data : {};
        let result = new CodeChoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SetName"] = this.SetName;
        data["Code"] = this.Code;
        data["Description"] = this.Description;
        data["NextSet"] = this.NextSet;
        data["Active"] = this.Active;
        data["OnAdd"] = this.OnAdd;
        data["CodeFlag"] = this.CodeFlag;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): CodeChoice {
        const json = this.toJSON();
        let result = new CodeChoice();
        result.init(json);
        return result;
    }
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export interface ICodeChoice {
    /** Name for a set of choices */
    SetName: string;
    /** Code */
    Code: string;
    /** Display Value  */
    Description: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active?: boolean;
    /** True if code is allowed for new records */
    OnAdd?: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

export class CloudChange implements ICloudChange {
    ChangeTime?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
    modifiedBy?: string | undefined;
    hash?: string | undefined;
    size?: number;
    type?: number;
    versionId?: string | undefined;
    removed?: boolean;
    WhenModified?: Date;

    constructor(data?: ICloudChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ChangeTime = _data["ChangeTime"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.modifiedBy = _data["modifiedBy"];
            this.hash = _data["hash"];
            this.size = _data["size"];
            this.type = _data["type"];
            this.versionId = _data["versionId"];
            this.removed = _data["removed"];
            this.WhenModified = _data["WhenModified"] ? new Date(_data["WhenModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CloudChange {
        data = typeof data === 'object' ? data : {};
        let result = new CloudChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ChangeTime"] = this.ChangeTime;
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["modifiedBy"] = this.modifiedBy;
        data["hash"] = this.hash;
        data["size"] = this.size;
        data["type"] = this.type;
        data["versionId"] = this.versionId;
        data["removed"] = this.removed;
        data["WhenModified"] = this.WhenModified ? this.WhenModified.toISOString() : <any>undefined;
        return data;
    }

    clone(): CloudChange {
        const json = this.toJSON();
        let result = new CloudChange();
        result.init(json);
        return result;
    }
}

export interface ICloudChange {
    ChangeTime?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
    modifiedBy?: string | undefined;
    hash?: string | undefined;
    size?: number;
    type?: number;
    versionId?: string | undefined;
    removed?: boolean;
    WhenModified?: Date;
}

/** Primary Site Weather Now */
export class ProjKPIFact implements IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative?: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;

    constructor(data?: IProjKPIFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Column = _data["Column"];
            this.Label = _data["Label"];
            this.Value = _data["Value"];
            this.Action = _data["Action"];
            this.DForm = _data["DForm"];
            this.TForm = _data["TForm"];
            this.Negative = _data["Negative"];
            this.ItemName = _data["ItemName"];
        }
    }

    static fromJS(data: any): ProjKPIFact {
        data = typeof data === 'object' ? data : {};
        let result = new ProjKPIFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Column"] = this.Column;
        data["Label"] = this.Label;
        data["Value"] = this.Value;
        data["Action"] = this.Action;
        data["DForm"] = this.DForm;
        data["TForm"] = this.TForm;
        data["Negative"] = this.Negative;
        data["ItemName"] = this.ItemName;
        return data;
    }

    clone(): ProjKPIFact {
        const json = this.toJSON();
        let result = new ProjKPIFact();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative?: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;
}

/** Attributes describing a member of a project team */
export class ProjectTeamMember implements IProjectTeamMember {
    /** Primary Key */
    UserProjectKey!: string;
    /** Key of Team Member in contact table */
    UserKey?: string;
    /** Login name of the team member  (see UserName below) */
    UserKey_dv?: string | undefined;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserKey_IsInactive?: boolean;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility?: string;
    /** Role Name (see Responsibility) */
    Responsibility_dv?: string | undefined;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Phone   */
    Phone?: string | undefined;
    /** Cell/Mobile Phone   */
    Cell?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Familiar Name (Nick for Nicholas, Liz for Elizabeth)  */
    FamiliarName?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting?: Date | undefined;
    /** When the team member left (or was replaced) */
    Ending?: Date | undefined;
    /** When TRUE,  shown by default */
    TeamList?: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic?: boolean;
    /** When TRUE, this team member is active */
    Active?: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic?: boolean;
    /** custom amount */
    csAmount?: number;
    /** custom amount */
    csValue?: number;
    /** custom quantity */
    csQty?: number;
    /** custom whole number */
    csNumber?: number;
    /** custom boolean */
    csCheck?: boolean;
    /** custom boolean */
    csFlag?: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IProjectTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserProjectKey = _data["UserProjectKey"];
            this.UserKey = _data["UserKey"];
            this.UserKey_dv = _data["UserKey_dv"];
            this.UserKey_IsInactive = _data["UserKey_IsInactive"];
            this.Responsibility = _data["Responsibility"];
            this.Responsibility_dv = _data["Responsibility_dv"];
            this.UserName = _data["UserName"];
            this.Company = _data["Company"];
            this.email = _data["email"];
            this.UsePhone = _data["UsePhone"];
            this.Phone = _data["Phone"];
            this.Cell = _data["Cell"];
            this.ContactProject = _data["ContactProject"];
            this.FamiliarName = _data["FamiliarName"];
            this.RoleDescription = _data["RoleDescription"];
            this.LikenessURL = _data["LikenessURL"];
            this.WebURL = _data["WebURL"];
            this.Starting = _data["Starting"] ? new Date(_data["Starting"].toString()) : <any>undefined;
            this.Ending = _data["Ending"] ? new Date(_data["Ending"].toString()) : <any>undefined;
            this.TeamList = _data["TeamList"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.UserNotPublic = _data["UserNotPublic"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.ETag = _data["ETag"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectTeamMember {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserProjectKey"] = this.UserProjectKey;
        data["UserKey"] = this.UserKey;
        data["UserKey_dv"] = this.UserKey_dv;
        data["UserKey_IsInactive"] = this.UserKey_IsInactive;
        data["Responsibility"] = this.Responsibility;
        data["Responsibility_dv"] = this.Responsibility_dv;
        data["UserName"] = this.UserName;
        data["Company"] = this.Company;
        data["email"] = this.email;
        data["UsePhone"] = this.UsePhone;
        data["Phone"] = this.Phone;
        data["Cell"] = this.Cell;
        data["ContactProject"] = this.ContactProject;
        data["FamiliarName"] = this.FamiliarName;
        data["RoleDescription"] = this.RoleDescription;
        data["LikenessURL"] = this.LikenessURL;
        data["WebURL"] = this.WebURL;
        data["Starting"] = this.Starting ? this.Starting.toISOString() : <any>undefined;
        data["Ending"] = this.Ending ? this.Ending.toISOString() : <any>undefined;
        data["TeamList"] = this.TeamList;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["UserNotPublic"] = this.UserNotPublic;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["ETag"] = this.ETag;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProjectTeamMember {
        const json = this.toJSON();
        let result = new ProjectTeamMember();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface IProjectTeamMember {
    /** Primary Key */
    UserProjectKey: string;
    /** Key of Team Member in contact table */
    UserKey?: string;
    /** Login name of the team member  (see UserName below) */
    UserKey_dv?: string | undefined;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserKey_IsInactive?: boolean;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility?: string;
    /** Role Name (see Responsibility) */
    Responsibility_dv?: string | undefined;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Phone   */
    Phone?: string | undefined;
    /** Cell/Mobile Phone   */
    Cell?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Familiar Name (Nick for Nicholas, Liz for Elizabeth)  */
    FamiliarName?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting?: Date | undefined;
    /** When the team member left (or was replaced) */
    Ending?: Date | undefined;
    /** When TRUE,  shown by default */
    TeamList?: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic?: boolean;
    /** When TRUE, this team member is active */
    Active?: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic?: boolean;
    /** custom amount */
    csAmount?: number;
    /** custom amount */
    csValue?: number;
    /** custom quantity */
    csQty?: number;
    /** custom whole number */
    csNumber?: number;
    /** custom boolean */
    csCheck?: boolean;
    /** custom boolean */
    csFlag?: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
    /** eTag */
    ETag?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Primary Summary of project information for list of projects (location, etc) */
export class ProjectSummary implements IProjectSummary {
    /** Project ID */
    Project!: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude?: number;
    /** Geo longitude from Project Setup Tab */
    longitude?: number;
    /** Start Date from Project Setup Dates tab */
    StartDate?: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate?: Date;
    /** Key for this user on project team */
    UserProjectKey?: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact?: string;
    /** Key for Image */
    ImageKey?: string;
    /** TRUE if this project is on the user list */
    UserList?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IProjectSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Description = _data["Description"];
            this.StatusText = _data["StatusText"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.StartDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
            this.FinishDate = _data["FinishDate"] ? new Date(_data["FinishDate"].toString()) : <any>undefined;
            this.UserProjectKey = _data["UserProjectKey"];
            this.SourceContact = _data["SourceContact"];
            this.ImageKey = _data["ImageKey"];
            this.UserList = _data["UserList"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ProjectSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Description"] = this.Description;
        data["StatusText"] = this.StatusText;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["StartDate"] = this.StartDate ? this.StartDate.toISOString() : <any>undefined;
        data["FinishDate"] = this.FinishDate ? this.FinishDate.toISOString() : <any>undefined;
        data["UserProjectKey"] = this.UserProjectKey;
        data["SourceContact"] = this.SourceContact;
        data["ImageKey"] = this.ImageKey;
        data["UserList"] = this.UserList;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ProjectSummary {
        const json = this.toJSON();
        let result = new ProjectSummary();
        result.init(json);
        return result;
    }
}

/** Primary Summary of project information for list of projects (location, etc) */
export interface IProjectSummary {
    /** Project ID */
    Project: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude?: number;
    /** Geo longitude from Project Setup Tab */
    longitude?: number;
    /** Start Date from Project Setup Dates tab */
    StartDate?: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate?: Date;
    /** Key for this user on project team */
    UserProjectKey?: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact?: string;
    /** Key for Image */
    ImageKey?: string;
    /** TRUE if this project is on the user list */
    UserList?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** Defines a payload intended for retrieval using a token */
export class TokenRequest implements ITokenRequest {
    /** Key for User for whom the alert was generated */
    UserKey?: string;
    /** Name of User  */
    FullName?: string | undefined;
    /** Max Idle time allowed in minutes */
    IdleForce?: number;
    /** Icon Height (for classic UI)   */
    IconHeight?: number;
    /** Key for Operation */
    DataPK?: string | undefined;
    /** Key for Document Session */
    DocSessionKey?: string | undefined;
    /** Key for User Session */
    LoginSessionKey?: string;
    /** Key for Site  */
    SiteID?: string;
    /** Context ID String */
    dsCacheKey?: string | undefined;
    /** Page Name  */
    PageName?: string | undefined;
    /** Part Name  */
    PartName?: string | undefined;
    /** Magic number. When changes, UI settings have changed */
    uiVaryBy?: number;
    /** Indicates if user holds exclusive access  */
    DataLockFlag?: string | undefined;
    /** When true, this user has opted out of Analytic data collection */
    GAFMOptOut?: boolean;
    /** Time offset in hours */
    TZOffset?: number;
    /** Payload  */
    Args?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.FullName = _data["FullName"];
            this.IdleForce = _data["IdleForce"];
            this.IconHeight = _data["IconHeight"];
            this.DataPK = _data["DataPK"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.LoginSessionKey = _data["LoginSessionKey"];
            this.SiteID = _data["SiteID"];
            this.dsCacheKey = _data["dsCacheKey"];
            this.PageName = _data["PageName"];
            this.PartName = _data["PartName"];
            this.uiVaryBy = _data["uiVaryBy"];
            this.DataLockFlag = _data["DataLockFlag"];
            this.GAFMOptOut = _data["GAFMOptOut"];
            this.TZOffset = _data["TZOffset"];
            this.Args = _data["Args"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["FullName"] = this.FullName;
        data["IdleForce"] = this.IdleForce;
        data["IconHeight"] = this.IconHeight;
        data["DataPK"] = this.DataPK;
        data["DocSessionKey"] = this.DocSessionKey;
        data["LoginSessionKey"] = this.LoginSessionKey;
        data["SiteID"] = this.SiteID;
        data["dsCacheKey"] = this.dsCacheKey;
        data["PageName"] = this.PageName;
        data["PartName"] = this.PartName;
        data["uiVaryBy"] = this.uiVaryBy;
        data["DataLockFlag"] = this.DataLockFlag;
        data["GAFMOptOut"] = this.GAFMOptOut;
        data["TZOffset"] = this.TZOffset;
        data["Args"] = this.Args;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): TokenRequest {
        const json = this.toJSON();
        let result = new TokenRequest();
        result.init(json);
        return result;
    }
}

/** Defines a payload intended for retrieval using a token */
export interface ITokenRequest {
    /** Key for User for whom the alert was generated */
    UserKey?: string;
    /** Name of User  */
    FullName?: string | undefined;
    /** Max Idle time allowed in minutes */
    IdleForce?: number;
    /** Icon Height (for classic UI)   */
    IconHeight?: number;
    /** Key for Operation */
    DataPK?: string | undefined;
    /** Key for Document Session */
    DocSessionKey?: string | undefined;
    /** Key for User Session */
    LoginSessionKey?: string;
    /** Key for Site  */
    SiteID?: string;
    /** Context ID String */
    dsCacheKey?: string | undefined;
    /** Page Name  */
    PageName?: string | undefined;
    /** Part Name  */
    PartName?: string | undefined;
    /** Magic number. When changes, UI settings have changed */
    uiVaryBy?: number;
    /** Indicates if user holds exclusive access  */
    DataLockFlag?: string | undefined;
    /** When true, this user has opted out of Analytic data collection */
    GAFMOptOut?: boolean;
    /** Time offset in hours */
    TZOffset?: number;
    /** Payload  */
    Args?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

export class AuthenticationExchangeData implements IAuthenticationExchangeData {

    constructor(data?: IAuthenticationExchangeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): AuthenticationExchangeData {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationExchangeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): AuthenticationExchangeData {
        const json = this.toJSON();
        let result = new AuthenticationExchangeData();
        result.init(json);
        return result;
    }
}

export interface IAuthenticationExchangeData {
}

/** Describes a set of permissions for this user */
export class UCPermitSet implements IUCPermitSet {
    /** Key of this item */
    Project!: string;
    /** Links to Module|Function  */
    Permits?: { [key: string]: UCPermit[]; } | undefined;

    constructor(data?: IUCPermitSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            if (_data["Permits"]) {
                this.Permits = {} as any;
                for (let key in _data["Permits"]) {
                    if (_data["Permits"].hasOwnProperty(key))
                        (<any>this.Permits)![key] = _data["Permits"][key] ? _data["Permits"][key].map((i: any) => UCPermit.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): UCPermitSet {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermitSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        if (this.Permits) {
            data["Permits"] = {};
            for (let key in this.Permits) {
                if (this.Permits.hasOwnProperty(key))
                    (<any>data["Permits"])[key] = (<any>this.Permits)[key];
            }
        }
        return data;
    }

    clone(): UCPermitSet {
        const json = this.toJSON();
        let result = new UCPermitSet();
        result.init(json);
        return result;
    }
}

/** Describes a set of permissions for this user */
export interface IUCPermitSet {
    /** Key of this item */
    Project: string;
    /** Links to Module|Function  */
    Permits?: { [key: string]: UCPermit[]; } | undefined;
}

/** Permissions for a specific function */
export class UCPermit implements IUCPermit {
    /** When true, has read permission */
    ReadOK?: boolean;
    /** When true, has read permission */
    BlanketOK?: boolean;
    /** When true, has read permission */
    InsOK?: boolean;
    /** When true, has read permission */
    UpdOK?: boolean;
    /** When true, has read permission */
    DelOK?: boolean;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** When true, there is no restriction on this permission */
    IsGlobal?: boolean;

    constructor(data?: IUCPermit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ReadOK = _data["ReadOK"];
            this.BlanketOK = _data["BlanketOK"];
            this.InsOK = _data["InsOK"];
            this.UpdOK = _data["UpdOK"];
            this.DelOK = _data["DelOK"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocReference = _data["DocReference"];
            this.IsGlobal = _data["IsGlobal"];
        }
    }

    static fromJS(data: any): UCPermit {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ReadOK"] = this.ReadOK;
        data["BlanketOK"] = this.BlanketOK;
        data["InsOK"] = this.InsOK;
        data["UpdOK"] = this.UpdOK;
        data["DelOK"] = this.DelOK;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocReference"] = this.DocReference;
        data["IsGlobal"] = this.IsGlobal;
        return data;
    }

    clone(): UCPermit {
        const json = this.toJSON();
        let result = new UCPermit();
        result.init(json);
        return result;
    }
}

/** Permissions for a specific function */
export interface IUCPermit {
    /** When true, has read permission */
    ReadOK?: boolean;
    /** When true, has read permission */
    BlanketOK?: boolean;
    /** When true, has read permission */
    InsOK?: boolean;
    /** When true, has read permission */
    UpdOK?: boolean;
    /** When true, has read permission */
    DelOK?: boolean;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** When true, there is no restriction on this permission */
    IsGlobal?: boolean;
}

/** Descriptive content of API issue */
export class HttpResponseJsonContent2 implements IHttpResponseJsonContent2 {
    /** HTTP Response Status Code */
    ThisStatus?: number;
    /** Descriptive reason */
    ThisReason?: string | undefined;

    constructor(data?: IHttpResponseJsonContent2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ThisStatus = _data["ThisStatus"];
            this.ThisReason = _data["ThisReason"];
        }
    }

    static fromJS(data: any): HttpResponseJsonContent2 {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponseJsonContent2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ThisStatus"] = this.ThisStatus;
        data["ThisReason"] = this.ThisReason;
        return data;
    }

    clone(): HttpResponseJsonContent2 {
        const json = this.toJSON();
        let result = new HttpResponseJsonContent2();
        result.init(json);
        return result;
    }
}

/** Descriptive content of API issue */
export interface IHttpResponseJsonContent2 {
    /** HTTP Response Status Code */
    ThisStatus?: number;
    /** Descriptive reason */
    ThisReason?: string | undefined;
}

export class HttpResponseJsonContent extends HttpResponseJsonContent2 implements IHttpResponseJsonContent {

    constructor(data?: IHttpResponseJsonContent) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): HttpResponseJsonContent {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponseJsonContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): HttpResponseJsonContent {
        const json = this.toJSON();
        let result = new HttpResponseJsonContent();
        result.init(json);
        return result;
    }
}

export interface IHttpResponseJsonContent extends IHttpResponseJsonContent2 {
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {

    constructor(data?: IMarshalByRefObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarshalByRefObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MarshalByRefObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): MarshalByRefObject {
        throw new Error("The abstract class 'MarshalByRefObject' cannot be instantiated.");
    }
}

export interface IMarshalByRefObject {
}

export abstract class Stream extends MarshalByRefObject implements IStream {
    CanRead?: boolean;
    CanSeek?: boolean;
    CanTimeout?: boolean;
    CanWrite?: boolean;
    Length?: number;
    Position?: number;
    ReadTimeout?: number;
    WriteTimeout?: number;

    constructor(data?: IStream) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.CanRead = _data["CanRead"];
            this.CanSeek = _data["CanSeek"];
            this.CanTimeout = _data["CanTimeout"];
            this.CanWrite = _data["CanWrite"];
            this.Length = _data["Length"];
            this.Position = _data["Position"];
            this.ReadTimeout = _data["ReadTimeout"];
            this.WriteTimeout = _data["WriteTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Stream' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CanRead"] = this.CanRead;
        data["CanSeek"] = this.CanSeek;
        data["CanTimeout"] = this.CanTimeout;
        data["CanWrite"] = this.CanWrite;
        data["Length"] = this.Length;
        data["Position"] = this.Position;
        data["ReadTimeout"] = this.ReadTimeout;
        data["WriteTimeout"] = this.WriteTimeout;
        super.toJSON(data);
        return data;
    }

    clone(): Stream {
        throw new Error("The abstract class 'Stream' cannot be instantiated.");
    }
}

export interface IStream extends IMarshalByRefObject {
    CanRead?: boolean;
    CanSeek?: boolean;
    CanTimeout?: boolean;
    CanWrite?: boolean;
    Length?: number;
    Position?: number;
    ReadTimeout?: number;
    WriteTimeout?: number;
}

/** Legacy Site Authentication */
export class TabDisplay implements ITabDisplay {
    /** Primary display of tab */
    Label?: string | undefined;
    /** Mouseover display (mostly for classic UI) */
    Tip?: string | undefined;

    constructor(data?: ITabDisplay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Label = _data["Label"];
            this.Tip = _data["Tip"];
        }
    }

    static fromJS(data: any): TabDisplay {
        data = typeof data === 'object' ? data : {};
        let result = new TabDisplay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Label"] = this.Label;
        data["Tip"] = this.Tip;
        return data;
    }

    clone(): TabDisplay {
        const json = this.toJSON();
        let result = new TabDisplay();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ITabDisplay {
    /** Primary display of tab */
    Label?: string | undefined;
    /** Mouseover display (mostly for classic UI) */
    Tip?: string | undefined;
}

/** Passes data to a simple API */
export class PDSData extends APIData implements IPDSData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string,decimal) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly?: boolean;

    constructor(data?: IPDSData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.PDSKey = _data["PDSKey"];
            this.Mode = _data["Mode"];
            this.Path = _data["Path"];
            this.Type = _data["Type"];
            this.UpdateReadOnly = _data["UpdateReadOnly"];
        }
    }

    static fromJS(data: any): PDSData {
        data = typeof data === 'object' ? data : {};
        let result = new PDSData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PDSKey"] = this.PDSKey;
        data["Mode"] = this.Mode;
        data["Path"] = this.Path;
        data["Type"] = this.Type;
        data["UpdateReadOnly"] = this.UpdateReadOnly;
        super.toJSON(data);
        return data;
    }

    clone(): PDSData {
        const json = this.toJSON();
        let result = new PDSData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IPDSData extends IAPIData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string,decimal) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly?: boolean;
}

/** Summary information about a contact */
export class ContactSummary implements IContactSummary {
    /** Link to user/contact */
    UserKey?: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser?: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags?: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When true, there are no references to this contact */
    OkToDelete?: boolean;
    /** When true, this contact came from an external source */
    IsXTS?: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn?: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut?: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary?: boolean;
    /** Key to mapping data for external source */
    TDKeyMapKey?: string;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.SortName = _data["SortName"];
            this.Email = _data["Email"];
            this.UsePhone = _data["UsePhone"];
            this.Fax = _data["Fax"];
            this.sfUser = _data["sfUser"];
            this.ContactType = _data["ContactType"];
            this.ContactFlags = _data["ContactFlags"];
            this.ExternalID = _data["ExternalID"];
            this.Company = _data["Company"];
            this.CSIList = _data["CSIList"];
            this.Active = _data["Active"];
            this.OkToDelete = _data["OkToDelete"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.IsPrimary = _data["IsPrimary"];
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["SortName"] = this.SortName;
        data["Email"] = this.Email;
        data["UsePhone"] = this.UsePhone;
        data["Fax"] = this.Fax;
        data["sfUser"] = this.sfUser;
        data["ContactType"] = this.ContactType;
        data["ContactFlags"] = this.ContactFlags;
        data["ExternalID"] = this.ExternalID;
        data["Company"] = this.Company;
        data["CSIList"] = this.CSIList;
        data["Active"] = this.Active;
        data["OkToDelete"] = this.OkToDelete;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["IsPrimary"] = this.IsPrimary;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): ContactSummary {
        const json = this.toJSON();
        let result = new ContactSummary();
        result.init(json);
        return result;
    }
}

/** Summary information about a contact */
export interface IContactSummary {
    /** Link to user/contact */
    UserKey?: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser?: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags?: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When true, there are no references to this contact */
    OkToDelete?: boolean;
    /** When true, this contact came from an external source */
    IsXTS?: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn?: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut?: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary?: boolean;
    /** Key to mapping data for external source */
    TDKeyMapKey?: string;
    /** eTag */
    ETag?: string | undefined;
}

/** Various filters for contact search */
export class ContactFilters implements IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users?: boolean;
    /** When true, result is limited to  */
    Customers?: boolean;
    /** When true, result is limited to  */
    Employee?: boolean;
    /** When true, result is limited to  */
    Public?: boolean;
    /** When true, result is limited to primary company contacts  */
    Company?: boolean;
    /** When true, result is limited to  */
    Vendors?: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState?: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;

    constructor(data?: IContactFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NameLike = _data["NameLike"];
            this.EmailLike = _data["EmailLike"];
            this.CompanyLike = _data["CompanyLike"];
            this.LocationLike = _data["LocationLike"];
            this.IDLike = _data["IDLike"];
            this.CSIListLike = _data["CSIListLike"];
            this.PhoneLike = _data["PhoneLike"];
            this.Users = _data["Users"];
            this.Customers = _data["Customers"];
            this.Employee = _data["Employee"];
            this.Public = _data["Public"];
            this.Company = _data["Company"];
            this.Vendors = _data["Vendors"];
            this.ContactState = _data["ContactState"];
            this.RoleKey = _data["RoleKey"];
            this.UserKey = _data["UserKey"];
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactFilters {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NameLike"] = this.NameLike;
        data["EmailLike"] = this.EmailLike;
        data["CompanyLike"] = this.CompanyLike;
        data["LocationLike"] = this.LocationLike;
        data["IDLike"] = this.IDLike;
        data["CSIListLike"] = this.CSIListLike;
        data["PhoneLike"] = this.PhoneLike;
        data["Users"] = this.Users;
        data["Customers"] = this.Customers;
        data["Employee"] = this.Employee;
        data["Public"] = this.Public;
        data["Company"] = this.Company;
        data["Vendors"] = this.Vendors;
        data["ContactState"] = this.ContactState;
        data["RoleKey"] = this.RoleKey;
        data["UserKey"] = this.UserKey;
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): ContactFilters {
        const json = this.toJSON();
        let result = new ContactFilters();
        result.init(json);
        return result;
    }
}

/** Various filters for contact search */
export interface IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users?: boolean;
    /** When true, result is limited to  */
    Customers?: boolean;
    /** When true, result is limited to  */
    Employee?: boolean;
    /** When true, result is limited to  */
    Public?: boolean;
    /** When true, result is limited to primary company contacts  */
    Company?: boolean;
    /** When true, result is limited to  */
    Vendors?: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState?: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
}

/** Describes a contact */
export class Contact implements IContact {
    /** Key for this user/contact */
    UserKey?: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with international dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** External Contact ID (returns Vendor or Employee ID if that is the type, otherwise customer id  */
    ExternalID?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone?: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility?: string;
    /** Key to primary company */
    ContactCompanyKey?: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr?: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects?: boolean;
    /** When True, can log in to dashboard */
    sfUser?: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser?: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration?: boolean;
    /** When TRUE, user must change password */
    PWMustChange?: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging?: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel?: number;
    /** Checksum of all externally syched data */
    SynchCheck?: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun?: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created?: Date;
    /** true when this is the primary company contact */
    IsPrimary?: boolean;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.FederatedIdentityInfo = _data["FederatedIdentityInfo"];
            this.SortName = _data["SortName"];
            this.FamiliarName = _data["FamiliarName"];
            this.Salutation = _data["Salutation"];
            this.Title = _data["Title"];
            this.Role = _data["Role"];
            this.EMail = _data["EMail"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.cell = _data["cell"];
            this.pager = _data["pager"];
            this.Company = _data["Company"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.Country = _data["Country"];
            this.County = _data["County"];
            this.TimeZone = _data["TimeZone"];
            this.IMService = _data["IMService"];
            this.IMHandle = _data["IMHandle"];
            this.WebURL = _data["WebURL"];
            this.VendorID = _data["VendorID"];
            this.EmployeeID = _data["EmployeeID"];
            this.ContactType = _data["ContactType"];
            this.ExternalID = _data["ExternalID"];
            this.RouteVia = _data["RouteVia"];
            this.ShowPhone = _data["ShowPhone"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.DefaultResponsibility = _data["DefaultResponsibility"];
            this.ContactCompanyKey = _data["ContactCompanyKey"];
            this.Signature = _data["Signature"];
            this.Likeness = _data["Likeness"];
            this.UseCompanyAddr = _data["UseCompanyAddr"];
            this.ShowNewProjects = _data["ShowNewProjects"];
            this.sfUser = _data["sfUser"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.SolomonUser = _data["SolomonUser"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.PWMustChange = _data["PWMustChange"];
            this.PWAging = _data["PWAging"];
            this.DivisionID = _data["DivisionID"];
            this.LockoutReason = _data["LockoutReason"];
            this.OrgLevel = _data["OrgLevel"];
            this.SynchCheck = _data["SynchCheck"];
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.LastLogin = _data["LastLogin"] ? new Date(_data["LastLogin"].toString()) : <any>undefined;
            this.LastPWChange = _data["LastPWChange"] ? new Date(_data["LastPWChange"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.IsPrimary = _data["IsPrimary"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["FederatedIdentityInfo"] = this.FederatedIdentityInfo;
        data["SortName"] = this.SortName;
        data["FamiliarName"] = this.FamiliarName;
        data["Salutation"] = this.Salutation;
        data["Title"] = this.Title;
        data["Role"] = this.Role;
        data["EMail"] = this.EMail;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["cell"] = this.cell;
        data["pager"] = this.pager;
        data["Company"] = this.Company;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["Country"] = this.Country;
        data["County"] = this.County;
        data["TimeZone"] = this.TimeZone;
        data["IMService"] = this.IMService;
        data["IMHandle"] = this.IMHandle;
        data["WebURL"] = this.WebURL;
        data["VendorID"] = this.VendorID;
        data["EmployeeID"] = this.EmployeeID;
        data["ContactType"] = this.ContactType;
        data["ExternalID"] = this.ExternalID;
        data["RouteVia"] = this.RouteVia;
        data["ShowPhone"] = this.ShowPhone;
        data["RouteeProxy"] = this.RouteeProxy;
        data["DefaultResponsibility"] = this.DefaultResponsibility;
        data["ContactCompanyKey"] = this.ContactCompanyKey;
        data["Signature"] = this.Signature;
        data["Likeness"] = this.Likeness;
        data["UseCompanyAddr"] = this.UseCompanyAddr;
        data["ShowNewProjects"] = this.ShowNewProjects;
        data["sfUser"] = this.sfUser;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["SolomonUser"] = this.SolomonUser;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["PWMustChange"] = this.PWMustChange;
        data["PWAging"] = this.PWAging;
        data["DivisionID"] = this.DivisionID;
        data["LockoutReason"] = this.LockoutReason;
        data["OrgLevel"] = this.OrgLevel;
        data["SynchCheck"] = this.SynchCheck;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["LastLogin"] = this.LastLogin ? this.LastLogin.toISOString() : <any>undefined;
        data["LastPWChange"] = this.LastPWChange ? this.LastPWChange.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["IsPrimary"] = this.IsPrimary;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

/** Describes a contact */
export interface IContact {
    /** Key for this user/contact */
    UserKey?: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with international dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** External Contact ID (returns Vendor or Employee ID if that is the type, otherwise customer id  */
    ExternalID?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone?: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility?: string;
    /** Key to primary company */
    ContactCompanyKey?: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr?: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects?: boolean;
    /** When True, can log in to dashboard */
    sfUser?: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic?: boolean;
    /** When false, this row is ignored and ineffective */
    Active?: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser?: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration?: boolean;
    /** When TRUE, user must change password */
    PWMustChange?: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging?: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel?: number;
    /** Checksum of all externally syched data */
    SynchCheck?: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun?: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created?: Date;
    /** true when this is the primary company contact */
    IsPrimary?: boolean;
    /** eTag */
    ETag?: string | undefined;
}

/** A document currently routed to a specific user */
export class UserActionItem implements IUserActionItem {
    /** Key for the document */
    DocMasterKey!: string;
    /** key for the route on the document */
    RouteID?: string;
    /** key for the type of document */
    DocTypeKey?: string;
    /** Original key for the type of document */
    DocTypeKey_ov?: string;
    /** Same as DocType */
    DocTypeKey_dv?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Due Date */
    Due?: Date | undefined;
    /** Title */
    Title?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser?: string;
    /** Key for Primary contact on this document */
    PrimaryContact?: string;
    /** Priority (1=high) */
    Priority?: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this route was reaced */
    Reached?: Date;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Display value for Primary Contact  */
    PrimaryContact_dv?: string | undefined;
    /** Current Route Sequence */
    Sequence?: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease?: boolean;
    /** When True, is recent  */
    IsRecent?: boolean;
    /** How many files are attached */
    FilesAttached?: number;
    /** Project Name (Resolved from Project ID) */
    cmp_Project_Name?: string | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Route Instructions */
    Note?: string | undefined;
    /** eTag */
    ETag?: string | undefined;

    constructor(data?: IUserActionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.RouteID = _data["RouteID"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocTypeKey_ov = _data["DocTypeKey_ov"];
            this.DocTypeKey_dv = _data["DocTypeKey_dv"];
            this.Project = _data["Project"];
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Title = _data["Title"];
            this.FromUser = _data["FromUser"];
            this.PrimaryContact = _data["PrimaryContact"];
            this.Priority = _data["Priority"];
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.StatusText = _data["StatusText"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.PrimaryContact_dv = _data["PrimaryContact_dv"];
            this.Sequence = _data["Sequence"];
            this.OkToRelease = _data["OkToRelease"];
            this.IsRecent = _data["IsRecent"];
            this.FilesAttached = _data["FilesAttached"];
            this.cmp_Project_Name = _data["cmp_Project_Name"];
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Note = _data["Note"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): UserActionItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["RouteID"] = this.RouteID;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocTypeKey_ov"] = this.DocTypeKey_ov;
        data["DocTypeKey_dv"] = this.DocTypeKey_dv;
        data["Project"] = this.Project;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Title"] = this.Title;
        data["FromUser"] = this.FromUser;
        data["PrimaryContact"] = this.PrimaryContact;
        data["Priority"] = this.Priority;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["StatusText"] = this.StatusText;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["PrimaryContact_dv"] = this.PrimaryContact_dv;
        data["Sequence"] = this.Sequence;
        data["OkToRelease"] = this.OkToRelease;
        data["IsRecent"] = this.IsRecent;
        data["FilesAttached"] = this.FilesAttached;
        data["cmp_Project_Name"] = this.cmp_Project_Name;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Note"] = this.Note;
        data["ETag"] = this.ETag;
        return data;
    }

    clone(): UserActionItem {
        const json = this.toJSON();
        let result = new UserActionItem();
        result.init(json);
        return result;
    }
}

/** A document currently routed to a specific user */
export interface IUserActionItem {
    /** Key for the document */
    DocMasterKey: string;
    /** key for the route on the document */
    RouteID?: string;
    /** key for the type of document */
    DocTypeKey?: string;
    /** Original key for the type of document */
    DocTypeKey_ov?: string;
    /** Same as DocType */
    DocTypeKey_dv?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Due Date */
    Due?: Date | undefined;
    /** Title */
    Title?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser?: string;
    /** Key for Primary contact on this document */
    PrimaryContact?: string;
    /** Priority (1=high) */
    Priority?: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this route was reaced */
    Reached?: Date;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Display value for Primary Contact  */
    PrimaryContact_dv?: string | undefined;
    /** Current Route Sequence */
    Sequence?: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease?: boolean;
    /** When True, is recent  */
    IsRecent?: boolean;
    /** How many files are attached */
    FilesAttached?: number;
    /** Project Name (Resolved from Project ID) */
    cmp_Project_Name?: string | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Route Instructions */
    Note?: string | undefined;
    /** eTag */
    ETag?: string | undefined;
}

/** Route Action Item */
export class RouteActionInfo2 implements IRouteActionInfo2 {
    /** Key of document */
    DocMasterKey!: string;
    /** Name of User */
    UserName?: string | undefined;
    /** Title of document */
    Title?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Type of Document */
    Type?: string | undefined;
    /** Project */
    Project?: string | undefined;
    /** Status */
    Status?: string | undefined;
    /** Company
             */
    Company?: string | undefined;
    /** Document Priority */
    Priority?: number;
    /** Current Route sequence */
    Sequence?: number;
    /** When due */
    Due?: string | undefined;
    /** when first viewed */
    Viewed?: string | undefined;
    /** when a notification was sent */
    Alerted?: string | undefined;
    /** when content was downloaded */
    Downloaded?: string | undefined;
    /** when the prior route sequence was resolved (when this route sequence was reached) */
    FromActed?: string | undefined;
    /** Creator */
    CreatorActed?: string | undefined;
    /** Ok to release */
    OkToRelease?: boolean;
    /** The Route Response drop down is relevant */
    ShowRouteResponseCode?: boolean;
    /** The Route Response text area is relevant */
    ShowRouteResponseArea?: boolean;
    /** hard copy  */
    HardCopyCount?: number;
    /** how many are ok to release */
    OkToReleaseCount?: number;
    /** how many match */
    ReleaseMatchCount?: number;
    /** The Route Response code   */
    ResponseCode?: string | undefined;
    /** Note */
    Note?: string | undefined;
    /** Response (entered here) */
    Response?: string | undefined;
    /** Instructions to this person */
    Instructions?: string | undefined;
    /** Who from */
    FromWho?: string | undefined;
    /** who added this route */
    CreatedBy?: string | undefined;
    /** who is next */
    NextWho?: string | undefined;
    /** information about this document access history */
    AccessSummary?: string | undefined;
    /** URL to open detailed report of history */
    DocAccessHistoryReportURL?: string | undefined;
    /** when this document was last saved */
    LastSaved?: string | undefined;
    /** if not empty, who currently is working on the document */
    ExclusiveTo?: string | undefined;
    /** Key of document process type */
    DocTypeKey?: string;
    /** Status choices */
    StatusChoices?: SelectCodeNode[] | undefined;
    /** Response code choices */
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    /** docs that match */
    MatchingDocs?: SelectCodeNode[] | undefined;
    /** eligible docs */
    EligibleDocs?: SelectCodeNode[] | undefined;

    constructor(data?: IRouteActionInfo2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.UserName = _data["UserName"];
            this.Title = _data["Title"];
            this.DocNo = _data["DocNo"];
            this.Type = _data["Type"];
            this.Project = _data["Project"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.Priority = _data["Priority"];
            this.Sequence = _data["Sequence"];
            this.Due = _data["Due"];
            this.Viewed = _data["Viewed"];
            this.Alerted = _data["Alerted"];
            this.Downloaded = _data["Downloaded"];
            this.FromActed = _data["FromActed"];
            this.CreatorActed = _data["CreatorActed"];
            this.OkToRelease = _data["OkToRelease"];
            this.ShowRouteResponseCode = _data["ShowRouteResponseCode"];
            this.ShowRouteResponseArea = _data["ShowRouteResponseArea"];
            this.HardCopyCount = _data["HardCopyCount"];
            this.OkToReleaseCount = _data["OkToReleaseCount"];
            this.ReleaseMatchCount = _data["ReleaseMatchCount"];
            this.ResponseCode = _data["ResponseCode"];
            this.Note = _data["Note"];
            this.Response = _data["Response"];
            this.Instructions = _data["Instructions"];
            this.FromWho = _data["FromWho"];
            this.CreatedBy = _data["CreatedBy"];
            this.NextWho = _data["NextWho"];
            this.AccessSummary = _data["AccessSummary"];
            this.DocAccessHistoryReportURL = _data["DocAccessHistoryReportURL"];
            this.LastSaved = _data["LastSaved"];
            this.ExclusiveTo = _data["ExclusiveTo"];
            this.DocTypeKey = _data["DocTypeKey"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["MatchingDocs"])) {
                this.MatchingDocs = [] as any;
                for (let item of _data["MatchingDocs"])
                    this.MatchingDocs!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["EligibleDocs"])) {
                this.EligibleDocs = [] as any;
                for (let item of _data["EligibleDocs"])
                    this.EligibleDocs!.push(SelectCodeNode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteActionInfo2 {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionInfo2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["UserName"] = this.UserName;
        data["Title"] = this.Title;
        data["DocNo"] = this.DocNo;
        data["Type"] = this.Type;
        data["Project"] = this.Project;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["Priority"] = this.Priority;
        data["Sequence"] = this.Sequence;
        data["Due"] = this.Due;
        data["Viewed"] = this.Viewed;
        data["Alerted"] = this.Alerted;
        data["Downloaded"] = this.Downloaded;
        data["FromActed"] = this.FromActed;
        data["CreatorActed"] = this.CreatorActed;
        data["OkToRelease"] = this.OkToRelease;
        data["ShowRouteResponseCode"] = this.ShowRouteResponseCode;
        data["ShowRouteResponseArea"] = this.ShowRouteResponseArea;
        data["HardCopyCount"] = this.HardCopyCount;
        data["OkToReleaseCount"] = this.OkToReleaseCount;
        data["ReleaseMatchCount"] = this.ReleaseMatchCount;
        data["ResponseCode"] = this.ResponseCode;
        data["Note"] = this.Note;
        data["Response"] = this.Response;
        data["Instructions"] = this.Instructions;
        data["FromWho"] = this.FromWho;
        data["CreatedBy"] = this.CreatedBy;
        data["NextWho"] = this.NextWho;
        data["AccessSummary"] = this.AccessSummary;
        data["DocAccessHistoryReportURL"] = this.DocAccessHistoryReportURL;
        data["LastSaved"] = this.LastSaved;
        data["ExclusiveTo"] = this.ExclusiveTo;
        data["DocTypeKey"] = this.DocTypeKey;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.MatchingDocs)) {
            data["MatchingDocs"] = [];
            for (let item of this.MatchingDocs)
                data["MatchingDocs"].push(item.toJSON());
        }
        if (Array.isArray(this.EligibleDocs)) {
            data["EligibleDocs"] = [];
            for (let item of this.EligibleDocs)
                data["EligibleDocs"].push(item.toJSON());
        }
        return data;
    }

    clone(): RouteActionInfo2 {
        const json = this.toJSON();
        let result = new RouteActionInfo2();
        result.init(json);
        return result;
    }
}

/** Route Action Item */
export interface IRouteActionInfo2 {
    /** Key of document */
    DocMasterKey: string;
    /** Name of User */
    UserName?: string | undefined;
    /** Title of document */
    Title?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Type of Document */
    Type?: string | undefined;
    /** Project */
    Project?: string | undefined;
    /** Status */
    Status?: string | undefined;
    /** Company
             */
    Company?: string | undefined;
    /** Document Priority */
    Priority?: number;
    /** Current Route sequence */
    Sequence?: number;
    /** When due */
    Due?: string | undefined;
    /** when first viewed */
    Viewed?: string | undefined;
    /** when a notification was sent */
    Alerted?: string | undefined;
    /** when content was downloaded */
    Downloaded?: string | undefined;
    /** when the prior route sequence was resolved (when this route sequence was reached) */
    FromActed?: string | undefined;
    /** Creator */
    CreatorActed?: string | undefined;
    /** Ok to release */
    OkToRelease?: boolean;
    /** The Route Response drop down is relevant */
    ShowRouteResponseCode?: boolean;
    /** The Route Response text area is relevant */
    ShowRouteResponseArea?: boolean;
    /** hard copy  */
    HardCopyCount?: number;
    /** how many are ok to release */
    OkToReleaseCount?: number;
    /** how many match */
    ReleaseMatchCount?: number;
    /** The Route Response code   */
    ResponseCode?: string | undefined;
    /** Note */
    Note?: string | undefined;
    /** Response (entered here) */
    Response?: string | undefined;
    /** Instructions to this person */
    Instructions?: string | undefined;
    /** Who from */
    FromWho?: string | undefined;
    /** who added this route */
    CreatedBy?: string | undefined;
    /** who is next */
    NextWho?: string | undefined;
    /** information about this document access history */
    AccessSummary?: string | undefined;
    /** URL to open detailed report of history */
    DocAccessHistoryReportURL?: string | undefined;
    /** when this document was last saved */
    LastSaved?: string | undefined;
    /** if not empty, who currently is working on the document */
    ExclusiveTo?: string | undefined;
    /** Key of document process type */
    DocTypeKey?: string;
    /** Status choices */
    StatusChoices?: SelectCodeNode[] | undefined;
    /** Response code choices */
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    /** docs that match */
    MatchingDocs?: SelectCodeNode[] | undefined;
    /** eligible docs */
    EligibleDocs?: SelectCodeNode[] | undefined;
}

export class RouteActionInfo extends RouteActionInfo2 implements IRouteActionInfo {

    constructor(data?: IRouteActionInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RouteActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): RouteActionInfo {
        const json = this.toJSON();
        let result = new RouteActionInfo();
        result.init(json);
        return result;
    }
}

export interface IRouteActionInfo extends IRouteActionInfo2 {
}

/** Key value pair */
export class SelectCodeNode implements ISelectCodeNode {
    /** the key */
    Key?: string | undefined;
    /** the value */
    Value?: string | undefined;

    constructor(data?: ISelectCodeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Key = _data["Key"];
            this.Value = _data["Value"];
        }
    }

    static fromJS(data: any): SelectCodeNode {
        data = typeof data === 'object' ? data : {};
        let result = new SelectCodeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.Key;
        data["Value"] = this.Value;
        return data;
    }

    clone(): SelectCodeNode {
        const json = this.toJSON();
        let result = new SelectCodeNode();
        result.init(json);
        return result;
    }
}

/** Key value pair */
export interface ISelectCodeNode {
    /** the key */
    Key?: string | undefined;
    /** the value */
    Value?: string | undefined;
}

/** Data to apply to the route being patched */
export class RouteActionData implements IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc.  Use UNREAD for setting to unviewed) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;

    constructor(data?: IRouteActionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NewStatus = _data["NewStatus"];
            this.ResponseCode = _data["ResponseCode"];
            this.ResponseText = _data["ResponseText"];
        }
    }

    static fromJS(data: any): RouteActionData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewStatus"] = this.NewStatus;
        data["ResponseCode"] = this.ResponseCode;
        data["ResponseText"] = this.ResponseText;
        return data;
    }

    clone(): RouteActionData {
        const json = this.toJSON();
        let result = new RouteActionData();
        result.init(json);
        return result;
    }
}

/** Data to apply to the route being patched */
export interface IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc.  Use UNREAD for setting to unviewed) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
