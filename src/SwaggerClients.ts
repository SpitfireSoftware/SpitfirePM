/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as jQuery from 'jquery';

export class ProjectsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns projects that match User and hidden filter
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param includeHidden True to include hidden projects in the result
     */
    getList(forUserKey: string, includeHidden: boolean) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getListWithCallbacks(forUserKey, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getListWithCallbacks(forUserKey: string, includeHidden: boolean, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that match User, Program, hidden filter
     */
    getMatchingList(usingFilters: QueryFilters) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getMatchingListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingListWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ContactClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns contacts that match filters
     * @param usingFilters Search Criteria
     */
    matchingContactList(usingFilters: ContactFilters) {
        return new Promise<ContactSummary[] | null>((resolve, reject) => {
            this.matchingContactListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingContactListWithCallbacks(usingFilters: ContactFilters, onSuccess?: (result: ContactSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingContactListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingContactList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingContactList(xhr: any): ContactSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the contact
     * @param id Contact Key
     */
    getContact(id: string) {
        return new Promise<Contact | null>((resolve, reject) => {
            this.getContactWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getContactWithCallbacks(id: string, onSuccess?: (result: Contact | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetContact(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetContact(xhr: any): Contact | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class LookupClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResultAll(lookupName: string, dataContext: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultAllWithCallbacks(lookupName, dataContext, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultAllWithCallbacks(lookupName: string, dataContext: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResultAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResultAll(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultWithCallbacks(lookupName, dataContext, depends1, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultWithCallbacks(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult2(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult2WithCallbacks(lookupName, dataContext, depends1, depends2, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult2(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult3(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult3WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult3WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult3WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult3(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult3(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of matches for a specified lookup and context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult4(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult4WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult4WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult4WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult4WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult4WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult4(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult4(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestionsAll(lookupName: string, dataContext: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsAllWithCallbacks(lookupName, dataContext, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsAllWithCallbacks(lookupName: string, dataContext: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestionsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsAll(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions(lookupName: string, dataContext: string, depends1: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithCallbacks(lookupName, dataContext, depends1, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithCallbacks(lookupName: string, dataContext: string, depends1: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions2(lookupName: string, dataContext: string, depends1: string, depends2: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions2WithCallbacks(lookupName, dataContext, depends1, depends2, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions2(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions3(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions3WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions3WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions3WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions3WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions3WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions3(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions3(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions4(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions4WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions4WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions4WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions4WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions4WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions4(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions4(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns viewable/printable value
     * @param displayName Name of Display Rule
     * @param dataContext Context for Suggestions, use 1 for default
     * @param dataValue Value to be described
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     */
    getDisplayValue(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDisplayValueWithCallbacks(displayName, dataContext, dataValue, depends1, depends2, depends3, depends4, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayValueWithCallbacks(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}/{dataContext}/{dataValue}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (dataValue === undefined || dataValue === null)
            throw new Error("The parameter 'dataValue' must be defined.");
        url_ = url_.replace("{dataValue}", encodeURIComponent("" + dataValue));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDisplayValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayValue(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of choices for a specified context
     * @param setName Name of Code Set
     * @param forDocType Document / Process Context for choices, use 1 for default
     */
    getCodeChoices(setName: string, forDocType: string) {
        return new Promise<CodeChoice[] | null>((resolve, reject) => {
            this.getCodeChoicesWithCallbacks(setName, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCodeChoicesWithCallbacks(setName: string, forDocType: string, onSuccess?: (result: CodeChoice[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/choices/{setName}/{forDocType}";
        if (setName === undefined || setName === null)
            throw new Error("The parameter 'setName' must be defined.");
        url_ = url_.replace("{setName}", encodeURIComponent("" + setName));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined.");
        url_ = url_.replace("{forDocType}", encodeURIComponent("" + forDocType));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCodeChoicesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCodeChoices(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCodeChoices(xhr: any): CodeChoice[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeChoice.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class DocumentToolsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocWorkflowLog(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocWorkflowLogWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocWorkflowLogWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/workflow/log/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocWorkflowLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocWorkflowLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocWorkflowLog(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the Document Session Key
     * @param id Document Key
     */
    getDocSession(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocSessionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocSessionWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocSession(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the specified session exists for the current user, associates the Document and Session Key
     * @param id Document Key
     * @param sessionID session id
     */
    patchDocSession(id: string, sessionID: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocSessionWithCallbacks(id, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocSessionWithCallbacks(id: string, sessionID: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/session/{id}/{sessionID}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocSession(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocHeader(id: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeaderWithCallbacks(id: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document revision, including a Document Session Key
     * @param id Document Key
     * @param revKey Revision Key
     */
    getDocHeader2(id: string, revKey: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeader2WithCallbacks(id, revKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeader2WithCallbacks(id: string, revKey: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{revKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revKey === undefined || revKey === null)
            throw new Error("The parameter 'revKey' must be defined.");
        url_ = url_.replace("{revKey}", encodeURIComponent("" + revKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeader2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader2(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocItems(id: string) {
        return new Promise<DocItem[] | null>((resolve, reject) => {
            this.getDocItemsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemsWithCallbacks(id: string, onSuccess?: (result: DocItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItems(xhr: any): DocItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AccountClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Authenticates a session and generates a FormsAuthenticationTicket and cookie
     */
    postLogin(credentials: SiteLogin) {
        return new Promise<string | null>((resolve, reject) => {
            this.postLoginWithCallbacks(credentials, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postLoginWithCallbacks(credentials: SiteLogin, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostLoginWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostLogin(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general information about the Authenticed user
     */
    getUserData() {
        return new Promise<CurrentUser | null>((resolve, reject) => {
            this.getUserDataWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserDataWithCallbacks(onSuccess?: (result: CurrentUser | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserData(xhr: any): CurrentUser | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUser.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns authorization flags for specified demand if they match or exceed the request
     * @param demand Demand Context
     */
    getAccess(demand: PermissionContext) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getAccessWithCallbacks(demand, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getAccessWithCallbacks(demand: PermissionContext, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Authorized";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(demand);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetAccessWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetAccess(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetAccess(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    acquireTabList() {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.acquireTabListWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private acquireTabListWithCallbacks(onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAcquireTabListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAcquireTabListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAcquireTabListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAcquireTabList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAcquireTabList(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class Client {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    returns_information_about_password_composition() {
        return new Promise<PasswordConfiguredOptions | null>((resolve, reject) => {
            this.returns_information_about_password_compositionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private returns_information_about_password_compositionWithCallbacks(onSuccess?: (result: PasswordConfiguredOptions | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/PasswordOptions";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReturns_information_about_password_compositionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReturns_information_about_password_compositionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReturns_information_about_password_compositionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processReturns_information_about_password_composition(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReturns_information_about_password_composition(xhr: any): PasswordConfiguredOptions | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PasswordConfiguredOptions.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class SessionClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of permissions for a project
     * @param projectID Project ID
     */
    getProjectPermits(projectID: string) {
        return new Promise<UCPermitSet | null>((resolve, reject) => {
            this.getProjectPermitsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitsWithCallbacks(projectID: string, onSuccess?: (result: UCPermitSet | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/project/{projectID}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermits(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermits(xhr: any): UCPermitSet | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UCPermitSet.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions by Module | Function
     * @param eTag (optional) Returns nothing if eTag matches supplied eTab
     */
    getProjectPermitNameMap(eTag: string | null | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectPermitNameMapWithCallbacks(eTag, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitNameMapWithCallbacks(eTag: string | null | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/map?";
        if (eTag !== undefined && eTag !== null)
            url_ += "eTag=" + encodeURIComponent("" + eTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitNameMapWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermitNameMap(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermitNameMap(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WCC Session data
     */
    getWCC() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getWCCWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getWCCWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/who";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetWCCWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetWCC(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetWCC(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param forTabType (optional) optional tab type (project,other, otheruser,blank for all)
     */
    getSessionTabs(forTabType: string | null | undefined) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getSessionTabsWithCallbacks(forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabsWithCallbacks(forTabType: string | null | undefined, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSessionTabs(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Logs the posted data
     * @param logData Information to be logged
     */
    postToWebAppLog(logData: APIData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postToWebAppLogWithCallbacks(logData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postToWebAppLogWithCallbacks(logData: APIData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostToWebAppLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostToWebAppLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostToWebAppLog(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Patches the value in the indicated resource
     * @param tableName table
     * @param fieldName field
     * @param changeData Change information
     */
    patchFieldValue(tableName: string, fieldName: string, changeData: PDSData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchFieldValueWithCallbacks(tableName, fieldName, changeData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchFieldValueWithCallbacks(tableName: string, fieldName: string, changeData: PDSData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/value/{tableName}/{fieldName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchFieldValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchFieldValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchFieldValue(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectTeamClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns members of the specified project team
     * @param projectID Full Project ID
     * @param includeHidden True to include hidden projects
     */
    getProjectTeamList(projectID: string, includeHidden: boolean) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.getProjectTeamListWithCallbacks(projectID, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectTeamListWithCallbacks(projectID: string, includeHidden: boolean, onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectTeamListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectTeamList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectTeamList(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class CatalogClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a history of access to the specified ID
     * @param iD Catalog File Key
     */
    getCatalogAccessHistory(iD: string) {
        return new Promise<FileAccessHistory[] | null>((resolve, reject) => {
            this.getCatalogAccessHistoryWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogAccessHistoryWithCallbacks(iD: string, onSuccess?: (result: FileAccessHistory[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/AccessHistory";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogAccessHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogAccessHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogAccessHistory(xhr: any): FileAccessHistory[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileAccessHistory.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list of versions for the specified ID
     * @param iD Catalog File Key
     */
    getCatalogVersions(iD: string) {
        return new Promise<FileVersion[] | null>((resolve, reject) => {
            this.getCatalogVersionsWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogVersionsWithCallbacks(iD: string, onSuccess?: (result: FileVersion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/versions";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogVersionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogVersions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogVersions(xhr: any): FileVersion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileVersion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ActionItemsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns action items for specified User
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserActionItemsAll(forUserKey: string) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getUserActionItemsAllWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsAllWithCallbacks(forUserKey: string, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItemsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItemsAll(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns action items that match filters ProjectLike, TitleLike, ForDocType, FromDate, ThruDate, NewOnly
     */
    getMatchingUserActionItems(usingFilters: QueryFilters) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getMatchingUserActionItemsWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingUserActionItemsWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/matching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingUserActionItems(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     */
    getUserActionItems(userID: string, routeID: string) {
        return new Promise<RouteActionInfo | null>((resolve, reject) => {
            this.getUserActionItemsWithCallbacks(userID, routeID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsWithCallbacks(userID: string, routeID: string, onSuccess?: (result: RouteActionInfo | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItems(xhr: any): RouteActionInfo | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result500);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Requested route not found", status, _responseText, _headers, result404);
        } else if (status === 503) {
            const _responseText = xhr.responseText;
            let result503: any = null;
            let resultData503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result503 = resultData503 !== undefined ? resultData503 : <any>null;
            return throwException("Try again after reauthentication", status, _responseText, _headers, result503);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RouteActionInfo.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     * @param actionData action is patch data
     * @param actionMode (optional) Mode is id,match,every
     */
    patchUserActionItems(userID: string, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchUserActionItemsWithCallbacks(userID, routeID, actionData, actionMode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserActionItemsWithCallbacks(userID: string, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}?";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        if (actionMode !== undefined && actionMode !== null)
            url_ += "actionMode=" + encodeURIComponent("" + actionMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserActionItems(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectDocListClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a summary of document processes on a project
     * @param projectID Full Project ID
     */
    getProjectDocSummary(projectID: string) {
        return new Promise<TypeSummary[] | null>((resolve, reject) => {
            this.getProjectDocSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocSummaryWithCallbacks(projectID: string, onSuccess?: (result: TypeSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/TypeSummary";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocSummary(xhr: any): TypeSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match the requested document type
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     */
    getProjectDocList(projectID: string, forDocType: string) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.getProjectDocListWithCallbacks(projectID, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocListWithCallbacks(projectID: string, forDocType: string, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match filters <b>INCOMPLETE</b>
     */
    matchingProjectDocList(projectID: string, usingFilters: QueryFilters) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.matchingProjectDocListWithCallbacks(projectID, usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingProjectDocListWithCallbacks(projectID: string, usingFilters: QueryFilters, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AlertsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns alert items for a specified user
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserAlertList(forUserKey: string) {
        return new Promise<UserAlert[] | null>((resolve, reject) => {
            this.getUserAlertListWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserAlertListWithCallbacks(forUserKey: string, onSuccess?: (result: UserAlert[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserAlertListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserAlertList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserAlertList(xhr: any): UserAlert[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAlert.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates and stores an alert
     * @param theAlert Model with new alert. Specify AlertText, Description.  UserKey, DocMasterKey, Project, Source, SourceKey and Info1 are optional;
     */
    createAlert(theAlert: UserAlert) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.createAlertWithCallbacks(theAlert, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createAlertWithCallbacks(theAlert: UserAlert, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(theAlert);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processCreateAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes all alert item for the specified user
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAllAlerts(forUserKey: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAllAlertsWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAllAlertsWithCallbacks(forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/all?";
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAllAlertsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAllAlerts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAllAlerts(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes a specific alert item for the specified user
     * @param id Alert Key
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAlert(id: string, forUserKey: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAlertWithCallbacks(id, forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAlertWithCallbacks(id: string, forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("key not found", status, _responseText, _headers, result404);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UICFGClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param partName Part Name
     * @param forDocType (optional) optional document type (guid format)
     * @param forContext (optional) optional context (subtype, container, etc)
     */
    getLiveDisplay(partName: string, forDocType: string | null | undefined, forContext: string | null | undefined) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLiveDisplayWithCallbacks(partName, forDocType, forContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLiveDisplayWithCallbacks(partName: string, forDocType: string | null | undefined, forContext: string | null | undefined, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/live/{partName}?";
        if (partName === undefined || partName === null)
            throw new Error("The parameter 'partName' must be defined.");
        url_ = url_.replace("{partName}", encodeURIComponent("" + partName));
        if (forDocType !== undefined && forDocType !== null)
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        if (forContext !== undefined && forContext !== null)
            url_ += "forContext=" + encodeURIComponent("" + forContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLiveDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLiveDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLiveDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param lookupName Part Name
     */
    getLookupDisplay(lookupName: string) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLookupDisplayWithCallbacks(lookupName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupDisplayWithCallbacks(lookupName: string, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/lookup/{lookupName}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectKPIClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of KPI facts for the specified project
     * @param projectID Full Project ID
     */
    getProjectKPIFacts(projectID: string) {
        return new Promise<ProjKPIFact[] | null>((resolve, reject) => {
            this.getProjectKPIFactsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectKPIFactsWithCallbacks(projectID: string, onSuccess?: (result: ProjKPIFact[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/KPI";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectKPIFactsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectKPIFacts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectKPIFacts(xhr: any): ProjKPIFact[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjKPIFact.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectToolsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a summary overview of the specified project
     * @param projectID Full Project ID
     */
    getProjectDetail(projectID: string) {
        return new Promise<ProjectAbstract | null>((resolve, reject) => {
            this.getProjectDetailWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDetailWithCallbacks(projectID: string, onSuccess?: (result: ProjectAbstract | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Abstract";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDetailWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDetail(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDetail(xhr: any): ProjectAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectAbstract.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that link to the specified project
     * @param projectID Full Project ID
     */
    getProjectLinks(projectID: string) {
        return new Promise<ProjectLink[] | null>((resolve, reject) => {
            this.getProjectLinksWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectLinksWithCallbacks(projectID: string, onSuccess?: (result: ProjectLink[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Links";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectLinks(xhr: any): ProjectLink[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectLink.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCost(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getProjectCostWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Costs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCost(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCostFooters(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectCostFootersWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostFootersWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/CostSummary?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostFootersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostFooters(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostFooters(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns recent weather reading at the specified project site
     * @param projectID Full Project ID
     */
    getProjectWeatherReading(projectID: string) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.getProjectWeatherReadingWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherReadingWithCallbacks(projectID: string, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherReading";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherReadingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherReading(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherReading(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    weatherDataWorker(thisProjectDetail: ProjectAbstract) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.weatherDataWorkerWithCallbacks(thisProjectDetail, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private weatherDataWorkerWithCallbacks(thisProjectDetail: ProjectAbstract, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/ProjectTools";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(thisProjectDetail);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processWeatherDataWorkerWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processWeatherDataWorkerWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processWeatherDataWorkerWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processWeatherDataWorker(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processWeatherDataWorker(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns history of weather readings at the specified project site INCOMPLETE
     * @param projectID Full Project ID
     */
    getProjectWeatherHistory(projectID: string) {
        return new Promise<WeatherAtLocation[] | null>((resolve, reject) => {
            this.getProjectWeatherHistoryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherHistoryWithCallbacks(projectID: string, onSuccess?: (result: WeatherAtLocation[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherHistory";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherHistory(xhr: any): WeatherAtLocation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAtLocation.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns current note for the specified project
     * @param projectID Full Project ID
     */
    getProjectNote(projectID: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getProjectNoteWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNoteWithCallbacks(projectID: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNote(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Sets project note INCOMPLETE!!!
     * @param projectID Full Project ID
     */
    newProjectNote(projectID: string, newNote: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.newProjectNoteWithCallbacks(projectID, newNote, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private newProjectNoteWithCallbacks(projectID: string, newNote: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newNote);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processNewProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processNewProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processNewProjectNote(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns all notes for the specified project
     * @param projectID Full Project ID
     */
    getProjectNotes(projectID: string) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getProjectNotesWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNotesWithCallbacks(projectID: string, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Notes";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNotesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNotes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNotes(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns transactions that detail costs on the project
     * @param projectID Full Project ID
     * @param forWBS (optional) Cost Code Like
     * @param forAccount (optional) Account Catagory
     * @param forAccountType (optional) Account Catagory Type (RV,EX,%)
     * @param forAccountClass (optional) Account Catagory Class (L,LB,M,O,P)
     * @param forPeriod (optional) Fiscal Period
     * @param fromDate (optional) From Date
     * @param thruDate (optional) Thru Date
     * @param refDMK (optional) Reference Document
     * @param refVendor (optional) Reference Vendor ID (or Contact Key)
     */
    getProjectCostTransactions(projectID: string, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined) {
        return new Promise<ProjectTranDetail[] | null>((resolve, reject) => {
            this.getProjectCostTransactionsWithCallbacks(projectID, forWBS, forAccount, forAccountType, forAccountClass, forPeriod, fromDate, thruDate, refDMK, refVendor, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostTransactionsWithCallbacks(projectID: string, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined, onSuccess?: (result: ProjectTranDetail[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cost/transactions?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forWBS !== undefined && forWBS !== null)
            url_ += "forWBS=" + encodeURIComponent("" + forWBS) + "&";
        if (forAccount !== undefined && forAccount !== null)
            url_ += "forAccount=" + encodeURIComponent("" + forAccount) + "&";
        if (forAccountType !== undefined && forAccountType !== null)
            url_ += "forAccountType=" + encodeURIComponent("" + forAccountType) + "&";
        if (forAccountClass !== undefined && forAccountClass !== null)
            url_ += "forAccountClass=" + encodeURIComponent("" + forAccountClass) + "&";
        if (forPeriod !== undefined && forPeriod !== null)
            url_ += "forPeriod=" + encodeURIComponent("" + forPeriod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (thruDate !== undefined && thruDate !== null)
            url_ += "thruDate=" + encodeURIComponent("" + thruDate) + "&";
        if (refDMK !== undefined && refDMK !== null)
            url_ += "refDMK=" + encodeURIComponent("" + refDMK) + "&";
        if (refVendor !== undefined && refVendor !== null)
            url_ += "refVendor=" + encodeURIComponent("" + refVendor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostTransactionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostTransactions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostTransactions(xhr: any): ProjectTranDetail[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTranDetail.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

/** Primary Summary */
export class ProjectSummary implements IProjectSummary {
    /** Project ID */
    project!: string;
    /** Project Name */
    projectName?: string | undefined;
    /** Site Address Line 1 */
    addr1?: string | undefined;
    /** Site Address Line 2 */
    addr2?: string | undefined;
    /** Site Address City */
    city?: string | undefined;
    /** Site Address State */
    state?: string | undefined;
    /** Site Address Zip */
    zip?: string | undefined;
    /** County */
    county?: string | undefined;
    /** Description from Project Setup Scope */
    description?: string | undefined;
    /** Resolved Status */
    statusText?: string | undefined;
    /** External Status from Project Setup Tab */
    externalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    externalSchedule?: string | undefined;
    /** Person on Site Address */
    person?: string | undefined;
    /** Company */
    company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude!: number;
    /** Geo longitude from Project Setup Tab */
    longitude!: number;
    /** Start Date from Project Setup Dates tab */
    startDate!: Date;
    /** Finish Date from Project Setup Dates tab */
    finishDate!: Date;
    /** Key for this user on project team */
    userProjectKey!: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    sourceContact!: string;
    /** Key for Image */
    imageKey!: string;
    /** TRUE if this project is on the user list */
    userList!: boolean;

    constructor(data?: IProjectSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["Project"];
            this.projectName = _data["ProjectName"];
            this.addr1 = _data["Addr1"];
            this.addr2 = _data["Addr2"];
            this.city = _data["City"];
            this.state = _data["State"];
            this.zip = _data["Zip"];
            this.county = _data["County"];
            this.description = _data["Description"];
            this.statusText = _data["StatusText"];
            this.externalStatus = _data["ExternalStatus"];
            this.externalSchedule = _data["ExternalSchedule"];
            this.person = _data["Person"];
            this.company = _data["Company"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.startDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
            this.finishDate = _data["FinishDate"] ? new Date(_data["FinishDate"].toString()) : <any>undefined;
            this.userProjectKey = _data["UserProjectKey"];
            this.sourceContact = _data["SourceContact"];
            this.imageKey = _data["ImageKey"];
            this.userList = _data["UserList"];
        }
    }

    static fromJS(data: any): ProjectSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.project;
        data["ProjectName"] = this.projectName;
        data["Addr1"] = this.addr1;
        data["Addr2"] = this.addr2;
        data["City"] = this.city;
        data["State"] = this.state;
        data["Zip"] = this.zip;
        data["County"] = this.county;
        data["Description"] = this.description;
        data["StatusText"] = this.statusText;
        data["ExternalStatus"] = this.externalStatus;
        data["ExternalSchedule"] = this.externalSchedule;
        data["Person"] = this.person;
        data["Company"] = this.company;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["FinishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["UserProjectKey"] = this.userProjectKey;
        data["SourceContact"] = this.sourceContact;
        data["ImageKey"] = this.imageKey;
        data["UserList"] = this.userList;
        return data; 
    }

    clone(): ProjectSummary {
        const json = this.toJSON();
        let result = new ProjectSummary();
        result.init(json);
        return result;
    }
}

/** Primary Summary */
export interface IProjectSummary {
    /** Project ID */
    project: string;
    /** Project Name */
    projectName?: string | undefined;
    /** Site Address Line 1 */
    addr1?: string | undefined;
    /** Site Address Line 2 */
    addr2?: string | undefined;
    /** Site Address City */
    city?: string | undefined;
    /** Site Address State */
    state?: string | undefined;
    /** Site Address Zip */
    zip?: string | undefined;
    /** County */
    county?: string | undefined;
    /** Description from Project Setup Scope */
    description?: string | undefined;
    /** Resolved Status */
    statusText?: string | undefined;
    /** External Status from Project Setup Tab */
    externalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    externalSchedule?: string | undefined;
    /** Person on Site Address */
    person?: string | undefined;
    /** Company */
    company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude: number;
    /** Geo longitude from Project Setup Tab */
    longitude: number;
    /** Start Date from Project Setup Dates tab */
    startDate: Date;
    /** Finish Date from Project Setup Dates tab */
    finishDate: Date;
    /** Key for this user on project team */
    userProjectKey: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    sourceContact: string;
    /** Key for Image */
    imageKey: string;
    /** TRUE if this project is on the user list */
    userList: boolean;
}

/** Various common filters - not every filter is supported by every query */
export class QueryFilters implements IQueryFilters {
    /** Project Mask (eg GC%) */
    projectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    titleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    userKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    forDocType?: string | undefined;
    /** Key for Program or empty key */
    programKey?: string | undefined;
    /** Default 2000-01-01 */
    fromDate?: Date | undefined;
    /** Default today */
    thruDate?: Date | undefined;
    /** Default is false */
    newOnly!: boolean;
    /** Default is false */
    includeHidden!: boolean;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;

    constructor(data?: IQueryFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectLike = _data["ProjectLike"];
            this.titleLike = _data["TitleLike"];
            this.userKey = _data["UserKey"];
            this.forDocType = _data["ForDocType"];
            this.programKey = _data["ProgramKey"];
            this.fromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.thruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
            this.newOnly = _data["NewOnly"];
            this.includeHidden = _data["IncludeHidden"];
            this.nvpFilters = _data["nvpFilters"];
        }
    }

    static fromJS(data: any): QueryFilters {
        data = typeof data === 'object' ? data : {};
        let result = new QueryFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectLike"] = this.projectLike;
        data["TitleLike"] = this.titleLike;
        data["UserKey"] = this.userKey;
        data["ForDocType"] = this.forDocType;
        data["ProgramKey"] = this.programKey;
        data["FromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.thruDate ? this.thruDate.toISOString() : <any>undefined;
        data["NewOnly"] = this.newOnly;
        data["IncludeHidden"] = this.includeHidden;
        data["nvpFilters"] = this.nvpFilters;
        return data; 
    }

    clone(): QueryFilters {
        const json = this.toJSON();
        let result = new QueryFilters();
        result.init(json);
        return result;
    }
}

/** Various common filters - not every filter is supported by every query */
export interface IQueryFilters {
    /** Project Mask (eg GC%) */
    projectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    titleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    userKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    forDocType?: string | undefined;
    /** Key for Program or empty key */
    programKey?: string | undefined;
    /** Default 2000-01-01 */
    fromDate?: Date | undefined;
    /** Default today */
    thruDate?: Date | undefined;
    /** Default is false */
    newOnly: boolean;
    /** Default is false */
    includeHidden: boolean;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;
}

/** Summary information about a contact */
export class ContactSummary implements IContactSummary {
    /** Link to user/contact */
    userKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    userName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    sortName?: string | undefined;
    /** Standard SMTP Email Address */
    email?: string | undefined;
    /** Which phone is preferred */
    usePhone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser!: boolean;
    /** Emp, Vendor, Customer, Standard */
    contactType?: string | undefined;
    /** Bit coded  */
    contactFlags!: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    externalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    cSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    active!: boolean;
    /** When true, there are no references to this contact */
    okToDelete!: boolean;
    /** When true, this contact came from an external source */
    isXTS!: boolean;
    /** When true, external changes to this contact are currently ignored */
    xTSBlockIn!: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    xTSBlockOut!: boolean;
    /** When true, this is the company contact - not a person at the company */
    isPrimary!: boolean;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userKey = _data["UserKey"];
            this.userName = _data["UserName"];
            this.sortName = _data["SortName"];
            this.email = _data["Email"];
            this.usePhone = _data["UsePhone"];
            this.fax = _data["Fax"];
            this.sfUser = _data["sfUser"];
            this.contactType = _data["ContactType"];
            this.contactFlags = _data["ContactFlags"];
            this.externalID = _data["ExternalID"];
            this.company = _data["Company"];
            this.cSIList = _data["CSIList"];
            this.active = _data["Active"];
            this.okToDelete = _data["OkToDelete"];
            this.isXTS = _data["IsXTS"];
            this.xTSBlockIn = _data["XTSBlockIn"];
            this.xTSBlockOut = _data["XTSBlockOut"];
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.userKey;
        data["UserName"] = this.userName;
        data["SortName"] = this.sortName;
        data["Email"] = this.email;
        data["UsePhone"] = this.usePhone;
        data["Fax"] = this.fax;
        data["sfUser"] = this.sfUser;
        data["ContactType"] = this.contactType;
        data["ContactFlags"] = this.contactFlags;
        data["ExternalID"] = this.externalID;
        data["Company"] = this.company;
        data["CSIList"] = this.cSIList;
        data["Active"] = this.active;
        data["OkToDelete"] = this.okToDelete;
        data["IsXTS"] = this.isXTS;
        data["XTSBlockIn"] = this.xTSBlockIn;
        data["XTSBlockOut"] = this.xTSBlockOut;
        data["IsPrimary"] = this.isPrimary;
        return data; 
    }

    clone(): ContactSummary {
        const json = this.toJSON();
        let result = new ContactSummary();
        result.init(json);
        return result;
    }
}

/** Summary information about a contact */
export interface IContactSummary {
    /** Link to user/contact */
    userKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    userName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    sortName?: string | undefined;
    /** Standard SMTP Email Address */
    email?: string | undefined;
    /** Which phone is preferred */
    usePhone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser: boolean;
    /** Emp, Vendor, Customer, Standard */
    contactType?: string | undefined;
    /** Bit coded  */
    contactFlags: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    externalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    cSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    active: boolean;
    /** When true, there are no references to this contact */
    okToDelete: boolean;
    /** When true, this contact came from an external source */
    isXTS: boolean;
    /** When true, external changes to this contact are currently ignored */
    xTSBlockIn: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    xTSBlockOut: boolean;
    /** When true, this is the company contact - not a person at the company */
    isPrimary: boolean;
}

/** Various filters for contact search */
export class ContactFilters implements IContactFilters {
    /** Name like */
    nameLike?: string | undefined;
    /** Email  */
    emailLike?: string | undefined;
    /** Company like  */
    companyLike?: string | undefined;
    /** Location */
    locationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    iDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    cSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    phoneLike?: string | undefined;
    /** When true, result is limited to  */
    users!: boolean;
    /** When true, result is limited to  */
    customers!: boolean;
    /** When true, result is limited to  */
    employee!: boolean;
    /** When true, result is limited to  */
    public!: boolean;
    /** When true, result is limited to primary company contacts  */
    company!: boolean;
    /** When true, result is limited to  */
    vendors!: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    contactState!: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    roleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    userKey?: string | undefined;
    /** Default 2000-01-01 */
    fromDate?: Date | undefined;
    /** Default today */
    thruDate?: Date | undefined;

    constructor(data?: IContactFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameLike = _data["NameLike"];
            this.emailLike = _data["EmailLike"];
            this.companyLike = _data["CompanyLike"];
            this.locationLike = _data["LocationLike"];
            this.iDLike = _data["IDLike"];
            this.cSIListLike = _data["CSIListLike"];
            this.phoneLike = _data["PhoneLike"];
            this.users = _data["Users"];
            this.customers = _data["Customers"];
            this.employee = _data["Employee"];
            this.public = _data["Public"];
            this.company = _data["Company"];
            this.vendors = _data["Vendors"];
            this.contactState = _data["ContactState"];
            this.roleKey = _data["RoleKey"];
            this.userKey = _data["UserKey"];
            this.fromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.thruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactFilters {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NameLike"] = this.nameLike;
        data["EmailLike"] = this.emailLike;
        data["CompanyLike"] = this.companyLike;
        data["LocationLike"] = this.locationLike;
        data["IDLike"] = this.iDLike;
        data["CSIListLike"] = this.cSIListLike;
        data["PhoneLike"] = this.phoneLike;
        data["Users"] = this.users;
        data["Customers"] = this.customers;
        data["Employee"] = this.employee;
        data["Public"] = this.public;
        data["Company"] = this.company;
        data["Vendors"] = this.vendors;
        data["ContactState"] = this.contactState;
        data["RoleKey"] = this.roleKey;
        data["UserKey"] = this.userKey;
        data["FromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.thruDate ? this.thruDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ContactFilters {
        const json = this.toJSON();
        let result = new ContactFilters();
        result.init(json);
        return result;
    }
}

/** Various filters for contact search */
export interface IContactFilters {
    /** Name like */
    nameLike?: string | undefined;
    /** Email  */
    emailLike?: string | undefined;
    /** Company like  */
    companyLike?: string | undefined;
    /** Location */
    locationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    iDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    cSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    phoneLike?: string | undefined;
    /** When true, result is limited to  */
    users: boolean;
    /** When true, result is limited to  */
    customers: boolean;
    /** When true, result is limited to  */
    employee: boolean;
    /** When true, result is limited to  */
    public: boolean;
    /** When true, result is limited to primary company contacts  */
    company: boolean;
    /** When true, result is limited to  */
    vendors: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    contactState: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    roleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    userKey?: string | undefined;
    /** Default 2000-01-01 */
    fromDate?: Date | undefined;
    /** Default today */
    thruDate?: Date | undefined;
}

/** Describes a contact */
export class Contact implements IContact {
    /** Key for this user/contact */
    userKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    userName?: string | undefined;
    /** Login name */
    userLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    federatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    sortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    familiarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    salutation?: string | undefined;
    /** Short description */
    title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    role?: string | undefined;
    /** Standard SMTP Email Address */
    eMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    county?: string | undefined;
    /** EST, PST, etc */
    timeZone?: string | undefined;
    /** Instant Messaging Service */
    iMService?: string | undefined;
    /** Instant Messaging Handle */
    iMHandle?: string | undefined;
    /** URL */
    webURL?: string | undefined;
    /** Vendor Company ID */
    vendorID?: string | undefined;
    /** Weak link to Solomon */
    employeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    contactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    routeVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    showPhone!: number;
    /** Key to role that defines who can proxy for this contact */
    routeeProxy?: string | undefined;
    /** A role with a responsibility */
    defaultResponsibility!: string;
    /** Key to primary company */
    contactCompanyKey!: string;
    /** HTML Markup for signature in templates */
    signature?: string | undefined;
    /** Key to file in catalog that contains image */
    likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    useCompanyAddr!: boolean;
    /** When true, new projects are added to the dashboard automatically */
    showNewProjects!: boolean;
    /** When True, can log in to dashboard */
    sfUser!: boolean;
    /** When true, this contact is included in lookups  */
    isPublic!: boolean;
    /** When false, this row is ignored and ineffective */
    active!: boolean;
    /** When true, is also an integrated DSL User */
    solomonUser!: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    slidingExpiration!: boolean;
    /** When TRUE, user must change password */
    pWMustChange!: boolean;
    /** When TRUE, user can be locked out because of password age */
    pWAging!: boolean;
    /** Company Division ID */
    divisionID?: string | undefined;
    /** Why user has been blocked */
    lockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    orgLevel!: number;
    /** Checksum of all externally syched data */
    synchCheck!: number;
    /** Number of consecutive login failures (reset upon success) */
    failedLoginRun!: number;
    /** Email notifications suppressed until this time */
    suppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    lastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    lastPWChange?: Date | undefined;
    /** User cannot login until this time */
    lockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    created!: Date;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userKey = _data["UserKey"];
            this.userName = _data["UserName"];
            this.userLogin = _data["UserLogin"];
            this.federatedIdentityInfo = _data["FederatedIdentityInfo"];
            this.sortName = _data["SortName"];
            this.familiarName = _data["FamiliarName"];
            this.salutation = _data["Salutation"];
            this.title = _data["Title"];
            this.role = _data["Role"];
            this.eMail = _data["EMail"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.cell = _data["cell"];
            this.pager = _data["pager"];
            this.company = _data["Company"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.country = _data["Country"];
            this.county = _data["County"];
            this.timeZone = _data["TimeZone"];
            this.iMService = _data["IMService"];
            this.iMHandle = _data["IMHandle"];
            this.webURL = _data["WebURL"];
            this.vendorID = _data["VendorID"];
            this.employeeID = _data["EmployeeID"];
            this.contactType = _data["ContactType"];
            this.routeVia = _data["RouteVia"];
            this.showPhone = _data["ShowPhone"];
            this.routeeProxy = _data["RouteeProxy"];
            this.defaultResponsibility = _data["DefaultResponsibility"];
            this.contactCompanyKey = _data["ContactCompanyKey"];
            this.signature = _data["Signature"];
            this.likeness = _data["Likeness"];
            this.useCompanyAddr = _data["UseCompanyAddr"];
            this.showNewProjects = _data["ShowNewProjects"];
            this.sfUser = _data["sfUser"];
            this.isPublic = _data["IsPublic"];
            this.active = _data["Active"];
            this.solomonUser = _data["SolomonUser"];
            this.slidingExpiration = _data["SlidingExpiration"];
            this.pWMustChange = _data["PWMustChange"];
            this.pWAging = _data["PWAging"];
            this.divisionID = _data["DivisionID"];
            this.lockoutReason = _data["LockoutReason"];
            this.orgLevel = _data["OrgLevel"];
            this.synchCheck = _data["SynchCheck"];
            this.failedLoginRun = _data["FailedLoginRun"];
            this.suppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.lastLogin = _data["LastLogin"] ? new Date(_data["LastLogin"].toString()) : <any>undefined;
            this.lastPWChange = _data["LastPWChange"] ? new Date(_data["LastPWChange"].toString()) : <any>undefined;
            this.lockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.userKey;
        data["UserName"] = this.userName;
        data["UserLogin"] = this.userLogin;
        data["FederatedIdentityInfo"] = this.federatedIdentityInfo;
        data["SortName"] = this.sortName;
        data["FamiliarName"] = this.familiarName;
        data["Salutation"] = this.salutation;
        data["Title"] = this.title;
        data["Role"] = this.role;
        data["EMail"] = this.eMail;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["cell"] = this.cell;
        data["pager"] = this.pager;
        data["Company"] = this.company;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["Country"] = this.country;
        data["County"] = this.county;
        data["TimeZone"] = this.timeZone;
        data["IMService"] = this.iMService;
        data["IMHandle"] = this.iMHandle;
        data["WebURL"] = this.webURL;
        data["VendorID"] = this.vendorID;
        data["EmployeeID"] = this.employeeID;
        data["ContactType"] = this.contactType;
        data["RouteVia"] = this.routeVia;
        data["ShowPhone"] = this.showPhone;
        data["RouteeProxy"] = this.routeeProxy;
        data["DefaultResponsibility"] = this.defaultResponsibility;
        data["ContactCompanyKey"] = this.contactCompanyKey;
        data["Signature"] = this.signature;
        data["Likeness"] = this.likeness;
        data["UseCompanyAddr"] = this.useCompanyAddr;
        data["ShowNewProjects"] = this.showNewProjects;
        data["sfUser"] = this.sfUser;
        data["IsPublic"] = this.isPublic;
        data["Active"] = this.active;
        data["SolomonUser"] = this.solomonUser;
        data["SlidingExpiration"] = this.slidingExpiration;
        data["PWMustChange"] = this.pWMustChange;
        data["PWAging"] = this.pWAging;
        data["DivisionID"] = this.divisionID;
        data["LockoutReason"] = this.lockoutReason;
        data["OrgLevel"] = this.orgLevel;
        data["SynchCheck"] = this.synchCheck;
        data["FailedLoginRun"] = this.failedLoginRun;
        data["SuppressNotifyUntil"] = this.suppressNotifyUntil ? this.suppressNotifyUntil.toISOString() : <any>undefined;
        data["LastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["LastPWChange"] = this.lastPWChange ? this.lastPWChange.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.lockedOutUntil ? this.lockedOutUntil.toISOString() : <any>undefined;
        data["Expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

/** Describes a contact */
export interface IContact {
    /** Key for this user/contact */
    userKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    userName?: string | undefined;
    /** Login name */
    userLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    federatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    sortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    familiarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    salutation?: string | undefined;
    /** Short description */
    title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    role?: string | undefined;
    /** Standard SMTP Email Address */
    eMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    county?: string | undefined;
    /** EST, PST, etc */
    timeZone?: string | undefined;
    /** Instant Messaging Service */
    iMService?: string | undefined;
    /** Instant Messaging Handle */
    iMHandle?: string | undefined;
    /** URL */
    webURL?: string | undefined;
    /** Vendor Company ID */
    vendorID?: string | undefined;
    /** Weak link to Solomon */
    employeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    contactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    routeVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    showPhone: number;
    /** Key to role that defines who can proxy for this contact */
    routeeProxy?: string | undefined;
    /** A role with a responsibility */
    defaultResponsibility: string;
    /** Key to primary company */
    contactCompanyKey: string;
    /** HTML Markup for signature in templates */
    signature?: string | undefined;
    /** Key to file in catalog that contains image */
    likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    useCompanyAddr: boolean;
    /** When true, new projects are added to the dashboard automatically */
    showNewProjects: boolean;
    /** When True, can log in to dashboard */
    sfUser: boolean;
    /** When true, this contact is included in lookups  */
    isPublic: boolean;
    /** When false, this row is ignored and ineffective */
    active: boolean;
    /** When true, is also an integrated DSL User */
    solomonUser: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    slidingExpiration: boolean;
    /** When TRUE, user must change password */
    pWMustChange: boolean;
    /** When TRUE, user can be locked out because of password age */
    pWAging: boolean;
    /** Company Division ID */
    divisionID?: string | undefined;
    /** Why user has been blocked */
    lockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    orgLevel: number;
    /** Checksum of all externally syched data */
    synchCheck: number;
    /** Number of consecutive login failures (reset upon success) */
    failedLoginRun: number;
    /** Email notifications suppressed until this time */
    suppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    lastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    lastPWChange?: Date | undefined;
    /** User cannot login until this time */
    lockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    created: Date;
}

/** Attributes describing a member of a project team */
export class Suggestion implements ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;

    constructor(data?: ISuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Suggestion {
        data = typeof data === 'object' ? data : {};
        let result = new Suggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): Suggestion {
        const json = this.toJSON();
        let result = new Suggestion();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export class CodeChoice implements ICodeChoice {
    /** Name for a set of choices */
    setName!: string;
    /** Code */
    code!: string;
    /** Display Value  */
    description!: string;
    /** For cascading codes, names the next code set */
    nextSet?: string | undefined;
    /** True if code is still active */
    active!: boolean;
    /** True if code is allowed for new records */
    onAdd!: boolean;
    /** Code Flag - use varies by code set */
    codeFlag!: boolean;

    constructor(data?: ICodeChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setName = _data["SetName"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.nextSet = _data["NextSet"];
            this.active = _data["Active"];
            this.onAdd = _data["OnAdd"];
            this.codeFlag = _data["CodeFlag"];
        }
    }

    static fromJS(data: any): CodeChoice {
        data = typeof data === 'object' ? data : {};
        let result = new CodeChoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SetName"] = this.setName;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["NextSet"] = this.nextSet;
        data["Active"] = this.active;
        data["OnAdd"] = this.onAdd;
        data["CodeFlag"] = this.codeFlag;
        return data; 
    }

    clone(): CodeChoice {
        const json = this.toJSON();
        let result = new CodeChoice();
        result.init(json);
        return result;
    }
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export interface ICodeChoice {
    /** Name for a set of choices */
    setName: string;
    /** Code */
    code: string;
    /** Display Value  */
    description: string;
    /** For cascading codes, names the next code set */
    nextSet?: string | undefined;
    /** True if code is still active */
    active: boolean;
    /** True if code is allowed for new records */
    onAdd: boolean;
    /** Code Flag - use varies by code set */
    codeFlag: boolean;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UpgradeRequired = 426,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
}

/** Document Header informat for a process */
export class DocMasterDetail implements IDocMasterDetail {
    /** Identifies a Document */
    docMasterKey!: string;
    /** References a Document Process Type */
    docTypeKey!: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    docReference!: string;
    /** Updatable; see also xsfDocRevision.Created */
    docDate!: Date;
    /** References base document, based upon DocType */
    docNo?: string | undefined;
    /** External reference number; text indexed */
    sourceDocNo?: string | undefined;
    /** free form, reference to external number */
    externalDocNo?: string | undefined;
    /** With DocNo, references base document */
    docBatchNo?: string | undefined;
    /** Short description */
    title?: string | undefined;
    /** Code Reference */
    source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    priority!: number;
    /** Number to send */
    numToSend!: number;
    /** Number to forward  */
    numToForward!: number;
    /** numeric probability. valid values 0 to 100 */
    probability!: number;
    /** When TRUE, Spitfire can replace the title automatically */
    autoTitled!: boolean;
    /** When true, access is strictly restricted */
    confidential!: boolean;
    /** When TRUE, those with permission can edit the document */
    docEdit!: boolean;
    /** when true, something is final (often used for final payment, etc) */
    final!: boolean;
    /** Used on Vendor Maintenance documents */
    docFlag!: boolean;
    /** Date (and sometimes Time) by which action is required */
    due!: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    closed!: Date;
    /** Own Signature Date or Manager's Approved Date */
    signoff!: Date;
    /** For example, invoice date of pay request */
    sourceDate!: Date;
    /** Weak link to another Spitfire Document. */
    linkedDocKey!: string;
    /** key to global reference */
    uniReferenceKey!: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    responsibleParty!: string;
    /** link to contact/user; the source  */
    sourceContact!: string;
    /** Validated in Contact Table */
    ownerApprover!: string;
    /** References user/contact; Set by data layer when related status changes */
    lastStatusBy!: string;
    /** Predefined route last resolved */
    lastRouteKey!: string;
    /** Status code */
    status?: string | undefined;
    /** Code (see doc type subcode maintenance) */
    subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    contractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    area!: number;
    /** Numeric duration - units implied by SOP */
    duration!: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    updateMask!: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    routeFlags!: number;
    /** free form  */
    location?: string | undefined;
    /** External payment authorization number */
    payItemNumber?: string | undefined;
    /** Company Division ID */
    divisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** External reference to Contract. */
    specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    budgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    sOVItemNumber?: string | undefined;
    /** freeform */
    section?: string | undefined;
    /** Reference to related subcontract  */
    subContract?: string | undefined;
    /** If pay control is being enforced  */
    payControl?: string | undefined;
    /** Links to a user/contact  */
    fromUser!: string;
    /** read only indicator of the number of stages currently in the route */
    maxStage!: number;
    /** read only indicator of the number of revisions currently in the document */
    maxRevNo!: number;
    /** Readonly Links to document revision */
    docRevKey!: string;
    /** Readonly key for document session */
    docSessionKey!: string;
    /** Current Route sequence (null if past end of route) */
    currentSeq!: number;
    /** References Subtype on Project Setup */
    projectSubtype?: string | undefined;
    /** when true, XTS applies */
    isXTS!: boolean;
    /** when true, XTS inbound updates are disabled */
    xTSBlockIn!: boolean;
    /** when true, XTS pushes are disabled */
    xTSBlockOut!: boolean;
    /** when XTS, mapping key */
    tDKeyMapKey!: string;
    /** Key to user currently editing  */
    editUser!: string;
    /** summary of compliance state - if type has compliance enabled */
    complianceInfo?: string | undefined;

    constructor(data?: IDocMasterDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMasterKey = _data["DocMasterKey"];
            this.docTypeKey = _data["DocTypeKey"];
            this.docReference = _data["DocReference"];
            this.docDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.docNo = _data["DocNo"];
            this.sourceDocNo = _data["SourceDocNo"];
            this.externalDocNo = _data["ExternalDocNo"];
            this.docBatchNo = _data["DocBatchNo"];
            this.title = _data["Title"];
            this.source = _data["Source"];
            this.priority = _data["Priority"];
            this.numToSend = _data["NumToSend"];
            this.numToForward = _data["NumToForward"];
            this.probability = _data["Probability"];
            this.autoTitled = _data["AutoTitled"];
            this.confidential = _data["Confidential"];
            this.docEdit = _data["DocEdit"];
            this.final = _data["Final"];
            this.docFlag = _data["DocFlag"];
            this.due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.sourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.linkedDocKey = _data["LinkedDocKey"];
            this.uniReferenceKey = _data["UniReferenceKey"];
            this.responsibleParty = _data["ResponsibleParty"];
            this.sourceContact = _data["SourceContact"];
            this.ownerApprover = _data["OwnerApprover"];
            this.lastStatusBy = _data["LastStatusBy"];
            this.lastRouteKey = _data["LastRouteKey"];
            this.status = _data["Status"];
            this.subtype = _data["Subtype"];
            this.contractType = _data["ContractType"];
            this.reason = _data["Reason"];
            this.area = _data["Area"];
            this.duration = _data["Duration"];
            this.updateMask = _data["UpdateMask"];
            this.routeFlags = _data["RouteFlags"];
            this.location = _data["Location"];
            this.payItemNumber = _data["PayItemNumber"];
            this.divisionID = _data["DivisionID"];
            this.project = _data["Project"];
            this.projEntity = _data["ProjEntity"];
            this.specification = _data["Specification"];
            this.budgetRevFlag = _data["BudgetRevFlag"];
            this.sOVItemNumber = _data["SOVItemNumber"];
            this.section = _data["Section"];
            this.subContract = _data["SubContract"];
            this.payControl = _data["PayControl"];
            this.fromUser = _data["FromUser"];
            this.maxStage = _data["MaxStage"];
            this.maxRevNo = _data["MaxRevNo"];
            this.docRevKey = _data["DocRevKey"];
            this.docSessionKey = _data["DocSessionKey"];
            this.currentSeq = _data["CurrentSeq"];
            this.projectSubtype = _data["ProjectSubtype"];
            this.isXTS = _data["IsXTS"];
            this.xTSBlockIn = _data["XTSBlockIn"];
            this.xTSBlockOut = _data["XTSBlockOut"];
            this.tDKeyMapKey = _data["TDKeyMapKey"];
            this.editUser = _data["EditUser"];
            this.complianceInfo = _data["ComplianceInfo"];
        }
    }

    static fromJS(data: any): DocMasterDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DocMasterDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.docMasterKey;
        data["DocTypeKey"] = this.docTypeKey;
        data["DocReference"] = this.docReference;
        data["DocDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["DocNo"] = this.docNo;
        data["SourceDocNo"] = this.sourceDocNo;
        data["ExternalDocNo"] = this.externalDocNo;
        data["DocBatchNo"] = this.docBatchNo;
        data["Title"] = this.title;
        data["Source"] = this.source;
        data["Priority"] = this.priority;
        data["NumToSend"] = this.numToSend;
        data["NumToForward"] = this.numToForward;
        data["Probability"] = this.probability;
        data["AutoTitled"] = this.autoTitled;
        data["Confidential"] = this.confidential;
        data["DocEdit"] = this.docEdit;
        data["Final"] = this.final;
        data["DocFlag"] = this.docFlag;
        data["Due"] = this.due ? this.due.toISOString() : <any>undefined;
        data["Closed"] = this.closed ? this.closed.toISOString() : <any>undefined;
        data["Signoff"] = this.signoff ? this.signoff.toISOString() : <any>undefined;
        data["SourceDate"] = this.sourceDate ? this.sourceDate.toISOString() : <any>undefined;
        data["LinkedDocKey"] = this.linkedDocKey;
        data["UniReferenceKey"] = this.uniReferenceKey;
        data["ResponsibleParty"] = this.responsibleParty;
        data["SourceContact"] = this.sourceContact;
        data["OwnerApprover"] = this.ownerApprover;
        data["LastStatusBy"] = this.lastStatusBy;
        data["LastRouteKey"] = this.lastRouteKey;
        data["Status"] = this.status;
        data["Subtype"] = this.subtype;
        data["ContractType"] = this.contractType;
        data["Reason"] = this.reason;
        data["Area"] = this.area;
        data["Duration"] = this.duration;
        data["UpdateMask"] = this.updateMask;
        data["RouteFlags"] = this.routeFlags;
        data["Location"] = this.location;
        data["PayItemNumber"] = this.payItemNumber;
        data["DivisionID"] = this.divisionID;
        data["Project"] = this.project;
        data["ProjEntity"] = this.projEntity;
        data["Specification"] = this.specification;
        data["BudgetRevFlag"] = this.budgetRevFlag;
        data["SOVItemNumber"] = this.sOVItemNumber;
        data["Section"] = this.section;
        data["SubContract"] = this.subContract;
        data["PayControl"] = this.payControl;
        data["FromUser"] = this.fromUser;
        data["MaxStage"] = this.maxStage;
        data["MaxRevNo"] = this.maxRevNo;
        data["DocRevKey"] = this.docRevKey;
        data["DocSessionKey"] = this.docSessionKey;
        data["CurrentSeq"] = this.currentSeq;
        data["ProjectSubtype"] = this.projectSubtype;
        data["IsXTS"] = this.isXTS;
        data["XTSBlockIn"] = this.xTSBlockIn;
        data["XTSBlockOut"] = this.xTSBlockOut;
        data["TDKeyMapKey"] = this.tDKeyMapKey;
        data["EditUser"] = this.editUser;
        data["ComplianceInfo"] = this.complianceInfo;
        return data; 
    }

    clone(): DocMasterDetail {
        const json = this.toJSON();
        let result = new DocMasterDetail();
        result.init(json);
        return result;
    }
}

/** Document Header informat for a process */
export interface IDocMasterDetail {
    /** Identifies a Document */
    docMasterKey: string;
    /** References a Document Process Type */
    docTypeKey: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    docReference: string;
    /** Updatable; see also xsfDocRevision.Created */
    docDate: Date;
    /** References base document, based upon DocType */
    docNo?: string | undefined;
    /** External reference number; text indexed */
    sourceDocNo?: string | undefined;
    /** free form, reference to external number */
    externalDocNo?: string | undefined;
    /** With DocNo, references base document */
    docBatchNo?: string | undefined;
    /** Short description */
    title?: string | undefined;
    /** Code Reference */
    source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    priority: number;
    /** Number to send */
    numToSend: number;
    /** Number to forward  */
    numToForward: number;
    /** numeric probability. valid values 0 to 100 */
    probability: number;
    /** When TRUE, Spitfire can replace the title automatically */
    autoTitled: boolean;
    /** When true, access is strictly restricted */
    confidential: boolean;
    /** When TRUE, those with permission can edit the document */
    docEdit: boolean;
    /** when true, something is final (often used for final payment, etc) */
    final: boolean;
    /** Used on Vendor Maintenance documents */
    docFlag: boolean;
    /** Date (and sometimes Time) by which action is required */
    due: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    closed: Date;
    /** Own Signature Date or Manager's Approved Date */
    signoff: Date;
    /** For example, invoice date of pay request */
    sourceDate: Date;
    /** Weak link to another Spitfire Document. */
    linkedDocKey: string;
    /** key to global reference */
    uniReferenceKey: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    responsibleParty: string;
    /** link to contact/user; the source  */
    sourceContact: string;
    /** Validated in Contact Table */
    ownerApprover: string;
    /** References user/contact; Set by data layer when related status changes */
    lastStatusBy: string;
    /** Predefined route last resolved */
    lastRouteKey: string;
    /** Status code */
    status?: string | undefined;
    /** Code (see doc type subcode maintenance) */
    subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    contractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    area: number;
    /** Numeric duration - units implied by SOP */
    duration: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    updateMask: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    routeFlags: number;
    /** free form  */
    location?: string | undefined;
    /** External payment authorization number */
    payItemNumber?: string | undefined;
    /** Company Division ID */
    divisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** External reference to Contract. */
    specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    budgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    sOVItemNumber?: string | undefined;
    /** freeform */
    section?: string | undefined;
    /** Reference to related subcontract  */
    subContract?: string | undefined;
    /** If pay control is being enforced  */
    payControl?: string | undefined;
    /** Links to a user/contact  */
    fromUser: string;
    /** read only indicator of the number of stages currently in the route */
    maxStage: number;
    /** read only indicator of the number of revisions currently in the document */
    maxRevNo: number;
    /** Readonly Links to document revision */
    docRevKey: string;
    /** Readonly key for document session */
    docSessionKey: string;
    /** Current Route sequence (null if past end of route) */
    currentSeq: number;
    /** References Subtype on Project Setup */
    projectSubtype?: string | undefined;
    /** when true, XTS applies */
    isXTS: boolean;
    /** when true, XTS inbound updates are disabled */
    xTSBlockIn: boolean;
    /** when true, XTS pushes are disabled */
    xTSBlockOut: boolean;
    /** when XTS, mapping key */
    tDKeyMapKey: string;
    /** Key to user currently editing  */
    editUser: string;
    /** summary of compliance state - if type has compliance enabled */
    complianceInfo?: string | undefined;
}

/** Describes an DocItem Condition */
export class DocItem implements IDocItem {
    /** Key of this item */
    docItemKey!: string;
    /** Readonly Number of task entries for this item; often 1 */
    taskCount!: number;
    /** Readonly Number of comment entries for this item; often zero */
    commentCount!: number;
    /** Parent revision to which this item belongs */
    itemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    docItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    relatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    responsibleParty!: string;
    /** Weak link to another Spitfire Document. */
    linkedDocKey!: string;
    /** Weak Link to another item */
    linkedItemKey!: string;
    /** Key to global reference  */
    uniReferenceKey!: string;
    /** References user/contact; Set by data layer when related status changes */
    lastStatusBy!: string;
    /** Key Reference user/contact */
    approver!: string;
    /** References user/contact */
    author!: string;
    /** Free form explaination or generic description (!!!) */
    description?: string | undefined;
    /** Assigned  */
    drawingNumber?: string | undefined;
    /** Auto-increment revision number */
    revisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    paragraph?: string | undefined;
    /** External reference to Contract. */
    specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    itemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    itemSource?: string | undefined;
    /** References code set ItemType */
    itemType?: string | undefined;
    /** Code defined in DocType specific list */
    itemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    drawings?: string | undefined;
    /** Code defined in DocType specific list */
    samples?: string | undefined;
    /** Code defined in DocType specific list */
    productData?: string | undefined;
    /** Code defined in DocType specific list */
    testReport?: string | undefined;
    /** Code defined in DocType specific list */
    mixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    schedule?: string | undefined;
    /** Code defined in DocType specific list */
    fieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    certification?: string | undefined;
    /** Code defined in DocType specific list */
    evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    shop?: string | undefined;
    /** External reference number of this item. */
    sourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    sourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    architectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    architectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    sOVLineNumber?: string | undefined;
    /** Free form */
    manufacturer?: string | undefined;
    /** Free form */
    supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    revenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    stage!: number;
    /** Money - Completed Work Retention */
    cWRetention!: number;
    /** Money - Stored Material Retention */
    sMRetention!: number;
    /** Original Estimate (of cost) */
    originalEstimate!: number;
    /** Original Quote (of revenue, to customer) */
    originalQuote!: number;
    /** Quantity - see UOM in item task extension */
    itemQuantity!: number;
    /** when true, is billable/included */
    billable!: boolean;
    /** Date Started */
    started?: Date | undefined;
    /** Date Ssubmitted */
    submitted?: Date | undefined;
    /** Date Requested */
    requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    due?: Date | undefined;
    /** Date Completed */
    completed?: Date | undefined;
    /** reference to Revision that includes this item */
    itemRevKey!: string;
    /** Key to container for this item; seldom used */
    itemFolderKey!: string;
    /** Reference to user/contact */
    itemFromUser!: string;
    /** Echoes Item number for convienience; see Item Revision */
    docItemNumber?: string | undefined;
    /** When Created  */
    itemCreated!: Date;
    /** Read Only: when true, this item is a copy from a register */
    isRegisterDoc!: boolean;
    /** When from register, this is the number of the item from the register */
    itemRegisterNumber?: string | undefined;
    /** Hmm */
    itemIsShared!: boolean;
    /** Hmm */
    responsibleNow!: string;
    /** Hmm */
    responsibleCommon?: string | undefined;

    constructor(data?: IDocItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docItemKey = _data["DocItemKey"];
            this.taskCount = _data["TaskCount"];
            this.commentCount = _data["CommentCount"];
            this.itemRevisionMap = _data["ItemRevisionMap"] ? DocItemMap.fromJS(_data["ItemRevisionMap"]) : <any>undefined;
            if (Array.isArray(_data["DocItemTask"])) {
                this.docItemTask = [] as any;
                for (let item of _data["DocItemTask"])
                    this.docItemTask!.push(DocItemTask.fromJS(item));
            }
            this.relatedLineDetails = _data["RelatedLineDetails"] ? RelatedItemDetail.fromJS(_data["RelatedLineDetails"]) : <any>undefined;
            this.responsibleParty = _data["ResponsibleParty"];
            this.linkedDocKey = _data["LinkedDocKey"];
            this.linkedItemKey = _data["LinkedItemKey"];
            this.uniReferenceKey = _data["UniReferenceKey"];
            this.lastStatusBy = _data["LastStatusBy"];
            this.approver = _data["Approver"];
            this.author = _data["Author"];
            this.description = _data["Description"];
            this.drawingNumber = _data["DrawingNumber"];
            this.revisionNumber = _data["RevisionNumber"];
            this.paragraph = _data["Paragraph"];
            this.specification = _data["Specification"];
            this.itemStatus = _data["ItemStatus"];
            this.itemSource = _data["ItemSource"];
            this.itemType = _data["ItemType"];
            this.itemSubtype = _data["ItemSubtype"];
            this.drawings = _data["Drawings"];
            this.samples = _data["Samples"];
            this.productData = _data["ProductData"];
            this.testReport = _data["TestReport"];
            this.mixDesign = _data["MixDesign"];
            this.schedule = _data["Schedule"];
            this.fieldMockup = _data["FieldMockup"];
            this.guarantee = _data["Guarantee"];
            this.certification = _data["Certification"];
            this.evaluation = _data["Evaluation"];
            this.shop = _data["Shop"];
            this.sourceItemNumber = _data["SourceItemNumber"];
            this.sourceInitialNumber = _data["SourceInitialNumber"];
            this.architectInitialNumber = _data["ArchitectInitialNumber"];
            this.architectItemNumber = _data["ArchitectItemNumber"];
            this.sOVLineNumber = _data["SOVLineNumber"];
            this.manufacturer = _data["Manufacturer"];
            this.supplier = _data["Supplier"];
            this.revenueEntity = _data["RevenueEntity"];
            this.stage = _data["Stage"];
            this.cWRetention = _data["CWRetention"];
            this.sMRetention = _data["SMRetention"];
            this.originalEstimate = _data["OriginalEstimate"];
            this.originalQuote = _data["OriginalQuote"];
            this.itemQuantity = _data["ItemQuantity"];
            this.billable = _data["Billable"];
            this.started = _data["Started"] ? new Date(_data["Started"].toString()) : <any>undefined;
            this.submitted = _data["Submitted"] ? new Date(_data["Submitted"].toString()) : <any>undefined;
            this.requested = _data["Requested"] ? new Date(_data["Requested"].toString()) : <any>undefined;
            this.received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
            this.due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.completed = _data["Completed"] ? new Date(_data["Completed"].toString()) : <any>undefined;
            this.itemRevKey = _data["ItemRevKey"];
            this.itemFolderKey = _data["ItemFolderKey"];
            this.itemFromUser = _data["ItemFromUser"];
            this.docItemNumber = _data["DocItemNumber"];
            this.itemCreated = _data["ItemCreated"] ? new Date(_data["ItemCreated"].toString()) : <any>undefined;
            this.isRegisterDoc = _data["IsRegisterDoc"];
            this.itemRegisterNumber = _data["ItemRegisterNumber"];
            this.itemIsShared = _data["ItemIsShared"];
            this.responsibleNow = _data["ResponsibleNow"];
            this.responsibleCommon = _data["ResponsibleCommon"];
        }
    }

    static fromJS(data: any): DocItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocItemKey"] = this.docItemKey;
        data["TaskCount"] = this.taskCount;
        data["CommentCount"] = this.commentCount;
        data["ItemRevisionMap"] = this.itemRevisionMap ? this.itemRevisionMap.toJSON() : <any>undefined;
        if (Array.isArray(this.docItemTask)) {
            data["DocItemTask"] = [];
            for (let item of this.docItemTask)
                data["DocItemTask"].push(item.toJSON());
        }
        data["RelatedLineDetails"] = this.relatedLineDetails ? this.relatedLineDetails.toJSON() : <any>undefined;
        data["ResponsibleParty"] = this.responsibleParty;
        data["LinkedDocKey"] = this.linkedDocKey;
        data["LinkedItemKey"] = this.linkedItemKey;
        data["UniReferenceKey"] = this.uniReferenceKey;
        data["LastStatusBy"] = this.lastStatusBy;
        data["Approver"] = this.approver;
        data["Author"] = this.author;
        data["Description"] = this.description;
        data["DrawingNumber"] = this.drawingNumber;
        data["RevisionNumber"] = this.revisionNumber;
        data["Paragraph"] = this.paragraph;
        data["Specification"] = this.specification;
        data["ItemStatus"] = this.itemStatus;
        data["ItemSource"] = this.itemSource;
        data["ItemType"] = this.itemType;
        data["ItemSubtype"] = this.itemSubtype;
        data["Drawings"] = this.drawings;
        data["Samples"] = this.samples;
        data["ProductData"] = this.productData;
        data["TestReport"] = this.testReport;
        data["MixDesign"] = this.mixDesign;
        data["Schedule"] = this.schedule;
        data["FieldMockup"] = this.fieldMockup;
        data["Guarantee"] = this.guarantee;
        data["Certification"] = this.certification;
        data["Evaluation"] = this.evaluation;
        data["Shop"] = this.shop;
        data["SourceItemNumber"] = this.sourceItemNumber;
        data["SourceInitialNumber"] = this.sourceInitialNumber;
        data["ArchitectInitialNumber"] = this.architectInitialNumber;
        data["ArchitectItemNumber"] = this.architectItemNumber;
        data["SOVLineNumber"] = this.sOVLineNumber;
        data["Manufacturer"] = this.manufacturer;
        data["Supplier"] = this.supplier;
        data["RevenueEntity"] = this.revenueEntity;
        data["Stage"] = this.stage;
        data["CWRetention"] = this.cWRetention;
        data["SMRetention"] = this.sMRetention;
        data["OriginalEstimate"] = this.originalEstimate;
        data["OriginalQuote"] = this.originalQuote;
        data["ItemQuantity"] = this.itemQuantity;
        data["Billable"] = this.billable;
        data["Started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["Submitted"] = this.submitted ? this.submitted.toISOString() : <any>undefined;
        data["Requested"] = this.requested ? this.requested.toISOString() : <any>undefined;
        data["Received"] = this.received ? this.received.toISOString() : <any>undefined;
        data["Reviewed"] = this.reviewed ? this.reviewed.toISOString() : <any>undefined;
        data["Due"] = this.due ? this.due.toISOString() : <any>undefined;
        data["Completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["ItemRevKey"] = this.itemRevKey;
        data["ItemFolderKey"] = this.itemFolderKey;
        data["ItemFromUser"] = this.itemFromUser;
        data["DocItemNumber"] = this.docItemNumber;
        data["ItemCreated"] = this.itemCreated ? this.itemCreated.toISOString() : <any>undefined;
        data["IsRegisterDoc"] = this.isRegisterDoc;
        data["ItemRegisterNumber"] = this.itemRegisterNumber;
        data["ItemIsShared"] = this.itemIsShared;
        data["ResponsibleNow"] = this.responsibleNow;
        data["ResponsibleCommon"] = this.responsibleCommon;
        return data; 
    }

    clone(): DocItem {
        const json = this.toJSON();
        let result = new DocItem();
        result.init(json);
        return result;
    }
}

/** Describes an DocItem Condition */
export interface IDocItem {
    /** Key of this item */
    docItemKey: string;
    /** Readonly Number of task entries for this item; often 1 */
    taskCount: number;
    /** Readonly Number of comment entries for this item; often zero */
    commentCount: number;
    /** Parent revision to which this item belongs */
    itemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    docItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    relatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    responsibleParty: string;
    /** Weak link to another Spitfire Document. */
    linkedDocKey: string;
    /** Weak Link to another item */
    linkedItemKey: string;
    /** Key to global reference  */
    uniReferenceKey: string;
    /** References user/contact; Set by data layer when related status changes */
    lastStatusBy: string;
    /** Key Reference user/contact */
    approver: string;
    /** References user/contact */
    author: string;
    /** Free form explaination or generic description (!!!) */
    description?: string | undefined;
    /** Assigned  */
    drawingNumber?: string | undefined;
    /** Auto-increment revision number */
    revisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    paragraph?: string | undefined;
    /** External reference to Contract. */
    specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    itemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    itemSource?: string | undefined;
    /** References code set ItemType */
    itemType?: string | undefined;
    /** Code defined in DocType specific list */
    itemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    drawings?: string | undefined;
    /** Code defined in DocType specific list */
    samples?: string | undefined;
    /** Code defined in DocType specific list */
    productData?: string | undefined;
    /** Code defined in DocType specific list */
    testReport?: string | undefined;
    /** Code defined in DocType specific list */
    mixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    schedule?: string | undefined;
    /** Code defined in DocType specific list */
    fieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    certification?: string | undefined;
    /** Code defined in DocType specific list */
    evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    shop?: string | undefined;
    /** External reference number of this item. */
    sourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    sourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    architectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    architectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    sOVLineNumber?: string | undefined;
    /** Free form */
    manufacturer?: string | undefined;
    /** Free form */
    supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    revenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    stage: number;
    /** Money - Completed Work Retention */
    cWRetention: number;
    /** Money - Stored Material Retention */
    sMRetention: number;
    /** Original Estimate (of cost) */
    originalEstimate: number;
    /** Original Quote (of revenue, to customer) */
    originalQuote: number;
    /** Quantity - see UOM in item task extension */
    itemQuantity: number;
    /** when true, is billable/included */
    billable: boolean;
    /** Date Started */
    started?: Date | undefined;
    /** Date Ssubmitted */
    submitted?: Date | undefined;
    /** Date Requested */
    requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    due?: Date | undefined;
    /** Date Completed */
    completed?: Date | undefined;
    /** reference to Revision that includes this item */
    itemRevKey: string;
    /** Key to container for this item; seldom used */
    itemFolderKey: string;
    /** Reference to user/contact */
    itemFromUser: string;
    /** Echoes Item number for convienience; see Item Revision */
    docItemNumber?: string | undefined;
    /** When Created  */
    itemCreated: Date;
    /** Read Only: when true, this item is a copy from a register */
    isRegisterDoc: boolean;
    /** When from register, this is the number of the item from the register */
    itemRegisterNumber?: string | undefined;
    /** Hmm */
    itemIsShared: boolean;
    /** Hmm */
    responsibleNow: string;
    /** Hmm */
    responsibleCommon?: string | undefined;
}

/** Describes an DocRevItem Condition */
export class DocItemMap implements IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    docRevItemKey!: string;
    /** Links to item */
    docItemKey!: string;
    /** Indicates the "folder" where the resource resides */
    containerKey!: string;
    /** Links to a user/contact  */
    fromUser!: string;
    /** Numeric Identifier  */
    itemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    itemSeq!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    created!: Date;

    constructor(data?: IDocItemMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docRevItemKey = _data["DocRevItemKey"];
            this.docItemKey = _data["DocItemKey"];
            this.containerKey = _data["ContainerKey"];
            this.fromUser = _data["FromUser"];
            this.itemNumber = _data["ItemNumber"];
            this.itemSeq = _data["ItemSeq"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocItemMap {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocRevItemKey"] = this.docRevItemKey;
        data["DocItemKey"] = this.docItemKey;
        data["ContainerKey"] = this.containerKey;
        data["FromUser"] = this.fromUser;
        data["ItemNumber"] = this.itemNumber;
        data["ItemSeq"] = this.itemSeq;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocItemMap {
        const json = this.toJSON();
        let result = new DocItemMap();
        result.init(json);
        return result;
    }
}

/** Describes an DocRevItem Condition */
export interface IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    docRevItemKey: string;
    /** Links to item */
    docItemKey: string;
    /** Indicates the "folder" where the resource resides */
    containerKey: string;
    /** Links to a user/contact  */
    fromUser: string;
    /** Numeric Identifier  */
    itemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    itemSeq: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    created: Date;
}

/** Describes an DocItemTask Condition */
export class DocItemTask implements IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    itemTaskKey!: string;
    linkedLineKey!: string;
    /** Weak link to RFQ */
    linkedRFQKey!: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    linkedCCCKey!: string;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    accountCategory?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    subChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    costType?: string | undefined;
    /** Weak link to accounting GL Account */
    gLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    gLSub?: string | undefined;
    /** Code of Labor Class  */
    laborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    uOM?: string | undefined;
    /** None or % of Total(TL) */
    retentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    projectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    itemPercent!: number;
    /** pjcosubd.change_units */
    quantity!: number;
    /** Calculated, but editable */
    revenueAmount!: number;
    rate!: number;
    /** defaults to Amount, but is editable */
    expenseAmount!: number;
    /** Material part of RevenueAmount */
    storedAmount!: number;
    /** Labor part of RevenueAmount */
    workAmount!: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    retentionAmount!: number;
    sMRetentionAmount!: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    sOVWork!: number;
    /** Total material value on SOV */
    sOVMaterials!: number;
    markupRate!: number;
    /** Amount, for custom use */
    csAmount!: number;
    csValue!: number;
    csQty!: number;
    csNumber!: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    markupControl!: boolean;
    /** for custom use */
    csCheck!: boolean;
    csFlag!: boolean;
    /** Free form */
    note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey!: string;
    csKey!: string;
    /** date, for custom use */
    csDate!: Date;
    csWhen!: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    created!: Date;
    linkedEstimate!: number;
    linkedQuote!: number;
    linkedExpense!: number;
    linkedLines!: number;
    linkedContact!: string;
    linkedRFQSC?: string | undefined;
    linkedStatus?: string | undefined;

    constructor(data?: IDocItemTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemTaskKey = _data["ItemTaskKey"];
            this.linkedLineKey = _data["LinkedLineKey"];
            this.linkedRFQKey = _data["LinkedRFQKey"];
            this.linkedCCCKey = _data["LinkedCCCKey"];
            this.projEntity = _data["ProjEntity"];
            this.accountCategory = _data["AccountCategory"];
            this.subcontract = _data["Subcontract"];
            this.subChangeOrder = _data["SubChangeOrder"];
            this.costType = _data["CostType"];
            this.gLAcct = _data["GLAcct"];
            this.gLSub = _data["GLSub"];
            this.laborClass = _data["LaborClass"];
            this.uOM = _data["UOM"];
            this.retentionMethod = _data["RetentionMethod"];
            this.vendor = _data["Vendor"];
            this.projectReference = _data["ProjectReference"];
            this.itemPercent = _data["ItemPercent"];
            this.quantity = _data["Quantity"];
            this.revenueAmount = _data["RevenueAmount"];
            this.rate = _data["Rate"];
            this.expenseAmount = _data["ExpenseAmount"];
            this.storedAmount = _data["StoredAmount"];
            this.workAmount = _data["WorkAmount"];
            this.retentionAmount = _data["RetentionAmount"];
            this.sMRetentionAmount = _data["SMRetentionAmount"];
            this.sOVWork = _data["SOVWork"];
            this.sOVMaterials = _data["SOVMaterials"];
            this.markupRate = _data["MarkupRate"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.markupControl = _data["MarkupControl"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.note = _data["Note"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.linkedEstimate = _data["LinkedEstimate"];
            this.linkedQuote = _data["LinkedQuote"];
            this.linkedExpense = _data["LinkedExpense"];
            this.linkedLines = _data["LinkedLines"];
            this.linkedContact = _data["LinkedContact"];
            this.linkedRFQSC = _data["LinkedRFQSC"];
            this.linkedStatus = _data["LinkedStatus"];
        }
    }

    static fromJS(data: any): DocItemTask {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemTaskKey"] = this.itemTaskKey;
        data["LinkedLineKey"] = this.linkedLineKey;
        data["LinkedRFQKey"] = this.linkedRFQKey;
        data["LinkedCCCKey"] = this.linkedCCCKey;
        data["ProjEntity"] = this.projEntity;
        data["AccountCategory"] = this.accountCategory;
        data["Subcontract"] = this.subcontract;
        data["SubChangeOrder"] = this.subChangeOrder;
        data["CostType"] = this.costType;
        data["GLAcct"] = this.gLAcct;
        data["GLSub"] = this.gLSub;
        data["LaborClass"] = this.laborClass;
        data["UOM"] = this.uOM;
        data["RetentionMethod"] = this.retentionMethod;
        data["Vendor"] = this.vendor;
        data["ProjectReference"] = this.projectReference;
        data["ItemPercent"] = this.itemPercent;
        data["Quantity"] = this.quantity;
        data["RevenueAmount"] = this.revenueAmount;
        data["Rate"] = this.rate;
        data["ExpenseAmount"] = this.expenseAmount;
        data["StoredAmount"] = this.storedAmount;
        data["WorkAmount"] = this.workAmount;
        data["RetentionAmount"] = this.retentionAmount;
        data["SMRetentionAmount"] = this.sMRetentionAmount;
        data["SOVWork"] = this.sOVWork;
        data["SOVMaterials"] = this.sOVMaterials;
        data["MarkupRate"] = this.markupRate;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["MarkupControl"] = this.markupControl;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.note;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["LinkedEstimate"] = this.linkedEstimate;
        data["LinkedQuote"] = this.linkedQuote;
        data["LinkedExpense"] = this.linkedExpense;
        data["LinkedLines"] = this.linkedLines;
        data["LinkedContact"] = this.linkedContact;
        data["LinkedRFQSC"] = this.linkedRFQSC;
        data["LinkedStatus"] = this.linkedStatus;
        return data; 
    }

    clone(): DocItemTask {
        const json = this.toJSON();
        let result = new DocItemTask();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemTask Condition */
export interface IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    itemTaskKey: string;
    linkedLineKey: string;
    /** Weak link to RFQ */
    linkedRFQKey: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    linkedCCCKey: string;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    accountCategory?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    subChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    costType?: string | undefined;
    /** Weak link to accounting GL Account */
    gLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    gLSub?: string | undefined;
    /** Code of Labor Class  */
    laborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    uOM?: string | undefined;
    /** None or % of Total(TL) */
    retentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    projectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    itemPercent: number;
    /** pjcosubd.change_units */
    quantity: number;
    /** Calculated, but editable */
    revenueAmount: number;
    rate: number;
    /** defaults to Amount, but is editable */
    expenseAmount: number;
    /** Material part of RevenueAmount */
    storedAmount: number;
    /** Labor part of RevenueAmount */
    workAmount: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    retentionAmount: number;
    sMRetentionAmount: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    sOVWork: number;
    /** Total material value on SOV */
    sOVMaterials: number;
    markupRate: number;
    /** Amount, for custom use */
    csAmount: number;
    csValue: number;
    csQty: number;
    csNumber: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    markupControl: boolean;
    /** for custom use */
    csCheck: boolean;
    csFlag: boolean;
    /** Free form */
    note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey: string;
    csKey: string;
    /** date, for custom use */
    csDate: Date;
    csWhen: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    created: Date;
    linkedEstimate: number;
    linkedQuote: number;
    linkedExpense: number;
    linkedLines: number;
    linkedContact: string;
    linkedRFQSC?: string | undefined;
    linkedStatus?: string | undefined;
}

/** Describes an SPRLineDetails Condition */
export class RelatedItemDetail implements IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    sCDocItemKey!: string;
    /** Approved (Paid) Quantity */
    approvedQuantity!: number;
    /** Approved Retention  */
    approvedRetention!: number;
    /** Change Order Approved  */
    approvedAmount!: number;
    /** Change Order Approved  */
    approvedExpense!: number;
    /** Change Order Units not yet approved */
    pendingChangeUnits!: number;
    /** not yet approved */
    pendingChangeRetention!: number;
    /** Change Order amount, not yet approved */
    pendingChangeAmount!: number;
    /** not yet approved */
    pendingChangeExpense!: number;
    /** Paid Units */
    voucheredUnits!: number;
    /** Paid Amount */
    voucheredAmount!: number;
    /** Paid Stored Material amount */
    voucheredSMAmount!: number;
    /** Amount Earned but held as retention */
    voucheredRetention!: number;
    /** Amount Earned but held as retention for stored materials */
    voucheredSMRetention!: number;
    /** Payment request units not yet approved */
    pRInProgressQuantity!: number;
    /** Payment retention  not yet approved */
    pRInProgressRetention!: number;
    /** Payment amount  not yet approved */
    pRInProgressAmount!: number;
    /** Units received */
    receivedUnits!: number;
    /** Units tentatively received  not yet approved */
    receiptInProgressUnits!: number;
    /** Amount of line (includes approved changes orders) */
    contractAmount!: number;
    /** Units on line, includes change orders */
    contractUnits!: number;
    /** Percent */
    totalPercentRequest!: number;
    /** Units */
    totalUnitsCompleted!: number;
    /** Amount */
    totalAmountCompleted!: number;
    /** Previous amount (documents of same time with lesser document number) */
    totalPriorAmount!: number;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    gLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    gLSub?: string | undefined;
    /** Code of Labor Class  */
    laborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    accountCategory?: string | undefined;
    /** None or % of Total(TL) */
    retentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    itemPercent!: number;
    rate!: number;
    /** calculated */
    lineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    cap!: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    uOM?: string | undefined;

    constructor(data?: IRelatedItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["Project"];
            this.subcontract = _data["Subcontract"];
            this.sCDocItemKey = _data["SCDocItemKey"];
            this.approvedQuantity = _data["ApprovedQuantity"];
            this.approvedRetention = _data["ApprovedRetention"];
            this.approvedAmount = _data["ApprovedAmount"];
            this.approvedExpense = _data["ApprovedExpense"];
            this.pendingChangeUnits = _data["PendingChangeUnits"];
            this.pendingChangeRetention = _data["PendingChangeRetention"];
            this.pendingChangeAmount = _data["PendingChangeAmount"];
            this.pendingChangeExpense = _data["PendingChangeExpense"];
            this.voucheredUnits = _data["VoucheredUnits"];
            this.voucheredAmount = _data["VoucheredAmount"];
            this.voucheredSMAmount = _data["VoucheredSMAmount"];
            this.voucheredRetention = _data["VoucheredRetention"];
            this.voucheredSMRetention = _data["VoucheredSMRetention"];
            this.pRInProgressQuantity = _data["PRInProgressQuantity"];
            this.pRInProgressRetention = _data["PRInProgressRetention"];
            this.pRInProgressAmount = _data["PRInProgressAmount"];
            this.receivedUnits = _data["ReceivedUnits"];
            this.receiptInProgressUnits = _data["ReceiptInProgressUnits"];
            this.contractAmount = _data["ContractAmount"];
            this.contractUnits = _data["ContractUnits"];
            this.totalPercentRequest = _data["TotalPercentRequest"];
            this.totalUnitsCompleted = _data["TotalUnitsCompleted"];
            this.totalAmountCompleted = _data["TotalAmountCompleted"];
            this.totalPriorAmount = _data["TotalPriorAmount"];
            this.projEntity = _data["ProjEntity"];
            this.gLAcct = _data["GLAcct"];
            this.gLSub = _data["GLSub"];
            this.laborClass = _data["LaborClass"];
            this.accountCategory = _data["AccountCategory"];
            this.retentionMethod = _data["RetentionMethod"];
            this.itemPercent = _data["ItemPercent"];
            this.rate = _data["Rate"];
            this.lineDesc = _data["LineDesc"];
            this.cap = _data["Cap"];
            this.uOM = _data["UOM"];
        }
    }

    static fromJS(data: any): RelatedItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.project;
        data["Subcontract"] = this.subcontract;
        data["SCDocItemKey"] = this.sCDocItemKey;
        data["ApprovedQuantity"] = this.approvedQuantity;
        data["ApprovedRetention"] = this.approvedRetention;
        data["ApprovedAmount"] = this.approvedAmount;
        data["ApprovedExpense"] = this.approvedExpense;
        data["PendingChangeUnits"] = this.pendingChangeUnits;
        data["PendingChangeRetention"] = this.pendingChangeRetention;
        data["PendingChangeAmount"] = this.pendingChangeAmount;
        data["PendingChangeExpense"] = this.pendingChangeExpense;
        data["VoucheredUnits"] = this.voucheredUnits;
        data["VoucheredAmount"] = this.voucheredAmount;
        data["VoucheredSMAmount"] = this.voucheredSMAmount;
        data["VoucheredRetention"] = this.voucheredRetention;
        data["VoucheredSMRetention"] = this.voucheredSMRetention;
        data["PRInProgressQuantity"] = this.pRInProgressQuantity;
        data["PRInProgressRetention"] = this.pRInProgressRetention;
        data["PRInProgressAmount"] = this.pRInProgressAmount;
        data["ReceivedUnits"] = this.receivedUnits;
        data["ReceiptInProgressUnits"] = this.receiptInProgressUnits;
        data["ContractAmount"] = this.contractAmount;
        data["ContractUnits"] = this.contractUnits;
        data["TotalPercentRequest"] = this.totalPercentRequest;
        data["TotalUnitsCompleted"] = this.totalUnitsCompleted;
        data["TotalAmountCompleted"] = this.totalAmountCompleted;
        data["TotalPriorAmount"] = this.totalPriorAmount;
        data["ProjEntity"] = this.projEntity;
        data["GLAcct"] = this.gLAcct;
        data["GLSub"] = this.gLSub;
        data["LaborClass"] = this.laborClass;
        data["AccountCategory"] = this.accountCategory;
        data["RetentionMethod"] = this.retentionMethod;
        data["ItemPercent"] = this.itemPercent;
        data["Rate"] = this.rate;
        data["LineDesc"] = this.lineDesc;
        data["Cap"] = this.cap;
        data["UOM"] = this.uOM;
        return data; 
    }

    clone(): RelatedItemDetail {
        const json = this.toJSON();
        let result = new RelatedItemDetail();
        result.init(json);
        return result;
    }
}

/** Describes an SPRLineDetails Condition */
export interface IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    sCDocItemKey: string;
    /** Approved (Paid) Quantity */
    approvedQuantity: number;
    /** Approved Retention  */
    approvedRetention: number;
    /** Change Order Approved  */
    approvedAmount: number;
    /** Change Order Approved  */
    approvedExpense: number;
    /** Change Order Units not yet approved */
    pendingChangeUnits: number;
    /** not yet approved */
    pendingChangeRetention: number;
    /** Change Order amount, not yet approved */
    pendingChangeAmount: number;
    /** not yet approved */
    pendingChangeExpense: number;
    /** Paid Units */
    voucheredUnits: number;
    /** Paid Amount */
    voucheredAmount: number;
    /** Paid Stored Material amount */
    voucheredSMAmount: number;
    /** Amount Earned but held as retention */
    voucheredRetention: number;
    /** Amount Earned but held as retention for stored materials */
    voucheredSMRetention: number;
    /** Payment request units not yet approved */
    pRInProgressQuantity: number;
    /** Payment retention  not yet approved */
    pRInProgressRetention: number;
    /** Payment amount  not yet approved */
    pRInProgressAmount: number;
    /** Units received */
    receivedUnits: number;
    /** Units tentatively received  not yet approved */
    receiptInProgressUnits: number;
    /** Amount of line (includes approved changes orders) */
    contractAmount: number;
    /** Units on line, includes change orders */
    contractUnits: number;
    /** Percent */
    totalPercentRequest: number;
    /** Units */
    totalUnitsCompleted: number;
    /** Amount */
    totalAmountCompleted: number;
    /** Previous amount (documents of same time with lesser document number) */
    totalPriorAmount: number;
    /** WB Task Code  */
    projEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    gLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    gLSub?: string | undefined;
    /** Code of Labor Class  */
    laborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    accountCategory?: string | undefined;
    /** None or % of Total(TL) */
    retentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    itemPercent: number;
    rate: number;
    /** calculated */
    lineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    cap: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    uOM?: string | undefined;
}

/** Legacy Site Authentication */
export class SiteLogin implements ISiteLogin {
    /** User ID EG: george@acme.com */
    uID?: string | undefined;
    /** Password */
    pW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    isHashed!: boolean;

    constructor(data?: ISiteLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uID = _data["UID"];
            this.pW = _data["PW"];
            this.isHashed = _data["IsHashed"];
        }
    }

    static fromJS(data: any): SiteLogin {
        data = typeof data === 'object' ? data : {};
        let result = new SiteLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UID"] = this.uID;
        data["PW"] = this.pW;
        data["IsHashed"] = this.isHashed;
        return data; 
    }

    clone(): SiteLogin {
        const json = this.toJSON();
        let result = new SiteLogin();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ISiteLogin {
    /** User ID EG: george@acme.com */
    uID?: string | undefined;
    /** Password */
    pW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    isHashed: boolean;
}

/** Attributes describing the currently authenticated user */
export class CurrentUser implements ICurrentUser {
    /** User Key */
    userKey!: string;
    /** Login ID for user in name@domain.com or similar format */
    userLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    fullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    pWMustChange!: boolean;
    /** Three character time zone designation */
    userTimeZone?: string | undefined;
    /** +/- Time offset from server */
    tZOffset!: number;
    /** Password Aging is enabled for this user */
    pWAging!: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    slidingExpiration!: boolean;
    /** When true, the user is currently locked out */
    isLockedOut!: boolean;
    /** When the current password will expire if PWAging is true */
    pWExpires?: Date | undefined;
    /** When this account will expire */
    expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    lockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    lockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    failedLoginRun!: number;
    /** When true, this exact user ID is integrated with Accounting */
    solomonUser!: boolean;
    /** When true, this is the users first interactive session */
    isFirstLogin!: boolean;
    /** Current IIS Session ID */
    masterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    userSessionKey!: string;
    /** URI for an image of this user */
    pictureURL?: string | undefined;
    /** hmmm */
    pDSKey?: string | undefined;
    /** This data is locked in memory */
    isDSProtected!: boolean;

    constructor(data?: ICurrentUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userKey = _data["UserKey"];
            this.userLoginName = _data["UserLoginName"];
            this.fullName = _data["FullName"];
            this.email = _data["email"];
            this.pWMustChange = _data["PWMustChange"];
            this.userTimeZone = _data["UserTimeZone"];
            this.tZOffset = _data["TZOffset"];
            this.pWAging = _data["PWAging"];
            this.slidingExpiration = _data["SlidingExpiration"];
            this.isLockedOut = _data["IsLockedOut"];
            this.pWExpires = _data["PWExpires"] ? new Date(_data["PWExpires"].toString()) : <any>undefined;
            this.expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.lockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.lockoutReason = _data["LockoutReason"];
            this.failedLoginRun = _data["FailedLoginRun"];
            this.solomonUser = _data["SolomonUser"];
            this.isFirstLogin = _data["IsFirstLogin"];
            this.masterSession = _data["MasterSession"];
            this.userSessionKey = _data["UserSessionKey"];
            this.pictureURL = _data["PictureURL"];
            this.pDSKey = _data["PDSKey"];
            this.isDSProtected = _data["IsDSProtected"];
        }
    }

    static fromJS(data: any): CurrentUser {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.userKey;
        data["UserLoginName"] = this.userLoginName;
        data["FullName"] = this.fullName;
        data["email"] = this.email;
        data["PWMustChange"] = this.pWMustChange;
        data["UserTimeZone"] = this.userTimeZone;
        data["TZOffset"] = this.tZOffset;
        data["PWAging"] = this.pWAging;
        data["SlidingExpiration"] = this.slidingExpiration;
        data["IsLockedOut"] = this.isLockedOut;
        data["PWExpires"] = this.pWExpires ? this.pWExpires.toISOString() : <any>undefined;
        data["Expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.lockedOutUntil ? this.lockedOutUntil.toISOString() : <any>undefined;
        data["LockoutReason"] = this.lockoutReason;
        data["FailedLoginRun"] = this.failedLoginRun;
        data["SolomonUser"] = this.solomonUser;
        data["IsFirstLogin"] = this.isFirstLogin;
        data["MasterSession"] = this.masterSession;
        data["UserSessionKey"] = this.userSessionKey;
        data["PictureURL"] = this.pictureURL;
        data["PDSKey"] = this.pDSKey;
        data["IsDSProtected"] = this.isDSProtected;
        return data; 
    }

    clone(): CurrentUser {
        const json = this.toJSON();
        let result = new CurrentUser();
        result.init(json);
        return result;
    }
}

/** Attributes describing the currently authenticated user */
export interface ICurrentUser {
    /** User Key */
    userKey: string;
    /** Login ID for user in name@domain.com or similar format */
    userLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    fullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    pWMustChange: boolean;
    /** Three character time zone designation */
    userTimeZone?: string | undefined;
    /** +/- Time offset from server */
    tZOffset: number;
    /** Password Aging is enabled for this user */
    pWAging: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    slidingExpiration: boolean;
    /** When true, the user is currently locked out */
    isLockedOut: boolean;
    /** When the current password will expire if PWAging is true */
    pWExpires?: Date | undefined;
    /** When this account will expire */
    expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    lockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    lockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    failedLoginRun: number;
    /** When true, this exact user ID is integrated with Accounting */
    solomonUser: boolean;
    /** When true, this is the users first interactive session */
    isFirstLogin: boolean;
    /** Current IIS Session ID */
    masterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    userSessionKey: string;
    /** URI for an image of this user */
    pictureURL?: string | undefined;
    /** hmmm */
    pDSKey?: string | undefined;
    /** This data is locked in memory */
    isDSProtected: boolean;
}

export class PasswordConfiguredOptions implements IPasswordConfiguredOptions {

    constructor(data?: IPasswordConfiguredOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PasswordConfiguredOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordConfiguredOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): PasswordConfiguredOptions {
        const json = this.toJSON();
        let result = new PasswordConfiguredOptions();
        result.init(json);
        return result;
    }
}

export interface IPasswordConfiguredOptions {
}

/** Permission required flag -- bit flags can be combined */
export enum PermissionFlags {
    None = 0,
    Read = 1,
    Insert = 2,
    Update = 4,
    Delete = 8,
    Blanket = 16,
}

/** Describes permission being demanded and the context */
export class PermissionContext implements IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    uCModule!: string;
    /** Internal Name (see xsfUCFunction) */
    uCFunction!: string;
    /** Project ID  */
    project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    docMasterKey!: string;
    /** Document Type */
    docTypeKey!: string;
    /** Doc Reference (seldom used) */
    docReference!: string;
    /** Bit Coded R I U D S  */
    permissionNeeded!: PermissionFlags;

    constructor(data?: IPermissionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uCModule = _data["UCModule"];
            this.uCFunction = _data["UCFunction"];
            this.project = _data["Project"];
            this.docMasterKey = _data["DocMasterKey"];
            this.docTypeKey = _data["DocTypeKey"];
            this.docReference = _data["DocReference"];
            this.permissionNeeded = _data["PermissionNeeded"];
        }
    }

    static fromJS(data: any): PermissionContext {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UCModule"] = this.uCModule;
        data["UCFunction"] = this.uCFunction;
        data["Project"] = this.project;
        data["DocMasterKey"] = this.docMasterKey;
        data["DocTypeKey"] = this.docTypeKey;
        data["DocReference"] = this.docReference;
        data["PermissionNeeded"] = this.permissionNeeded;
        return data; 
    }

    clone(): PermissionContext {
        const json = this.toJSON();
        let result = new PermissionContext();
        result.init(json);
        return result;
    }
}

/** Describes permission being demanded and the context */
export interface IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    uCModule: string;
    /** Internal Name (see xsfUCFunction) */
    uCFunction: string;
    /** Project ID  */
    project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    docMasterKey: string;
    /** Document Type */
    docTypeKey: string;
    /** Doc Reference (seldom used) */
    docReference: string;
    /** Bit Coded R I U D S  */
    permissionNeeded: PermissionFlags;
}

export class TabStripDetails implements ITabStripDetails {
    tabId!: number;
    tabKey?: string | undefined;
    tabText?: string | undefined;
    tabOrder!: number;
    tabType?: string | undefined;
    authorizedRoles?: string | undefined;
    linkURL?: string | undefined;
    tip?: string | undefined;
    isVisible!: boolean;

    constructor(data?: ITabStripDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tabId = _data["TabId"];
            this.tabKey = _data["TabKey"];
            this.tabText = _data["TabText"];
            this.tabOrder = _data["TabOrder"];
            this.tabType = _data["TabType"];
            this.authorizedRoles = _data["AuthorizedRoles"];
            this.linkURL = _data["LinkURL"];
            this.tip = _data["Tip"];
            this.isVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): TabStripDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TabStripDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TabId"] = this.tabId;
        data["TabKey"] = this.tabKey;
        data["TabText"] = this.tabText;
        data["TabOrder"] = this.tabOrder;
        data["TabType"] = this.tabType;
        data["AuthorizedRoles"] = this.authorizedRoles;
        data["LinkURL"] = this.linkURL;
        data["Tip"] = this.tip;
        data["IsVisible"] = this.isVisible;
        return data; 
    }

    clone(): TabStripDetails {
        const json = this.toJSON();
        let result = new TabStripDetails();
        result.init(json);
        return result;
    }
}

export interface ITabStripDetails {
    tabId: number;
    tabKey?: string | undefined;
    tabText?: string | undefined;
    tabOrder: number;
    tabType?: string | undefined;
    authorizedRoles?: string | undefined;
    linkURL?: string | undefined;
    tip?: string | undefined;
    isVisible: boolean;
}

/** Describes a set of permissions for this user */
export class UCPermitSet implements IUCPermitSet {
    /** Key of this item */
    project!: string;
    /** Links to Module|Function  */
    permits!: { [key: string]: UCPermit[]; };

    constructor(data?: IUCPermitSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permits = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["Project"];
            if (_data["Permits"]) {
                this.permits = {} as any;
                for (let key in _data["Permits"]) {
                    if (_data["Permits"].hasOwnProperty(key))
                        this.permits![key] = _data["Permits"][key] ? _data["Permits"][key].map((i: any) => UCPermit.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): UCPermitSet {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermitSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.project;
        if (this.permits) {
            data["Permits"] = {};
            for (let key in this.permits) {
                if (this.permits.hasOwnProperty(key))
                    data["Permits"][key] = this.permits[key];
            }
        }
        return data; 
    }

    clone(): UCPermitSet {
        const json = this.toJSON();
        let result = new UCPermitSet();
        result.init(json);
        return result;
    }
}

/** Describes a set of permissions for this user */
export interface IUCPermitSet {
    /** Key of this item */
    project: string;
    /** Links to Module|Function  */
    permits: { [key: string]: UCPermit[]; };
}

/** Permissions for a specific function */
export class UCPermit implements IUCPermit {
    /** If not empty, for a specific document (rare) */
    docMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    docReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    docTypeKey?: string | undefined;
    /** When true, has read permission */
    readOK!: boolean;
    /** When true, has read permission */
    insOK!: boolean;
    /** When true, has read permission */
    updOK!: boolean;
    /** When true, has read permission */
    delOK!: boolean;
    /** When true, has read permission */
    blanketOK!: boolean;
    /** When true, there is no restriction on this permission */
    isGlobal!: boolean;

    constructor(data?: IUCPermit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMasterKey = _data["DocMasterKey"];
            this.docReference = _data["DocReference"];
            this.docTypeKey = _data["DocTypeKey"];
            this.readOK = _data["ReadOK"];
            this.insOK = _data["InsOK"];
            this.updOK = _data["UpdOK"];
            this.delOK = _data["DelOK"];
            this.blanketOK = _data["BlanketOK"];
            this.isGlobal = _data["IsGlobal"];
        }
    }

    static fromJS(data: any): UCPermit {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.docMasterKey;
        data["DocReference"] = this.docReference;
        data["DocTypeKey"] = this.docTypeKey;
        data["ReadOK"] = this.readOK;
        data["InsOK"] = this.insOK;
        data["UpdOK"] = this.updOK;
        data["DelOK"] = this.delOK;
        data["BlanketOK"] = this.blanketOK;
        data["IsGlobal"] = this.isGlobal;
        return data; 
    }

    clone(): UCPermit {
        const json = this.toJSON();
        let result = new UCPermit();
        result.init(json);
        return result;
    }
}

/** Permissions for a specific function */
export interface IUCPermit {
    /** If not empty, for a specific document (rare) */
    docMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    docReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    docTypeKey?: string | undefined;
    /** When true, has read permission */
    readOK: boolean;
    /** When true, has read permission */
    insOK: boolean;
    /** When true, has read permission */
    updOK: boolean;
    /** When true, has read permission */
    delOK: boolean;
    /** When true, has read permission */
    blanketOK: boolean;
    /** When true, there is no restriction on this permission */
    isGlobal: boolean;
}

/** Passes data to a simple API */
export class APIData implements IAPIData {
    /** Raw Data */
    data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    isURIEncoded!: boolean;

    constructor(data?: IAPIData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["Data"];
            this.isURIEncoded = _data["IsURIEncoded"];
        }
    }

    static fromJS(data: any): APIData {
        data = typeof data === 'object' ? data : {};
        let result = new APIData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        data["IsURIEncoded"] = this.isURIEncoded;
        return data; 
    }

    clone(): APIData {
        const json = this.toJSON();
        let result = new APIData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IAPIData {
    /** Raw Data */
    data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    isURIEncoded: boolean;
}

/** Passes data to a simple API */
export class PDSData extends APIData implements IPDSData {
    /** ID of data set */
    pDSKey?: string | undefined;
    /** Type of change (put, set) */
    mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    path?: string | undefined;
    /** Type of data (boolean,string) */
    type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    updateReadOnly!: boolean;

    constructor(data?: IPDSData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pDSKey = _data["PDSKey"];
            this.mode = _data["Mode"];
            this.path = _data["Path"];
            this.type = _data["Type"];
            this.updateReadOnly = _data["UpdateReadOnly"];
        }
    }

    static fromJS(data: any): PDSData {
        data = typeof data === 'object' ? data : {};
        let result = new PDSData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PDSKey"] = this.pDSKey;
        data["Mode"] = this.mode;
        data["Path"] = this.path;
        data["Type"] = this.type;
        data["UpdateReadOnly"] = this.updateReadOnly;
        super.toJSON(data);
        return data; 
    }

    clone(): PDSData {
        const json = this.toJSON();
        let result = new PDSData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IPDSData extends IAPIData {
    /** ID of data set */
    pDSKey?: string | undefined;
    /** Type of change (put, set) */
    mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    path?: string | undefined;
    /** Type of data (boolean,string) */
    type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    updateReadOnly: boolean;
}

/** Attributes describing a member of a project team */
export class ProjectTeamMember implements IProjectTeamMember {
    /** Primary Key */
    userProjectKey!: string;
    /** Key of Team Member in contact table */
    userKey!: string;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    responsibility!: string;
    /** Login name of the team member */
    userName?: string | undefined;
    /** Company Name (Acme Inc) */
    company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    usePhone?: string | undefined;
    /** Freeform: how the team member designates this project   */
    contactProject?: string | undefined;
    /** Role Description */
    roleDescription?: string | undefined;
    /** Role Name (see Responsibility) */
    roleName?: string | undefined;
    /** Link to likeness of this team member */
    likenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    webURL?: string | undefined;
    /** By default, When the team member was added  */
    starting!: Date;
    /** When the team member left (or was replaced) */
    ending!: Date;
    /** When TRUE,  shown by default */
    teamList!: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    isPublic!: boolean;
    /** When TRUE, this team member is active */
    active!: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    userNotPublic!: boolean;
    /** When TRUE, the contact for this team member has been marked inactive */
    userNotActive!: boolean;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IProjectTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userProjectKey = _data["UserProjectKey"];
            this.userKey = _data["UserKey"];
            this.responsibility = _data["Responsibility"];
            this.userName = _data["UserName"];
            this.company = _data["Company"];
            this.email = _data["email"];
            this.usePhone = _data["UsePhone"];
            this.contactProject = _data["ContactProject"];
            this.roleDescription = _data["RoleDescription"];
            this.roleName = _data["RoleName"];
            this.likenessURL = _data["LikenessURL"];
            this.webURL = _data["WebURL"];
            this.starting = _data["Starting"] ? new Date(_data["Starting"].toString()) : <any>undefined;
            this.ending = _data["Ending"] ? new Date(_data["Ending"].toString()) : <any>undefined;
            this.teamList = _data["TeamList"];
            this.isPublic = _data["IsPublic"];
            this.active = _data["Active"];
            this.userNotPublic = _data["UserNotPublic"];
            this.userNotActive = _data["UserNotActive"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTeamMember {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserProjectKey"] = this.userProjectKey;
        data["UserKey"] = this.userKey;
        data["Responsibility"] = this.responsibility;
        data["UserName"] = this.userName;
        data["Company"] = this.company;
        data["email"] = this.email;
        data["UsePhone"] = this.usePhone;
        data["ContactProject"] = this.contactProject;
        data["RoleDescription"] = this.roleDescription;
        data["RoleName"] = this.roleName;
        data["LikenessURL"] = this.likenessURL;
        data["WebURL"] = this.webURL;
        data["Starting"] = this.starting ? this.starting.toISOString() : <any>undefined;
        data["Ending"] = this.ending ? this.ending.toISOString() : <any>undefined;
        data["TeamList"] = this.teamList;
        data["IsPublic"] = this.isPublic;
        data["Active"] = this.active;
        data["UserNotPublic"] = this.userNotPublic;
        data["UserNotActive"] = this.userNotActive;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectTeamMember {
        const json = this.toJSON();
        let result = new ProjectTeamMember();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface IProjectTeamMember {
    /** Primary Key */
    userProjectKey: string;
    /** Key of Team Member in contact table */
    userKey: string;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    responsibility: string;
    /** Login name of the team member */
    userName?: string | undefined;
    /** Company Name (Acme Inc) */
    company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    usePhone?: string | undefined;
    /** Freeform: how the team member designates this project   */
    contactProject?: string | undefined;
    /** Role Description */
    roleDescription?: string | undefined;
    /** Role Name (see Responsibility) */
    roleName?: string | undefined;
    /** Link to likeness of this team member */
    likenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    webURL?: string | undefined;
    /** By default, When the team member was added  */
    starting: Date;
    /** When the team member left (or was replaced) */
    ending: Date;
    /** When TRUE,  shown by default */
    teamList: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    isPublic: boolean;
    /** When TRUE, this team member is active */
    active: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    userNotPublic: boolean;
    /** When TRUE, the contact for this team member has been marked inactive */
    userNotActive: boolean;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Readonly description of an cost transaction posted to a project */
export class FileAccessHistory implements IFileAccessHistory {
    /** User Name   */
    userName?: string | undefined;
    /** File Name   */
    fileName?: string | undefined;
    /** File Revision number (starts with 1) */
    revID!: number;
    /** When this access transaction occurred */
    accessed!: Date;
    /** Type of Access */
    accessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    withDocument?: string | undefined;
    /** Additional information about access  */
    accessInfo?: string | undefined;
    /** Was the file in cache */
    usedCache!: boolean;
    /** User Key  for this transaction  */
    userKey!: string;
    /** Document Key  for this transaction  */
    docMasterKey?: string | undefined;

    constructor(data?: IFileAccessHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.fileName = _data["FileName"];
            this.revID = _data["RevID"];
            this.accessed = _data["Accessed"] ? new Date(_data["Accessed"].toString()) : <any>undefined;
            this.accessType = _data["AccessType"];
            this.withDocument = _data["WithDocument"];
            this.accessInfo = _data["AccessInfo"];
            this.usedCache = _data["UsedCache"];
            this.userKey = _data["UserKey"];
            this.docMasterKey = _data["DocMasterKey"];
        }
    }

    static fromJS(data: any): FileAccessHistory {
        data = typeof data === 'object' ? data : {};
        let result = new FileAccessHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["FileName"] = this.fileName;
        data["RevID"] = this.revID;
        data["Accessed"] = this.accessed ? this.accessed.toISOString() : <any>undefined;
        data["AccessType"] = this.accessType;
        data["WithDocument"] = this.withDocument;
        data["AccessInfo"] = this.accessInfo;
        data["UsedCache"] = this.usedCache;
        data["UserKey"] = this.userKey;
        data["DocMasterKey"] = this.docMasterKey;
        return data; 
    }

    clone(): FileAccessHistory {
        const json = this.toJSON();
        let result = new FileAccessHistory();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IFileAccessHistory {
    /** User Name   */
    userName?: string | undefined;
    /** File Name   */
    fileName?: string | undefined;
    /** File Revision number (starts with 1) */
    revID: number;
    /** When this access transaction occurred */
    accessed: Date;
    /** Type of Access */
    accessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    withDocument?: string | undefined;
    /** Additional information about access  */
    accessInfo?: string | undefined;
    /** Was the file in cache */
    usedCache: boolean;
    /** User Key  for this transaction  */
    userKey: string;
    /** Document Key  for this transaction  */
    docMasterKey?: string | undefined;
}

/** Information about file versions */
export class FileVersion implements IFileVersion {
    /** Link to xsfFileVersionInfo */
    fileVerKey!: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    revID!: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    dataHash?: string | undefined;
    /** External reference */
    sourceRevision?: string | undefined;
    /** When stored */
    cataloged!: Date;
    /** When Approved */
    approved!: Date;
    /** User that approved this */
    approvedBy!: string;
    /** Links to a user/contact  */
    fromUser!: string;
    /** text from binary (for index/search) */
    txtData?: string | undefined;
    /** Size of file binary data in bytes  */
    binSize!: number;
    /** True on the file version that is the newest one with approved not empty  */
    isCurrentApprovedVersion!: boolean;
    /** When not empty, reason this version cannot be removed */
    noCanDelete?: string | undefined;

    constructor(data?: IFileVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileVerKey = _data["FileVerKey"];
            this.revID = _data["RevID"];
            this.dataHash = _data["DataHash"];
            this.sourceRevision = _data["SourceRevision"];
            this.cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.approved = _data["Approved"] ? new Date(_data["Approved"].toString()) : <any>undefined;
            this.approvedBy = _data["ApprovedBy"];
            this.fromUser = _data["FromUser"];
            this.txtData = _data["TxtData"];
            this.binSize = _data["BinSize"];
            this.isCurrentApprovedVersion = _data["IsCurrentApprovedVersion"];
            this.noCanDelete = _data["NoCanDelete"];
        }
    }

    static fromJS(data: any): FileVersion {
        data = typeof data === 'object' ? data : {};
        let result = new FileVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileVerKey"] = this.fileVerKey;
        data["RevID"] = this.revID;
        data["DataHash"] = this.dataHash;
        data["SourceRevision"] = this.sourceRevision;
        data["Cataloged"] = this.cataloged ? this.cataloged.toISOString() : <any>undefined;
        data["Approved"] = this.approved ? this.approved.toISOString() : <any>undefined;
        data["ApprovedBy"] = this.approvedBy;
        data["FromUser"] = this.fromUser;
        data["TxtData"] = this.txtData;
        data["BinSize"] = this.binSize;
        data["IsCurrentApprovedVersion"] = this.isCurrentApprovedVersion;
        data["NoCanDelete"] = this.noCanDelete;
        return data; 
    }

    clone(): FileVersion {
        const json = this.toJSON();
        let result = new FileVersion();
        result.init(json);
        return result;
    }
}

/** Information about file versions */
export interface IFileVersion {
    /** Link to xsfFileVersionInfo */
    fileVerKey: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    revID: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    dataHash?: string | undefined;
    /** External reference */
    sourceRevision?: string | undefined;
    /** When stored */
    cataloged: Date;
    /** When Approved */
    approved: Date;
    /** User that approved this */
    approvedBy: string;
    /** Links to a user/contact  */
    fromUser: string;
    /** text from binary (for index/search) */
    txtData?: string | undefined;
    /** Size of file binary data in bytes  */
    binSize: number;
    /** True on the file version that is the newest one with approved not empty  */
    isCurrentApprovedVersion: boolean;
    /** When not empty, reason this version cannot be removed */
    noCanDelete?: string | undefined;
}

/** A document currently routed to a specific user */
export class UserActionItem implements IUserActionItem {
    /** Key for the document */
    docMasterKey!: string;
    /** key for the route on the document */
    routeID!: string;
    /** key for the type of document */
    docTypeKey!: string;
    /** Resolved Name of the document/process type */
    docType?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Document Number */
    docNo?: string | undefined;
    /** Document Batch (seldom used) */
    docBatchNo?: string | undefined;
    /** Due Date */
    due?: Date | undefined;
    /** Title */
    title?: string | undefined;
    /** Key for Contact this document is "from" */
    fromUser!: string;
    /** Key for Primary contact on this document */
    primaryContact!: string;
    /** Priority (1=high) */
    priority!: number;
    /** Date this route was viewed */
    viewed?: Date | undefined;
    /** Date this document was closed (or null) */
    closed?: Date | undefined;
    /** Date this route was reaced */
    reached!: Date;
    /** Route Instructions */
    note?: string | undefined;
    /** Resolved Status of document */
    statusText?: string | undefined;
    /** Status Code */
    status?: string | undefined;
    /** Company Name */
    company?: string | undefined;
    /** Current Route Sequence */
    sequence!: number;
    /** When TRUE, it is OK to release this document without opening it */
    okToRelease!: boolean;
    /** When True, is recent  */
    isRecent!: boolean;
    /** How many files are attached */
    filesAttached!: number;

    constructor(data?: IUserActionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMasterKey = _data["DocMasterKey"];
            this.routeID = _data["RouteID"];
            this.docTypeKey = _data["DocTypeKey"];
            this.docType = _data["DocType"];
            this.project = _data["Project"];
            this.docNo = _data["DocNo"];
            this.docBatchNo = _data["DocBatchNo"];
            this.due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.title = _data["Title"];
            this.fromUser = _data["FromUser"];
            this.primaryContact = _data["PrimaryContact"];
            this.priority = _data["Priority"];
            this.viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.note = _data["Note"];
            this.statusText = _data["StatusText"];
            this.status = _data["Status"];
            this.company = _data["Company"];
            this.sequence = _data["Sequence"];
            this.okToRelease = _data["OkToRelease"];
            this.isRecent = _data["IsRecent"];
            this.filesAttached = _data["FilesAttached"];
        }
    }

    static fromJS(data: any): UserActionItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.docMasterKey;
        data["RouteID"] = this.routeID;
        data["DocTypeKey"] = this.docTypeKey;
        data["DocType"] = this.docType;
        data["Project"] = this.project;
        data["DocNo"] = this.docNo;
        data["DocBatchNo"] = this.docBatchNo;
        data["Due"] = this.due ? this.due.toISOString() : <any>undefined;
        data["Title"] = this.title;
        data["FromUser"] = this.fromUser;
        data["PrimaryContact"] = this.primaryContact;
        data["Priority"] = this.priority;
        data["Viewed"] = this.viewed ? this.viewed.toISOString() : <any>undefined;
        data["Closed"] = this.closed ? this.closed.toISOString() : <any>undefined;
        data["Reached"] = this.reached ? this.reached.toISOString() : <any>undefined;
        data["Note"] = this.note;
        data["StatusText"] = this.statusText;
        data["Status"] = this.status;
        data["Company"] = this.company;
        data["Sequence"] = this.sequence;
        data["OkToRelease"] = this.okToRelease;
        data["IsRecent"] = this.isRecent;
        data["FilesAttached"] = this.filesAttached;
        return data; 
    }

    clone(): UserActionItem {
        const json = this.toJSON();
        let result = new UserActionItem();
        result.init(json);
        return result;
    }
}

/** A document currently routed to a specific user */
export interface IUserActionItem {
    /** Key for the document */
    docMasterKey: string;
    /** key for the route on the document */
    routeID: string;
    /** key for the type of document */
    docTypeKey: string;
    /** Resolved Name of the document/process type */
    docType?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Document Number */
    docNo?: string | undefined;
    /** Document Batch (seldom used) */
    docBatchNo?: string | undefined;
    /** Due Date */
    due?: Date | undefined;
    /** Title */
    title?: string | undefined;
    /** Key for Contact this document is "from" */
    fromUser: string;
    /** Key for Primary contact on this document */
    primaryContact: string;
    /** Priority (1=high) */
    priority: number;
    /** Date this route was viewed */
    viewed?: Date | undefined;
    /** Date this document was closed (or null) */
    closed?: Date | undefined;
    /** Date this route was reaced */
    reached: Date;
    /** Route Instructions */
    note?: string | undefined;
    /** Resolved Status of document */
    statusText?: string | undefined;
    /** Status Code */
    status?: string | undefined;
    /** Company Name */
    company?: string | undefined;
    /** Current Route Sequence */
    sequence: number;
    /** When TRUE, it is OK to release this document without opening it */
    okToRelease: boolean;
    /** When True, is recent  */
    isRecent: boolean;
    /** How many files are attached */
    filesAttached: number;
}

export class RouteActionInfo implements IRouteActionInfo {
    docMasterKey!: string;
    userName?: string | undefined;
    title?: string | undefined;
    docNo?: string | undefined;
    type?: string | undefined;
    project?: string | undefined;
    status?: string | undefined;
    company?: string | undefined;
    priority!: number;
    sequence!: number;
    due?: string | undefined;
    viewed?: string | undefined;
    alerted?: string | undefined;
    downloaded?: string | undefined;
    fromActed?: string | undefined;
    creatorActed?: string | undefined;
    okToRelease!: boolean;
    showRouteResponseCode!: boolean;
    showRouteResponseArea!: boolean;
    hardCopyCount!: number;
    okToReleaseCount!: number;
    releaseMatchCount!: number;
    responseCode?: string | undefined;
    note?: string | undefined;
    response?: string | undefined;
    instructions?: string | undefined;
    fromWho?: string | undefined;
    createdBy?: string | undefined;
    nextWho?: string | undefined;
    accessSummary?: string | undefined;
    docAccessHistoryReportURL?: string | undefined;
    lastSaved?: string | undefined;
    exclusiveTo?: string | undefined;
    docTypeKey!: string;
    statusChoices?: SelectCodeNode[] | undefined;
    responseCodeChoices?: SelectCodeNode[] | undefined;
    matchingDocs?: SelectCodeNode[] | undefined;
    eligibleDocs?: SelectCodeNode[] | undefined;

    constructor(data?: IRouteActionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMasterKey = _data["DocMasterKey"];
            this.userName = _data["UserName"];
            this.title = _data["Title"];
            this.docNo = _data["DocNo"];
            this.type = _data["Type"];
            this.project = _data["Project"];
            this.status = _data["Status"];
            this.company = _data["Company"];
            this.priority = _data["Priority"];
            this.sequence = _data["Sequence"];
            this.due = _data["Due"];
            this.viewed = _data["Viewed"];
            this.alerted = _data["Alerted"];
            this.downloaded = _data["Downloaded"];
            this.fromActed = _data["FromActed"];
            this.creatorActed = _data["CreatorActed"];
            this.okToRelease = _data["OkToRelease"];
            this.showRouteResponseCode = _data["ShowRouteResponseCode"];
            this.showRouteResponseArea = _data["ShowRouteResponseArea"];
            this.hardCopyCount = _data["HardCopyCount"];
            this.okToReleaseCount = _data["OkToReleaseCount"];
            this.releaseMatchCount = _data["ReleaseMatchCount"];
            this.responseCode = _data["ResponseCode"];
            this.note = _data["Note"];
            this.response = _data["Response"];
            this.instructions = _data["Instructions"];
            this.fromWho = _data["FromWho"];
            this.createdBy = _data["CreatedBy"];
            this.nextWho = _data["NextWho"];
            this.accessSummary = _data["AccessSummary"];
            this.docAccessHistoryReportURL = _data["DocAccessHistoryReportURL"];
            this.lastSaved = _data["LastSaved"];
            this.exclusiveTo = _data["ExclusiveTo"];
            this.docTypeKey = _data["DocTypeKey"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.statusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.statusChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.responseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.responseCodeChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["MatchingDocs"])) {
                this.matchingDocs = [] as any;
                for (let item of _data["MatchingDocs"])
                    this.matchingDocs!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["EligibleDocs"])) {
                this.eligibleDocs = [] as any;
                for (let item of _data["EligibleDocs"])
                    this.eligibleDocs!.push(SelectCodeNode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.docMasterKey;
        data["UserName"] = this.userName;
        data["Title"] = this.title;
        data["DocNo"] = this.docNo;
        data["Type"] = this.type;
        data["Project"] = this.project;
        data["Status"] = this.status;
        data["Company"] = this.company;
        data["Priority"] = this.priority;
        data["Sequence"] = this.sequence;
        data["Due"] = this.due;
        data["Viewed"] = this.viewed;
        data["Alerted"] = this.alerted;
        data["Downloaded"] = this.downloaded;
        data["FromActed"] = this.fromActed;
        data["CreatorActed"] = this.creatorActed;
        data["OkToRelease"] = this.okToRelease;
        data["ShowRouteResponseCode"] = this.showRouteResponseCode;
        data["ShowRouteResponseArea"] = this.showRouteResponseArea;
        data["HardCopyCount"] = this.hardCopyCount;
        data["OkToReleaseCount"] = this.okToReleaseCount;
        data["ReleaseMatchCount"] = this.releaseMatchCount;
        data["ResponseCode"] = this.responseCode;
        data["Note"] = this.note;
        data["Response"] = this.response;
        data["Instructions"] = this.instructions;
        data["FromWho"] = this.fromWho;
        data["CreatedBy"] = this.createdBy;
        data["NextWho"] = this.nextWho;
        data["AccessSummary"] = this.accessSummary;
        data["DocAccessHistoryReportURL"] = this.docAccessHistoryReportURL;
        data["LastSaved"] = this.lastSaved;
        data["ExclusiveTo"] = this.exclusiveTo;
        data["DocTypeKey"] = this.docTypeKey;
        if (Array.isArray(this.statusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.statusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.responseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.responseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.matchingDocs)) {
            data["MatchingDocs"] = [];
            for (let item of this.matchingDocs)
                data["MatchingDocs"].push(item.toJSON());
        }
        if (Array.isArray(this.eligibleDocs)) {
            data["EligibleDocs"] = [];
            for (let item of this.eligibleDocs)
                data["EligibleDocs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RouteActionInfo {
        const json = this.toJSON();
        let result = new RouteActionInfo();
        result.init(json);
        return result;
    }
}

export interface IRouteActionInfo {
    docMasterKey: string;
    userName?: string | undefined;
    title?: string | undefined;
    docNo?: string | undefined;
    type?: string | undefined;
    project?: string | undefined;
    status?: string | undefined;
    company?: string | undefined;
    priority: number;
    sequence: number;
    due?: string | undefined;
    viewed?: string | undefined;
    alerted?: string | undefined;
    downloaded?: string | undefined;
    fromActed?: string | undefined;
    creatorActed?: string | undefined;
    okToRelease: boolean;
    showRouteResponseCode: boolean;
    showRouteResponseArea: boolean;
    hardCopyCount: number;
    okToReleaseCount: number;
    releaseMatchCount: number;
    responseCode?: string | undefined;
    note?: string | undefined;
    response?: string | undefined;
    instructions?: string | undefined;
    fromWho?: string | undefined;
    createdBy?: string | undefined;
    nextWho?: string | undefined;
    accessSummary?: string | undefined;
    docAccessHistoryReportURL?: string | undefined;
    lastSaved?: string | undefined;
    exclusiveTo?: string | undefined;
    docTypeKey: string;
    statusChoices?: SelectCodeNode[] | undefined;
    responseCodeChoices?: SelectCodeNode[] | undefined;
    matchingDocs?: SelectCodeNode[] | undefined;
    eligibleDocs?: SelectCodeNode[] | undefined;
}

export class SelectCodeNode implements ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectCodeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectCodeNode {
        data = typeof data === 'object' ? data : {};
        let result = new SelectCodeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectCodeNode {
        const json = this.toJSON();
        let result = new SelectCodeNode();
        result.init(json);
        return result;
    }
}

export interface ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;
}

/** Data to apply to the route being patched */
export class RouteActionData implements IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    newStatus?: string | undefined;
    /** Response Code */
    responseCode?: string | undefined;
    /** Freeform text for response note */
    responseText?: string | undefined;

    constructor(data?: IRouteActionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newStatus = _data["NewStatus"];
            this.responseCode = _data["ResponseCode"];
            this.responseText = _data["ResponseText"];
        }
    }

    static fromJS(data: any): RouteActionData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewStatus"] = this.newStatus;
        data["ResponseCode"] = this.responseCode;
        data["ResponseText"] = this.responseText;
        return data; 
    }

    clone(): RouteActionData {
        const json = this.toJSON();
        let result = new RouteActionData();
        result.init(json);
        return result;
    }
}

/** Data to apply to the route being patched */
export interface IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    newStatus?: string | undefined;
    /** Response Code */
    responseCode?: string | undefined;
    /** Freeform text for response note */
    responseText?: string | undefined;
}

/** Summary of Project Process (Document) types */
export class TypeSummary implements ITypeSummary {
    /** Key for Process Type */
    docTypeKey!: string;
    /** String Process (Doc Type) Name */
    docType?: string | undefined;
    /** Number of documents currently open */
    cnt_open!: number;
    /** Number of documents closed */
    cnt_closed!: number;
    /** Number of documents overdue */
    cnt_overdue!: number;
    /** Number of documents due soon */
    cnt_DueSoon!: number;
    /** Number of days tile due */
    daysTillDue!: number;
    /** User has permission to create  */
    canAdd!: boolean;

    constructor(data?: ITypeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docTypeKey = _data["DocTypeKey"];
            this.docType = _data["DocType"];
            this.cnt_open = _data["cnt_open"];
            this.cnt_closed = _data["cnt_closed"];
            this.cnt_overdue = _data["cnt_overdue"];
            this.cnt_DueSoon = _data["cnt_DueSoon"];
            this.daysTillDue = _data["DaysTillDue"];
            this.canAdd = _data["CanAdd"];
        }
    }

    static fromJS(data: any): TypeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new TypeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocTypeKey"] = this.docTypeKey;
        data["DocType"] = this.docType;
        data["cnt_open"] = this.cnt_open;
        data["cnt_closed"] = this.cnt_closed;
        data["cnt_overdue"] = this.cnt_overdue;
        data["cnt_DueSoon"] = this.cnt_DueSoon;
        data["DaysTillDue"] = this.daysTillDue;
        data["CanAdd"] = this.canAdd;
        return data; 
    }

    clone(): TypeSummary {
        const json = this.toJSON();
        let result = new TypeSummary();
        result.init(json);
        return result;
    }
}

/** Summary of Project Process (Document) types */
export interface ITypeSummary {
    /** Key for Process Type */
    docTypeKey: string;
    /** String Process (Doc Type) Name */
    docType?: string | undefined;
    /** Number of documents currently open */
    cnt_open: number;
    /** Number of documents closed */
    cnt_closed: number;
    /** Number of documents overdue */
    cnt_overdue: number;
    /** Number of documents due soon */
    cnt_DueSoon: number;
    /** Number of days tile due */
    daysTillDue: number;
    /** User has permission to create  */
    canAdd: boolean;
}

/** Process Document on a Project */
export class ProjectDocsOfType implements IProjectDocsOfType {
    /** Key to Document (required to open) */
    docMasterKey!: string;
    /** Type of Process */
    docTypeKey!: string;
    /** Key to Process Reference */
    docReference!: string;
    /** Document Date (header) */
    docDate!: Date;
    /** Document Number (header; usually read only) */
    docNo?: string | undefined;
    /** Batch Number (often unused) */
    docBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    sourceDocNo?: string | undefined;
    /** Document Title */
    title?: string | undefined;
    /** Document Priority 1==High */
    priority!: number;
    /** When true, document is confidential (only name routes have access) */
    confidential!: boolean;
    /** Key to Contact document was "from") */
    fromUser!: string;
    /** Resolved name of user the Document is "from" */
    sortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    responsibleParty!: string;
    /** Resolved name of Responsible Party */
    sortResp?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    company!: string;
    /** Resolved Company Name  of the source Contact  */
    sortCompany?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    toUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    sortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    author?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person)   */
    sortAuthor?: string | undefined;
    /** When the document/process is due */
    due!: Date;
    /** when the document/process was approved */
    signoff?: Date | undefined;
    /** when the document/process was closed */
    closed?: Date | undefined;
    /** Project ID */
    project?: string | undefined;
    /** check this */
    specSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    subContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    payControl?: string | undefined;
    /** Subtype code */
    subtype?: string | undefined;
    /** Resolved name of subtype */
    subtypeDescription?: string | undefined;
    /** Status Code */
    status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    costImpact!: number;
    /** Custome Amount */
    csAmount!: number;
    /** Subsegment code */
    subsegment?: string | undefined;
    /** Contract type code */
    contractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    sourceDate?: Date | undefined;
    /** Payment Item Number */
    payItemNumber?: string | undefined;
    /** External Doc Number */
    externalDocNo?: string | undefined;
    /** Specification (document header) */
    specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    sourceContact!: string;
    /** Current Routing sequence (zero if route is complete) */
    currentSeq!: number;
    /** Number of stages of routing  */
    maxStage!: number;
    /** How many files are attached */
    filesAttached!: number;

    constructor(data?: IProjectDocsOfType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMasterKey = _data["DocMasterKey"];
            this.docTypeKey = _data["DocTypeKey"];
            this.docReference = _data["DocReference"];
            this.docDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.docNo = _data["DocNo"];
            this.docBatchNo = _data["DocBatchNo"];
            this.sourceDocNo = _data["SourceDocNo"];
            this.title = _data["Title"];
            this.priority = _data["Priority"];
            this.confidential = _data["Confidential"];
            this.fromUser = _data["FromUser"];
            this.sortFrom = _data["SortFrom"];
            this.responsibleParty = _data["ResponsibleParty"];
            this.sortResp = _data["SortResp"];
            this.company = _data["Company"];
            this.sortCompany = _data["SortCompany"];
            this.toUser = _data["ToUser"];
            this.sortTo = _data["SortTo"];
            this.author = _data["Author"];
            this.sortAuthor = _data["SortAuthor"];
            this.due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.project = _data["Project"];
            this.specSection = _data["SpecSection"];
            this.subContract = _data["SubContract"];
            this.payControl = _data["PayControl"];
            this.subtype = _data["Subtype"];
            this.subtypeDescription = _data["SubtypeDescription"];
            this.status = _data["Status"];
            this.costImpact = _data["CostImpact"];
            this.csAmount = _data["csAmount"];
            this.subsegment = _data["Subsegment"];
            this.contractType = _data["ContractType"];
            this.sourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.payItemNumber = _data["PayItemNumber"];
            this.externalDocNo = _data["ExternalDocNo"];
            this.specification = _data["Specification"];
            this.sourceContact = _data["SourceContact"];
            this.currentSeq = _data["CurrentSeq"];
            this.maxStage = _data["MaxStage"];
            this.filesAttached = _data["FilesAttached"];
        }
    }

    static fromJS(data: any): ProjectDocsOfType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDocsOfType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.docMasterKey;
        data["DocTypeKey"] = this.docTypeKey;
        data["DocReference"] = this.docReference;
        data["DocDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["DocNo"] = this.docNo;
        data["DocBatchNo"] = this.docBatchNo;
        data["SourceDocNo"] = this.sourceDocNo;
        data["Title"] = this.title;
        data["Priority"] = this.priority;
        data["Confidential"] = this.confidential;
        data["FromUser"] = this.fromUser;
        data["SortFrom"] = this.sortFrom;
        data["ResponsibleParty"] = this.responsibleParty;
        data["SortResp"] = this.sortResp;
        data["Company"] = this.company;
        data["SortCompany"] = this.sortCompany;
        data["ToUser"] = this.toUser;
        data["SortTo"] = this.sortTo;
        data["Author"] = this.author;
        data["SortAuthor"] = this.sortAuthor;
        data["Due"] = this.due ? this.due.toISOString() : <any>undefined;
        data["Signoff"] = this.signoff ? this.signoff.toISOString() : <any>undefined;
        data["Closed"] = this.closed ? this.closed.toISOString() : <any>undefined;
        data["Project"] = this.project;
        data["SpecSection"] = this.specSection;
        data["SubContract"] = this.subContract;
        data["PayControl"] = this.payControl;
        data["Subtype"] = this.subtype;
        data["SubtypeDescription"] = this.subtypeDescription;
        data["Status"] = this.status;
        data["CostImpact"] = this.costImpact;
        data["csAmount"] = this.csAmount;
        data["Subsegment"] = this.subsegment;
        data["ContractType"] = this.contractType;
        data["SourceDate"] = this.sourceDate ? this.sourceDate.toISOString() : <any>undefined;
        data["PayItemNumber"] = this.payItemNumber;
        data["ExternalDocNo"] = this.externalDocNo;
        data["Specification"] = this.specification;
        data["SourceContact"] = this.sourceContact;
        data["CurrentSeq"] = this.currentSeq;
        data["MaxStage"] = this.maxStage;
        data["FilesAttached"] = this.filesAttached;
        return data; 
    }

    clone(): ProjectDocsOfType {
        const json = this.toJSON();
        let result = new ProjectDocsOfType();
        result.init(json);
        return result;
    }
}

/** Process Document on a Project */
export interface IProjectDocsOfType {
    /** Key to Document (required to open) */
    docMasterKey: string;
    /** Type of Process */
    docTypeKey: string;
    /** Key to Process Reference */
    docReference: string;
    /** Document Date (header) */
    docDate: Date;
    /** Document Number (header; usually read only) */
    docNo?: string | undefined;
    /** Batch Number (often unused) */
    docBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    sourceDocNo?: string | undefined;
    /** Document Title */
    title?: string | undefined;
    /** Document Priority 1==High */
    priority: number;
    /** When true, document is confidential (only name routes have access) */
    confidential: boolean;
    /** Key to Contact document was "from") */
    fromUser: string;
    /** Resolved name of user the Document is "from" */
    sortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    responsibleParty: string;
    /** Resolved name of Responsible Party */
    sortResp?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    company: string;
    /** Resolved Company Name  of the source Contact  */
    sortCompany?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    toUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    sortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    author?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person)   */
    sortAuthor?: string | undefined;
    /** When the document/process is due */
    due: Date;
    /** when the document/process was approved */
    signoff?: Date | undefined;
    /** when the document/process was closed */
    closed?: Date | undefined;
    /** Project ID */
    project?: string | undefined;
    /** check this */
    specSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    subContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    payControl?: string | undefined;
    /** Subtype code */
    subtype?: string | undefined;
    /** Resolved name of subtype */
    subtypeDescription?: string | undefined;
    /** Status Code */
    status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    costImpact: number;
    /** Custome Amount */
    csAmount: number;
    /** Subsegment code */
    subsegment?: string | undefined;
    /** Contract type code */
    contractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    sourceDate?: Date | undefined;
    /** Payment Item Number */
    payItemNumber?: string | undefined;
    /** External Doc Number */
    externalDocNo?: string | undefined;
    /** Specification (document header) */
    specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    sourceContact: string;
    /** Current Routing sequence (zero if route is complete) */
    currentSeq: number;
    /** Number of stages of routing  */
    maxStage: number;
    /** How many files are attached */
    filesAttached: number;
}

/** Describes an Alert Condition */
export class UserAlert implements IUserAlert {
    /** Key for Alert */
    alertKey!: string;
    /** Key for User for whom the alert was generated */
    userKey!: string;
    /** Document about which the alert was generated */
    docMasterKey!: string;
    /** Status of Alert (New, etc) */
    status?: string | undefined;
    /** Notification type (M for email) */
    notificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    created!: Date;
    /** For Email Notification Type, when was the email sent */
    notified!: Date;
    /** When was the alert viewed */
    viewed!: Date;
    /** When action is due */
    due!: Date;
    /** When closed (from document) */
    closed!: Date;
    /** Short Description of alert */
    description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    alertText?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    source?: string | undefined;
    /** Key from source to indentify its alerts */
    sourceKey?: string | undefined;
    /** Extra info for categorization */
    info1?: string | undefined;
    /** Extra info 2 */
    info2?: string | undefined;
    /** Files attached to document */
    filesAttached!: number;
    /** unused */
    msg_type?: string | undefined;
    /** unused */
    msg_key?: string | undefined;
    /** unused */
    msg_suffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    sIVAlert!: boolean;

    constructor(data?: IUserAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertKey = _data["AlertKey"];
            this.userKey = _data["UserKey"];
            this.docMasterKey = _data["DocMasterKey"];
            this.status = _data["Status"];
            this.notificationType = _data["NotificationType"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.notified = _data["Notified"] ? new Date(_data["Notified"].toString()) : <any>undefined;
            this.viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.description = _data["Description"];
            this.alertText = _data["AlertText"];
            this.project = _data["Project"];
            this.source = _data["Source"];
            this.sourceKey = _data["SourceKey"];
            this.info1 = _data["Info1"];
            this.info2 = _data["Info2"];
            this.filesAttached = _data["FilesAttached"];
            this.msg_type = _data["msg_type"];
            this.msg_key = _data["msg_key"];
            this.msg_suffix = _data["msg_suffix"];
            this.sIVAlert = _data["SIVAlert"];
        }
    }

    static fromJS(data: any): UserAlert {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AlertKey"] = this.alertKey;
        data["UserKey"] = this.userKey;
        data["DocMasterKey"] = this.docMasterKey;
        data["Status"] = this.status;
        data["NotificationType"] = this.notificationType;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["Notified"] = this.notified ? this.notified.toISOString() : <any>undefined;
        data["Viewed"] = this.viewed ? this.viewed.toISOString() : <any>undefined;
        data["Due"] = this.due ? this.due.toISOString() : <any>undefined;
        data["Closed"] = this.closed ? this.closed.toISOString() : <any>undefined;
        data["Description"] = this.description;
        data["AlertText"] = this.alertText;
        data["Project"] = this.project;
        data["Source"] = this.source;
        data["SourceKey"] = this.sourceKey;
        data["Info1"] = this.info1;
        data["Info2"] = this.info2;
        data["FilesAttached"] = this.filesAttached;
        data["msg_type"] = this.msg_type;
        data["msg_key"] = this.msg_key;
        data["msg_suffix"] = this.msg_suffix;
        data["SIVAlert"] = this.sIVAlert;
        return data; 
    }

    clone(): UserAlert {
        const json = this.toJSON();
        let result = new UserAlert();
        result.init(json);
        return result;
    }
}

/** Describes an Alert Condition */
export interface IUserAlert {
    /** Key for Alert */
    alertKey: string;
    /** Key for User for whom the alert was generated */
    userKey: string;
    /** Document about which the alert was generated */
    docMasterKey: string;
    /** Status of Alert (New, etc) */
    status?: string | undefined;
    /** Notification type (M for email) */
    notificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    created: Date;
    /** For Email Notification Type, when was the email sent */
    notified: Date;
    /** When was the alert viewed */
    viewed: Date;
    /** When action is due */
    due: Date;
    /** When closed (from document) */
    closed: Date;
    /** Short Description of alert */
    description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    alertText?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    source?: string | undefined;
    /** Key from source to indentify its alerts */
    sourceKey?: string | undefined;
    /** Extra info for categorization */
    info1?: string | undefined;
    /** Extra info 2 */
    info2?: string | undefined;
    /** Files attached to document */
    filesAttached: number;
    /** unused */
    msg_type?: string | undefined;
    /** unused */
    msg_key?: string | undefined;
    /** unused */
    msg_suffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    sIVAlert: boolean;
}

/** Describes a Part, including the fields available to this user */
export class UIDisplayPart implements IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    partName?: string | undefined;
    /** Display Name  */
    displayName?: string | undefined;
    /** Free form explaination or generic description   */
    description?: string | undefined;
    /** API hint */
    getAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    sortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    partType?: string | undefined;
    /** List of UI Items  */
    uIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    uIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    viaUI!: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI!: boolean;

    constructor(data?: IUIDisplayPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partName = _data["PartName"];
            this.displayName = _data["DisplayName"];
            this.description = _data["Description"];
            this.getAPI = _data["GetAPI"];
            this.sortHint = _data["SortHint"];
            this.partType = _data["PartType"];
            if (Array.isArray(_data["UIItems"])) {
                this.uIItems = [] as any;
                for (let item of _data["UIItems"])
                    this.uIItems!.push(UIDisplayConfig.fromJS(item));
            }
            if (Array.isArray(_data["UIFilters"])) {
                this.uIFilters = [] as any;
                for (let item of _data["UIFilters"])
                    this.uIFilters!.push(UIDisplayFilter.fromJS(item));
            }
            this.viaUI = _data["ViaUI"];
            this.wbxUI = _data["wbxUI"];
        }
    }

    static fromJS(data: any): UIDisplayPart {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartName"] = this.partName;
        data["DisplayName"] = this.displayName;
        data["Description"] = this.description;
        data["GetAPI"] = this.getAPI;
        data["SortHint"] = this.sortHint;
        data["PartType"] = this.partType;
        if (Array.isArray(this.uIItems)) {
            data["UIItems"] = [];
            for (let item of this.uIItems)
                data["UIItems"].push(item.toJSON());
        }
        if (Array.isArray(this.uIFilters)) {
            data["UIFilters"] = [];
            for (let item of this.uIFilters)
                data["UIFilters"].push(item.toJSON());
        }
        data["ViaUI"] = this.viaUI;
        data["wbxUI"] = this.wbxUI;
        return data; 
    }

    clone(): UIDisplayPart {
        const json = this.toJSON();
        let result = new UIDisplayPart();
        result.init(json);
        return result;
    }
}

/** Describes a Part, including the fields available to this user */
export interface IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    partName?: string | undefined;
    /** Display Name  */
    displayName?: string | undefined;
    /** Free form explaination or generic description   */
    description?: string | undefined;
    /** API hint */
    getAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    sortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    partType?: string | undefined;
    /** List of UI Items  */
    uIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    uIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    viaUI: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI: boolean;
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export class UIDisplayConfig implements IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    partConfigKey!: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    itemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    dataMember?: string | undefined;
    /** Name of a field in the schema */
    dataField?: string | undefined;
    /** The visible label for this entry */
    label?: string | undefined;
    /** Name of lookup */
    lookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    displayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    otherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    clickAction?: string | undefined;
    /** For quick help */
    helpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    limitTo!: number;
    /** Max characters, for character types, this is from database size */
    maxChars!: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    requiredBefore!: number;
    /** For controling tab order */
    seqData!: number;
    /** When TRUE, UI will be read only */
    isReadOnly!: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    visible!: boolean;
    /** When true, this data is object is from internal defaults */
    isInternalDefault!: boolean;
    /** CSS to be applied */
    cSS?: string | undefined;
    /** Client Side Describe Value name */
    dV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    dependsOn?: string | undefined;
    /** When 1, allow HTML */
    hTML!: boolean;
    /** HTML 5 Placeholder text */
    overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    shownWhen?: string | undefined;
    /** DV function used to validate */
    validateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    validateTextAgainst?: string | undefined;
    /** Max */
    validationMax?: string | undefined;
    /** Min */
    validationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    width!: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    widthCSS?: string | undefined;

    constructor(data?: IUIDisplayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partConfigKey = _data["PartConfigKey"];
            this.itemName = _data["ItemName"];
            this.dataMember = _data["DataMember"];
            this.dataField = _data["DataField"];
            this.label = _data["Label"];
            this.lookupName = _data["LookupName"];
            this.displayFormat = _data["DisplayFormat"];
            if (_data["OtherProperties"]) {
                this.otherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        this.otherProperties![key] = _data["OtherProperties"][key];
                }
            }
            this.clickAction = _data["ClickAction"];
            this.helpText = _data["HelpText"];
            this.limitTo = _data["LimitTo"];
            this.maxChars = _data["MaxChars"];
            this.requiredBefore = _data["RequiredBefore"];
            this.seqData = _data["SeqData"];
            this.isReadOnly = _data["IsReadOnly"];
            this.visible = _data["Visible"];
            this.isInternalDefault = _data["IsInternalDefault"];
            this.cSS = _data["CSS"];
            this.dV = _data["DV"];
            this.dependsOn = _data["DependsOn"];
            this.hTML = _data["HTML"];
            this.overlay = _data["Overlay"];
            this.shownWhen = _data["ShownWhen"];
            this.validateAgainst = _data["ValidateAgainst"];
            this.validateTextAgainst = _data["ValidateTextAgainst"];
            this.validationMax = _data["ValidationMax"];
            this.validationMin = _data["ValidationMin"];
            this.width = _data["Width"];
            this.widthCSS = _data["WidthCSS"];
        }
    }

    static fromJS(data: any): UIDisplayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.partConfigKey;
        data["ItemName"] = this.itemName;
        data["DataMember"] = this.dataMember;
        data["DataField"] = this.dataField;
        data["Label"] = this.label;
        data["LookupName"] = this.lookupName;
        data["DisplayFormat"] = this.displayFormat;
        if (this.otherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.otherProperties) {
                if (this.otherProperties.hasOwnProperty(key))
                    data["OtherProperties"][key] = this.otherProperties[key];
            }
        }
        data["ClickAction"] = this.clickAction;
        data["HelpText"] = this.helpText;
        data["LimitTo"] = this.limitTo;
        data["MaxChars"] = this.maxChars;
        data["RequiredBefore"] = this.requiredBefore;
        data["SeqData"] = this.seqData;
        data["IsReadOnly"] = this.isReadOnly;
        data["Visible"] = this.visible;
        data["IsInternalDefault"] = this.isInternalDefault;
        data["CSS"] = this.cSS;
        data["DV"] = this.dV;
        data["DependsOn"] = this.dependsOn;
        data["HTML"] = this.hTML;
        data["Overlay"] = this.overlay;
        data["ShownWhen"] = this.shownWhen;
        data["ValidateAgainst"] = this.validateAgainst;
        data["ValidateTextAgainst"] = this.validateTextAgainst;
        data["ValidationMax"] = this.validationMax;
        data["ValidationMin"] = this.validationMin;
        data["Width"] = this.width;
        data["WidthCSS"] = this.widthCSS;
        return data; 
    }

    clone(): UIDisplayConfig {
        const json = this.toJSON();
        let result = new UIDisplayConfig();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export interface IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    partConfigKey: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    itemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    dataMember?: string | undefined;
    /** Name of a field in the schema */
    dataField?: string | undefined;
    /** The visible label for this entry */
    label?: string | undefined;
    /** Name of lookup */
    lookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    displayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    otherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    clickAction?: string | undefined;
    /** For quick help */
    helpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    limitTo: number;
    /** Max characters, for character types, this is from database size */
    maxChars: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    requiredBefore: number;
    /** For controling tab order */
    seqData: number;
    /** When TRUE, UI will be read only */
    isReadOnly: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    visible: boolean;
    /** When true, this data is object is from internal defaults */
    isInternalDefault: boolean;
    /** CSS to be applied */
    cSS?: string | undefined;
    /** Client Side Describe Value name */
    dV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    dependsOn?: string | undefined;
    /** When 1, allow HTML */
    hTML: boolean;
    /** HTML 5 Placeholder text */
    overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    shownWhen?: string | undefined;
    /** DV function used to validate */
    validateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    validateTextAgainst?: string | undefined;
    /** Max */
    validationMax?: string | undefined;
    /** Min */
    validationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    width: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    widthCSS?: string | undefined;
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export class UIDisplayFilter implements IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    partConfigKey!: string;
    /** One of the UI item names   */
    itemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    dataMember?: string | undefined;
    /** Name of a field in the schema */
    dataField?: string | undefined;
    /** The visible label for this entry */
    label?: string | undefined;
    /** Name of lookup */
    lookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    displayFormat?: string | undefined;
    /** see KBA-01336 */
    auxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    helpText?: string | undefined;
    /** For overriding allowed length */
    limitTo!: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    defaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    visible!: boolean;
    /** When true, this data is object is from internal defaults */
    isInternalDefault!: boolean;
    /** CSS to be applied */
    cSS?: string | undefined;
    /** Client Side Describe Value name */
    dV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    dependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    overlay?: string | undefined;

    constructor(data?: IUIDisplayFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partConfigKey = _data["PartConfigKey"];
            this.itemName = _data["ItemName"];
            this.dataMember = _data["DataMember"];
            this.dataField = _data["DataField"];
            this.label = _data["Label"];
            this.lookupName = _data["LookupName"];
            this.displayFormat = _data["DisplayFormat"];
            if (_data["AuxData"]) {
                this.auxData = {} as any;
                for (let key in _data["AuxData"]) {
                    if (_data["AuxData"].hasOwnProperty(key))
                        this.auxData![key] = _data["AuxData"][key];
                }
            }
            this.helpText = _data["HelpText"];
            this.limitTo = _data["LimitTo"];
            this.defaultValue = _data["DefaultValue"];
            this.visible = _data["Visible"];
            this.isInternalDefault = _data["IsInternalDefault"];
            this.cSS = _data["CSS"];
            this.dV = _data["DV"];
            this.dependsOn = _data["DependsOn"];
            this.overlay = _data["Overlay"];
        }
    }

    static fromJS(data: any): UIDisplayFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.partConfigKey;
        data["ItemName"] = this.itemName;
        data["DataMember"] = this.dataMember;
        data["DataField"] = this.dataField;
        data["Label"] = this.label;
        data["LookupName"] = this.lookupName;
        data["DisplayFormat"] = this.displayFormat;
        if (this.auxData) {
            data["AuxData"] = {};
            for (let key in this.auxData) {
                if (this.auxData.hasOwnProperty(key))
                    data["AuxData"][key] = this.auxData[key];
            }
        }
        data["HelpText"] = this.helpText;
        data["LimitTo"] = this.limitTo;
        data["DefaultValue"] = this.defaultValue;
        data["Visible"] = this.visible;
        data["IsInternalDefault"] = this.isInternalDefault;
        data["CSS"] = this.cSS;
        data["DV"] = this.dV;
        data["DependsOn"] = this.dependsOn;
        data["Overlay"] = this.overlay;
        return data; 
    }

    clone(): UIDisplayFilter {
        const json = this.toJSON();
        let result = new UIDisplayFilter();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export interface IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    partConfigKey: string;
    /** One of the UI item names   */
    itemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    dataMember?: string | undefined;
    /** Name of a field in the schema */
    dataField?: string | undefined;
    /** The visible label for this entry */
    label?: string | undefined;
    /** Name of lookup */
    lookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    displayFormat?: string | undefined;
    /** see KBA-01336 */
    auxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    helpText?: string | undefined;
    /** For overriding allowed length */
    limitTo: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    defaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    visible: boolean;
    /** When true, this data is object is from internal defaults */
    isInternalDefault: boolean;
    /** CSS to be applied */
    cSS?: string | undefined;
    /** Client Side Describe Value name */
    dV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    dependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    overlay?: string | undefined;
}

/** Primary Site Weather Now */
export class ProjKPIFact implements IProjKPIFact {
    /** Target which KPI column */
    column?: string | undefined;
    /** Label  */
    label?: string | undefined;
    /** Value to display */
    value?: string | undefined;
    /** Set if value has a click action */
    action?: string | undefined;
    /** Display Format (C2) */
    dForm?: string | undefined;
    /** CSS to apply */
    tForm?: string | undefined;
    negative!: boolean;
    /** UI CFG Item Name */
    itemName?: string | undefined;

    constructor(data?: IProjKPIFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["Column"];
            this.label = _data["Label"];
            this.value = _data["Value"];
            this.action = _data["Action"];
            this.dForm = _data["DForm"];
            this.tForm = _data["TForm"];
            this.negative = _data["Negative"];
            this.itemName = _data["ItemName"];
        }
    }

    static fromJS(data: any): ProjKPIFact {
        data = typeof data === 'object' ? data : {};
        let result = new ProjKPIFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Column"] = this.column;
        data["Label"] = this.label;
        data["Value"] = this.value;
        data["Action"] = this.action;
        data["DForm"] = this.dForm;
        data["TForm"] = this.tForm;
        data["Negative"] = this.negative;
        data["ItemName"] = this.itemName;
        return data; 
    }

    clone(): ProjKPIFact {
        const json = this.toJSON();
        let result = new ProjKPIFact();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjKPIFact {
    /** Target which KPI column */
    column?: string | undefined;
    /** Label  */
    label?: string | undefined;
    /** Value to display */
    value?: string | undefined;
    /** Set if value has a click action */
    action?: string | undefined;
    /** Display Format (C2) */
    dForm?: string | undefined;
    /** CSS to apply */
    tForm?: string | undefined;
    negative: boolean;
    /** UI CFG Item Name */
    itemName?: string | undefined;
}

/** Abstracted information about a project */
export class ProjectAbstract implements IProjectAbstract {
    /** Project ID */
    project!: string;
    /** Key for Project */
    projectKey!: string;
    /** From Project Setup (Subtype_ */
    projectType?: string | undefined;
    /** Key for Project Setup */
    setupDocKey!: string;
    /** Key for Site Address */
    siteAddrKey!: string;
    /** Person */
    person?: string | undefined;
    /** Company from Address tab */
    company?: string | undefined;
    /** Address line 1 */
    addr1?: string | undefined;
    /** Address Line 2 */
    addr2?: string | undefined;
    /** City */
    city?: string | undefined;
    /** State */
    state?: string | undefined;
    /** Zip */
    zip?: string | undefined;
    /** County */
    county?: string | undefined;
    /** Phone */
    phone?: string | undefined;
    /** Fax (obsolete) */
    fax?: string | undefined;
    /** External Status (from project setup) */
    externalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    externalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    sCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    planRoomMode?: string | undefined;
    /** URI for site camera */
    webCamURL?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    forecastThreshold!: number;
    /** Geo latitude (project setup) */
    latitude!: number;
    /** Geo longitude (project setup) */
    longitude!: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey!: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    cloudDrivePath?: string | undefined;
    /** GLSUB for project */
    gLSUB?: string | undefined;
    /** When true, project is active */
    active!: boolean;
    /** Status code  (project setup) */
    status?: string | undefined;
    /** Resolved Status (project setup) */
    statusText?: string | undefined;
    /** Subtype  */
    subtype?: string | undefined;
    /** State of project setup */
    docState?: string | undefined;
    /** Key From Project Setup Reference  */
    projectDocReference?: string | undefined;
    /** From UniReferenceKey */
    projectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    projectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    projectCustomerName?: string | undefined;
    /** From Project Setup */
    projectTitle?: string | undefined;
    /** From Project Setup */
    projectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    projectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    projectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    projectBar?: string | undefined;
    /** From Dates on project setup */
    projectStartDate!: Date;
    /** From Dates on project setup */
    projectFinishDate!: Date;
    /** how to display project start date */
    projectStartFormat?: string | undefined;
    /** how to display project finish date */
    projectFinishFormat?: string | undefined;
    /** URI to current project photo */
    projectPhoto?: string | undefined;
    /** Current Note on Project */
    projectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    alwaysShowLinks!: boolean;
    /** When true, disable Note */
    excludeNoteUI!: boolean;
    /** When true, disable Links */
    excludeLinkUI!: boolean;
    /** When true, disable Cost Analysis */
    excludeCostAnalysisUI!: boolean;
    /** When true, disable KPI */
    excludeKPIUI!: boolean;
    /** Indicates when this abstract was generated */
    dataResolved!: Date;

    constructor(data?: IProjectAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["Project"];
            this.projectKey = _data["ProjectKey"];
            this.projectType = _data["ProjectType"];
            this.setupDocKey = _data["SetupDocKey"];
            this.siteAddrKey = _data["SiteAddrKey"];
            this.person = _data["Person"];
            this.company = _data["Company"];
            this.addr1 = _data["Addr1"];
            this.addr2 = _data["Addr2"];
            this.city = _data["City"];
            this.state = _data["State"];
            this.zip = _data["Zip"];
            this.county = _data["County"];
            this.phone = _data["Phone"];
            this.fax = _data["Fax"];
            this.externalStatus = _data["ExternalStatus"];
            this.externalSchedule = _data["ExternalSchedule"];
            this.sCBudgetMode = _data["SCBudgetMode"];
            this.planRoomMode = _data["PlanRoomMode"];
            this.webCamURL = _data["WebCamURL"];
            this.description = _data["Description"];
            this.forecastThreshold = _data["ForecastThreshold"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.cldStoreKey = _data["cldStoreKey"];
            this.cloudDrivePath = _data["CloudDrivePath"];
            this.gLSUB = _data["GLSUB"];
            this.active = _data["Active"];
            this.status = _data["Status"];
            this.statusText = _data["StatusText"];
            this.subtype = _data["Subtype"];
            this.docState = _data["DocState"];
            this.projectDocReference = _data["ProjectDocReference"];
            this.projectUniReference = _data["ProjectUniReference"];
            this.projectCustomerID = _data["ProjectCustomerID"];
            this.projectCustomerName = _data["ProjectCustomerName"];
            this.projectTitle = _data["ProjectTitle"];
            this.projectIDMasked = _data["ProjectIDMasked"];
            this.projectTabName = _data["ProjectTabName"];
            this.projectTabTip = _data["ProjectTabTip"];
            this.projectBar = _data["ProjectBar"];
            this.projectStartDate = _data["ProjectStartDate"] ? new Date(_data["ProjectStartDate"].toString()) : <any>undefined;
            this.projectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.projectStartFormat = _data["ProjectStartFormat"];
            this.projectFinishFormat = _data["ProjectFinishFormat"];
            this.projectPhoto = _data["ProjectPhoto"];
            this.projectCurrentNote = _data["ProjectCurrentNote"];
            if (Array.isArray(_data["actionsMenu"])) {
                this.actionsMenu = [] as any;
                for (let item of _data["actionsMenu"])
                    this.actionsMenu!.push(MenuAction.fromJS(item));
            }
            if (Array.isArray(_data["registerMenu"])) {
                this.registerMenu = [] as any;
                for (let item of _data["registerMenu"])
                    this.registerMenu!.push(MenuAction.fromJS(item));
            }
            this.alwaysShowLinks = _data["AlwaysShowLinks"];
            this.excludeNoteUI = _data["ExcludeNoteUI"];
            this.excludeLinkUI = _data["ExcludeLinkUI"];
            this.excludeCostAnalysisUI = _data["ExcludeCostAnalysisUI"];
            this.excludeKPIUI = _data["ExcludeKPIUI"];
            this.dataResolved = _data["dataResolved"] ? new Date(_data["dataResolved"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.project;
        data["ProjectKey"] = this.projectKey;
        data["ProjectType"] = this.projectType;
        data["SetupDocKey"] = this.setupDocKey;
        data["SiteAddrKey"] = this.siteAddrKey;
        data["Person"] = this.person;
        data["Company"] = this.company;
        data["Addr1"] = this.addr1;
        data["Addr2"] = this.addr2;
        data["City"] = this.city;
        data["State"] = this.state;
        data["Zip"] = this.zip;
        data["County"] = this.county;
        data["Phone"] = this.phone;
        data["Fax"] = this.fax;
        data["ExternalStatus"] = this.externalStatus;
        data["ExternalSchedule"] = this.externalSchedule;
        data["SCBudgetMode"] = this.sCBudgetMode;
        data["PlanRoomMode"] = this.planRoomMode;
        data["WebCamURL"] = this.webCamURL;
        data["Description"] = this.description;
        data["ForecastThreshold"] = this.forecastThreshold;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["cldStoreKey"] = this.cldStoreKey;
        data["CloudDrivePath"] = this.cloudDrivePath;
        data["GLSUB"] = this.gLSUB;
        data["Active"] = this.active;
        data["Status"] = this.status;
        data["StatusText"] = this.statusText;
        data["Subtype"] = this.subtype;
        data["DocState"] = this.docState;
        data["ProjectDocReference"] = this.projectDocReference;
        data["ProjectUniReference"] = this.projectUniReference;
        data["ProjectCustomerID"] = this.projectCustomerID;
        data["ProjectCustomerName"] = this.projectCustomerName;
        data["ProjectTitle"] = this.projectTitle;
        data["ProjectIDMasked"] = this.projectIDMasked;
        data["ProjectTabName"] = this.projectTabName;
        data["ProjectTabTip"] = this.projectTabTip;
        data["ProjectBar"] = this.projectBar;
        data["ProjectStartDate"] = this.projectStartDate ? this.projectStartDate.toISOString() : <any>undefined;
        data["ProjectFinishDate"] = this.projectFinishDate ? this.projectFinishDate.toISOString() : <any>undefined;
        data["ProjectStartFormat"] = this.projectStartFormat;
        data["ProjectFinishFormat"] = this.projectFinishFormat;
        data["ProjectPhoto"] = this.projectPhoto;
        data["ProjectCurrentNote"] = this.projectCurrentNote;
        if (Array.isArray(this.actionsMenu)) {
            data["actionsMenu"] = [];
            for (let item of this.actionsMenu)
                data["actionsMenu"].push(item.toJSON());
        }
        if (Array.isArray(this.registerMenu)) {
            data["registerMenu"] = [];
            for (let item of this.registerMenu)
                data["registerMenu"].push(item.toJSON());
        }
        data["AlwaysShowLinks"] = this.alwaysShowLinks;
        data["ExcludeNoteUI"] = this.excludeNoteUI;
        data["ExcludeLinkUI"] = this.excludeLinkUI;
        data["ExcludeCostAnalysisUI"] = this.excludeCostAnalysisUI;
        data["ExcludeKPIUI"] = this.excludeKPIUI;
        data["dataResolved"] = this.dataResolved ? this.dataResolved.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectAbstract {
        const json = this.toJSON();
        let result = new ProjectAbstract();
        result.init(json);
        return result;
    }
}

/** Abstracted information about a project */
export interface IProjectAbstract {
    /** Project ID */
    project: string;
    /** Key for Project */
    projectKey: string;
    /** From Project Setup (Subtype_ */
    projectType?: string | undefined;
    /** Key for Project Setup */
    setupDocKey: string;
    /** Key for Site Address */
    siteAddrKey: string;
    /** Person */
    person?: string | undefined;
    /** Company from Address tab */
    company?: string | undefined;
    /** Address line 1 */
    addr1?: string | undefined;
    /** Address Line 2 */
    addr2?: string | undefined;
    /** City */
    city?: string | undefined;
    /** State */
    state?: string | undefined;
    /** Zip */
    zip?: string | undefined;
    /** County */
    county?: string | undefined;
    /** Phone */
    phone?: string | undefined;
    /** Fax (obsolete) */
    fax?: string | undefined;
    /** External Status (from project setup) */
    externalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    externalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    sCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    planRoomMode?: string | undefined;
    /** URI for site camera */
    webCamURL?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    forecastThreshold: number;
    /** Geo latitude (project setup) */
    latitude: number;
    /** Geo longitude (project setup) */
    longitude: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    cloudDrivePath?: string | undefined;
    /** GLSUB for project */
    gLSUB?: string | undefined;
    /** When true, project is active */
    active: boolean;
    /** Status code  (project setup) */
    status?: string | undefined;
    /** Resolved Status (project setup) */
    statusText?: string | undefined;
    /** Subtype  */
    subtype?: string | undefined;
    /** State of project setup */
    docState?: string | undefined;
    /** Key From Project Setup Reference  */
    projectDocReference?: string | undefined;
    /** From UniReferenceKey */
    projectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    projectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    projectCustomerName?: string | undefined;
    /** From Project Setup */
    projectTitle?: string | undefined;
    /** From Project Setup */
    projectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    projectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    projectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    projectBar?: string | undefined;
    /** From Dates on project setup */
    projectStartDate: Date;
    /** From Dates on project setup */
    projectFinishDate: Date;
    /** how to display project start date */
    projectStartFormat?: string | undefined;
    /** how to display project finish date */
    projectFinishFormat?: string | undefined;
    /** URI to current project photo */
    projectPhoto?: string | undefined;
    /** Current Note on Project */
    projectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    alwaysShowLinks: boolean;
    /** When true, disable Note */
    excludeNoteUI: boolean;
    /** When true, disable Links */
    excludeLinkUI: boolean;
    /** When true, disable Cost Analysis */
    excludeCostAnalysisUI: boolean;
    /** When true, disable KPI */
    excludeKPIUI: boolean;
    /** Indicates when this abstract was generated */
    dataResolved: Date;
}

/** Describes a Menu or Action */
export class MenuAction implements IMenuAction {
    /** The menu or group that connects a series of actions */
    menuID?: string | undefined;
    /** optional arguement */
    commandArgument?: string | undefined;
    /** Key for this action, unique within MenuID */
    commandName?: string | undefined;
    /** True if enabled */
    enabled!: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    hasPermits!: number;
    /** suggested image */
    iconImageUrl?: string | undefined;
    /** Display Text */
    itemText?: string | undefined;
    /** URL for action */
    hRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    hrefTarget?: string | undefined;
    /** For a permission demand lookup */
    uCModule?: string | undefined;
    /** The function within the specified module */
    uCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    needPermits!: number;
    /** Controls order of choices within MenuID */
    menuSeq!: number;
    /** If not empty, a confirmation prompt */
    confirm?: string | undefined;
    /** When true, and not enabled, do not bother showing */
    hideifDisabled!: boolean;

    constructor(data?: IMenuAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuID = _data["MenuID"];
            this.commandArgument = _data["CommandArgument"];
            this.commandName = _data["CommandName"];
            this.enabled = _data["Enabled"];
            this.hasPermits = _data["HasPermits"];
            this.iconImageUrl = _data["IconImageUrl"];
            this.itemText = _data["ItemText"];
            this.hRef = _data["HRef"];
            this.hrefTarget = _data["HrefTarget"];
            this.uCModule = _data["UCModule"];
            this.uCFunction = _data["UCFunction"];
            this.needPermits = _data["NeedPermits"];
            this.menuSeq = _data["MenuSeq"];
            this.confirm = _data["Confirm"];
            this.hideifDisabled = _data["HideifDisabled"];
        }
    }

    static fromJS(data: any): MenuAction {
        data = typeof data === 'object' ? data : {};
        let result = new MenuAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MenuID"] = this.menuID;
        data["CommandArgument"] = this.commandArgument;
        data["CommandName"] = this.commandName;
        data["Enabled"] = this.enabled;
        data["HasPermits"] = this.hasPermits;
        data["IconImageUrl"] = this.iconImageUrl;
        data["ItemText"] = this.itemText;
        data["HRef"] = this.hRef;
        data["HrefTarget"] = this.hrefTarget;
        data["UCModule"] = this.uCModule;
        data["UCFunction"] = this.uCFunction;
        data["NeedPermits"] = this.needPermits;
        data["MenuSeq"] = this.menuSeq;
        data["Confirm"] = this.confirm;
        data["HideifDisabled"] = this.hideifDisabled;
        return data; 
    }

    clone(): MenuAction {
        const json = this.toJSON();
        let result = new MenuAction();
        result.init(json);
        return result;
    }
}

/** Describes a Menu or Action */
export interface IMenuAction {
    /** The menu or group that connects a series of actions */
    menuID?: string | undefined;
    /** optional arguement */
    commandArgument?: string | undefined;
    /** Key for this action, unique within MenuID */
    commandName?: string | undefined;
    /** True if enabled */
    enabled: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    hasPermits: number;
    /** suggested image */
    iconImageUrl?: string | undefined;
    /** Display Text */
    itemText?: string | undefined;
    /** URL for action */
    hRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    hrefTarget?: string | undefined;
    /** For a permission demand lookup */
    uCModule?: string | undefined;
    /** The function within the specified module */
    uCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    needPermits: number;
    /** Controls order of choices within MenuID */
    menuSeq: number;
    /** If not empty, a confirmation prompt */
    confirm?: string | undefined;
    /** When true, and not enabled, do not bother showing */
    hideifDisabled: boolean;
}

/** Attributes describing a Link to a parent or child  project */
export class ProjectLink implements IProjectLink {
    /** Key for Attachment between projects */
    docAttachKey!: string;
    /** Key for document that owns the link */
    docMasterKey?: string | undefined;
    /** Key for Project Setup  */
    linkedProjectContractKey?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Title of Project */
    title?: string | undefined;
    /** Location of Project */
    location?: string | undefined;
    /** External Doc Number */
    externalDocNo?: string | undefined;
    /** Resolved Status  */
    statusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    projectStart!: Date;
    /** Project Finish Date (from Dates tab) */
    projectFinish!: Date;
    /** EAC Contract Value  */
    currentContract!: number;
    /** When True, this is a child project */
    isChild!: boolean;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docAttachKey = _data["DocAttachKey"];
            this.docMasterKey = _data["DocMasterKey"];
            this.linkedProjectContractKey = _data["LinkedProjectContractKey"];
            this.project = _data["Project"];
            this.title = _data["Title"];
            this.location = _data["Location"];
            this.externalDocNo = _data["ExternalDocNo"];
            this.statusDescription = _data["StatusDescription"];
            this.projectStart = _data["ProjectStart"] ? new Date(_data["ProjectStart"].toString()) : <any>undefined;
            this.projectFinish = _data["ProjectFinish"] ? new Date(_data["ProjectFinish"].toString()) : <any>undefined;
            this.currentContract = _data["CurrentContract"];
            this.isChild = _data["IsChild"];
        }
    }

    static fromJS(data: any): ProjectLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.docAttachKey;
        data["DocMasterKey"] = this.docMasterKey;
        data["LinkedProjectContractKey"] = this.linkedProjectContractKey;
        data["Project"] = this.project;
        data["Title"] = this.title;
        data["Location"] = this.location;
        data["ExternalDocNo"] = this.externalDocNo;
        data["StatusDescription"] = this.statusDescription;
        data["ProjectStart"] = this.projectStart ? this.projectStart.toISOString() : <any>undefined;
        data["ProjectFinish"] = this.projectFinish ? this.projectFinish.toISOString() : <any>undefined;
        data["CurrentContract"] = this.currentContract;
        data["IsChild"] = this.isChild;
        return data; 
    }

    clone(): ProjectLink {
        const json = this.toJSON();
        let result = new ProjectLink();
        result.init(json);
        return result;
    }
}

/** Attributes describing a Link to a parent or child  project */
export interface IProjectLink {
    /** Key for Attachment between projects */
    docAttachKey: string;
    /** Key for document that owns the link */
    docMasterKey?: string | undefined;
    /** Key for Project Setup  */
    linkedProjectContractKey?: string | undefined;
    /** Project ID */
    project?: string | undefined;
    /** Title of Project */
    title?: string | undefined;
    /** Location of Project */
    location?: string | undefined;
    /** External Doc Number */
    externalDocNo?: string | undefined;
    /** Resolved Status  */
    statusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    projectStart: Date;
    /** Project Finish Date (from Dates tab) */
    projectFinish: Date;
    /** EAC Contract Value  */
    currentContract: number;
    /** When True, this is a child project */
    isChild: boolean;
}

/** Primary Site Weather Now */
export class ProjectWeatherNow implements IProjectWeatherNow {
    /** Description of location */
    at?: string | undefined;
    /** Barometer */
    barometer!: number;
    /** Descriptio of condition (cloudy) */
    condition?: string | undefined;
    /** Dew Point  */
    dewPoint!: number;
    /** Feels Like */
    feelsLike!: number;
    /** URI to full forecast */
    forecast?: string | undefined;
    /** Current Humidity */
    humidity!: number;
    /** URI to icon  */
    icon?: string | undefined;
    /** When this reading was taken */
    obtained!: Date;
    /** Source of weather data (usually noaa) */
    provider?: string | undefined;
    /** When reading was acquired */
    reported?: string | undefined;
    /** Temperature (F) */
    temperature!: number;
    /** Visibility (miles) */
    visibility!: number;
    /** Wind (MPH) */
    wind!: number;
    /** Description of Wind/direction */
    windInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    zipCode?: string | undefined;

    constructor(data?: IProjectWeatherNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.at = _data["At"];
            this.barometer = _data["Barometer"];
            this.condition = _data["Condition"];
            this.dewPoint = _data["DewPoint"];
            this.feelsLike = _data["FeelsLike"];
            this.forecast = _data["Forecast"];
            this.humidity = _data["Humidity"];
            this.icon = _data["Icon"];
            this.obtained = _data["Obtained"] ? new Date(_data["Obtained"].toString()) : <any>undefined;
            this.provider = _data["Provider"];
            this.reported = _data["Reported"];
            this.temperature = _data["Temperature"];
            this.visibility = _data["Visibility"];
            this.wind = _data["Wind"];
            this.windInfo = _data["WindInfo"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): ProjectWeatherNow {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWeatherNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["At"] = this.at;
        data["Barometer"] = this.barometer;
        data["Condition"] = this.condition;
        data["DewPoint"] = this.dewPoint;
        data["FeelsLike"] = this.feelsLike;
        data["Forecast"] = this.forecast;
        data["Humidity"] = this.humidity;
        data["Icon"] = this.icon;
        data["Obtained"] = this.obtained ? this.obtained.toISOString() : <any>undefined;
        data["Provider"] = this.provider;
        data["Reported"] = this.reported;
        data["Temperature"] = this.temperature;
        data["Visibility"] = this.visibility;
        data["Wind"] = this.wind;
        data["WindInfo"] = this.windInfo;
        data["ZipCode"] = this.zipCode;
        return data; 
    }

    clone(): ProjectWeatherNow {
        const json = this.toJSON();
        let result = new ProjectWeatherNow();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjectWeatherNow {
    /** Description of location */
    at?: string | undefined;
    /** Barometer */
    barometer: number;
    /** Descriptio of condition (cloudy) */
    condition?: string | undefined;
    /** Dew Point  */
    dewPoint: number;
    /** Feels Like */
    feelsLike: number;
    /** URI to full forecast */
    forecast?: string | undefined;
    /** Current Humidity */
    humidity: number;
    /** URI to icon  */
    icon?: string | undefined;
    /** When this reading was taken */
    obtained: Date;
    /** Source of weather data (usually noaa) */
    provider?: string | undefined;
    /** When reading was acquired */
    reported?: string | undefined;
    /** Temperature (F) */
    temperature: number;
    /** Visibility (miles) */
    visibility: number;
    /** Wind (MPH) */
    wind: number;
    /** Description of Wind/direction */
    windInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    zipCode?: string | undefined;
}

/** Primary Site Weather Now */
export class WeatherAtLocation implements IWeatherAtLocation {
    /** Location (typically zipcode) */
    locationCode!: number;
    /** Description of Location (JFK Airport, New York, NY) */
    location?: string | undefined;
    recordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    provider?: string | undefined;
    /** Key of this record */
    weatherInfoKey!: string;
    /** Key of this location */
    weatherLocationKey!: string;
    /** When this reading was acquired */
    reported!: Date;
    /** Weather condition summary (windy) */
    conditions?: string | undefined;
    /** Visibility (in miles) */
    visibility!: number;
    /** Temperature (F) */
    temperature!: number;
    /** Feels like (F) */
    feelsLike!: number;
    /** Dewpoint (F) */
    dewpoint!: number;
    /** Relative Humidity */
    humidityPct!: number;
    /** Description of wind direction */
    windDirection?: string | undefined;
    /** Wind Speed (MPH) */
    wind!: number;
    /** Barametric Pressure */
    barometer!: number;

    constructor(data?: IWeatherAtLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCode = _data["LocationCode"];
            this.location = _data["Location"];
            this.recordedAt = _data["RecordedAt"];
            this.provider = _data["Provider"];
            this.weatherInfoKey = _data["WeatherInfoKey"];
            this.weatherLocationKey = _data["WeatherLocationKey"];
            this.reported = _data["Reported"] ? new Date(_data["Reported"].toString()) : <any>undefined;
            this.conditions = _data["Conditions"];
            this.visibility = _data["Visibility"];
            this.temperature = _data["Temperature"];
            this.feelsLike = _data["FeelsLike"];
            this.dewpoint = _data["Dewpoint"];
            this.humidityPct = _data["HumidityPct"];
            this.windDirection = _data["WindDirection"];
            this.wind = _data["Wind"];
            this.barometer = _data["Barometer"];
        }
    }

    static fromJS(data: any): WeatherAtLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAtLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocationCode"] = this.locationCode;
        data["Location"] = this.location;
        data["RecordedAt"] = this.recordedAt;
        data["Provider"] = this.provider;
        data["WeatherInfoKey"] = this.weatherInfoKey;
        data["WeatherLocationKey"] = this.weatherLocationKey;
        data["Reported"] = this.reported ? this.reported.toISOString() : <any>undefined;
        data["Conditions"] = this.conditions;
        data["Visibility"] = this.visibility;
        data["Temperature"] = this.temperature;
        data["FeelsLike"] = this.feelsLike;
        data["Dewpoint"] = this.dewpoint;
        data["HumidityPct"] = this.humidityPct;
        data["WindDirection"] = this.windDirection;
        data["Wind"] = this.wind;
        data["Barometer"] = this.barometer;
        return data; 
    }

    clone(): WeatherAtLocation {
        const json = this.toJSON();
        let result = new WeatherAtLocation();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IWeatherAtLocation {
    /** Location (typically zipcode) */
    locationCode: number;
    /** Description of Location (JFK Airport, New York, NY) */
    location?: string | undefined;
    recordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    provider?: string | undefined;
    /** Key of this record */
    weatherInfoKey: string;
    /** Key of this location */
    weatherLocationKey: string;
    /** When this reading was acquired */
    reported: Date;
    /** Weather condition summary (windy) */
    conditions?: string | undefined;
    /** Visibility (in miles) */
    visibility: number;
    /** Temperature (F) */
    temperature: number;
    /** Feels like (F) */
    feelsLike: number;
    /** Dewpoint (F) */
    dewpoint: number;
    /** Relative Humidity */
    humidityPct: number;
    /** Description of wind direction */
    windDirection?: string | undefined;
    /** Wind Speed (MPH) */
    wind: number;
    /** Barametric Pressure */
    barometer: number;
}

/** Comment about a topic */
export class Comment implements IComment {
    /** Key for this comment */
    docCommentKey!: string;
    /** Key for the topic relating a group of comments */
    topicKey!: string;
    /** Key for the author of this comment */
    fromUser!: string;
    /** Primary text of this comment */
    note?: string | undefined;
    /** Primary amount */
    cost!: number;
    /** Stage (as in document re-route stage; no known use cases) */
    stage!: number;
    /** When this comment was created (editable given sufficient permission) */
    created!: Date;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docCommentKey = _data["DocCommentKey"];
            this.topicKey = _data["TopicKey"];
            this.fromUser = _data["FromUser"];
            this.note = _data["Note"];
            this.cost = _data["Cost"];
            this.stage = _data["Stage"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.docCommentKey;
        data["TopicKey"] = this.topicKey;
        data["FromUser"] = this.fromUser;
        data["Note"] = this.note;
        data["Cost"] = this.cost;
        data["Stage"] = this.stage;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Comment {
        const json = this.toJSON();
        let result = new Comment();
        result.init(json);
        return result;
    }
}

/** Comment about a topic */
export interface IComment {
    /** Key for this comment */
    docCommentKey: string;
    /** Key for the topic relating a group of comments */
    topicKey: string;
    /** Key for the author of this comment */
    fromUser: string;
    /** Primary text of this comment */
    note?: string | undefined;
    /** Primary amount */
    cost: number;
    /** Stage (as in document re-route stage; no known use cases) */
    stage: number;
    /** When this comment was created (editable given sufficient permission) */
    created: Date;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Readonly description of an cost transaction posted to a project */
export class ProjectTranDetail implements IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    rowKey!: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount!: number;
    /** Typically US */
    baseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    cpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime!: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num!: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime!: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date!: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date!: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    invoiceNumber?: string | undefined;
    /** PO Number */
    pONumber?: string | undefined;
    /** Source Batch Number */
    sourceBatchNumber?: string | undefined;
    /** Labor Class */
    laborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units!: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line!: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    descr?: string | undefined;
    /** Is XTS transaction  */
    isXTS!: boolean;
    /** Identifies a Document */
    docMasterKey!: string;
    /** Document Title */
    docTitle?: string | undefined;
    /** Account Type (EX or RV) */
    acct_Type?: string | undefined;
    /** No known use */
    acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    acct_Class?: string | undefined;

    constructor(data?: IProjectTranDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowKey = _data["RowKey"];
            this.acct = _data["acct"];
            this.alloc_flag = _data["alloc_flag"];
            this.amount = _data["amount"];
            this.baseCuryId = _data["BaseCuryId"];
            this.batch_id = _data["batch_id"];
            this.batch_type = _data["batch_type"];
            this.bill_batch_id = _data["bill_batch_id"];
            this.cpnyId = _data["CpnyId"];
            this.crtd_datetime = _data["crtd_datetime"] ? new Date(_data["crtd_datetime"].toString()) : <any>undefined;
            this.crtd_prog = _data["crtd_prog"];
            this.crtd_user = _data["crtd_user"];
            this.data1 = _data["data1"];
            this.detail_num = _data["detail_num"];
            this.employee = _data["employee"];
            this.fiscalno = _data["fiscalno"];
            this.gl_acct = _data["gl_acct"];
            this.gl_subacct = _data["gl_subacct"];
            this.lupd_datetime = _data["lupd_datetime"] ? new Date(_data["lupd_datetime"].toString()) : <any>undefined;
            this.lupd_prog = _data["lupd_prog"];
            this.lupd_user = _data["lupd_user"];
            this.pjt_entity = _data["pjt_entity"];
            this.post_date = _data["post_date"] ? new Date(_data["post_date"].toString()) : <any>undefined;
            this.project = _data["project"];
            this.subcontract = _data["Subcontract"];
            this.system_cd = _data["system_cd"];
            this.trans_date = _data["trans_date"] ? new Date(_data["trans_date"].toString()) : <any>undefined;
            this.tr_comment = _data["tr_comment"];
            this.tr_id01 = _data["tr_id01"];
            this.invoiceNumber = _data["InvoiceNumber"];
            this.pONumber = _data["PONumber"];
            this.sourceBatchNumber = _data["SourceBatchNumber"];
            this.laborClass = _data["LaborClass"];
            this.tr_status = _data["tr_status"];
            this.unit_of_measure = _data["unit_of_measure"];
            this.units = _data["units"];
            this.vendor_num = _data["vendor_num"];
            this.voucher_line = _data["voucher_line"];
            this.voucher_num = _data["voucher_num"];
            this.emp_name = _data["emp_name"];
            this.name = _data["name"];
            this.equip_id = _data["equip_id"];
            this.invtid = _data["invtid"];
            this.lotsernbr = _data["lotsernbr"];
            this.siteid = _data["siteid"];
            this.whseloc = _data["whseloc"];
            this.descr = _data["Descr"];
            this.isXTS = _data["IsXTS"];
            this.docMasterKey = _data["DocMasterKey"];
            this.docTitle = _data["DocTitle"];
            this.acct_Type = _data["Acct_Type"];
            this.acct_TranClass = _data["Acct_TranClass"];
            this.acct_Class = _data["Acct_Class"];
        }
    }

    static fromJS(data: any): ProjectTranDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTranDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.rowKey;
        data["acct"] = this.acct;
        data["alloc_flag"] = this.alloc_flag;
        data["amount"] = this.amount;
        data["BaseCuryId"] = this.baseCuryId;
        data["batch_id"] = this.batch_id;
        data["batch_type"] = this.batch_type;
        data["bill_batch_id"] = this.bill_batch_id;
        data["CpnyId"] = this.cpnyId;
        data["crtd_datetime"] = this.crtd_datetime ? this.crtd_datetime.toISOString() : <any>undefined;
        data["crtd_prog"] = this.crtd_prog;
        data["crtd_user"] = this.crtd_user;
        data["data1"] = this.data1;
        data["detail_num"] = this.detail_num;
        data["employee"] = this.employee;
        data["fiscalno"] = this.fiscalno;
        data["gl_acct"] = this.gl_acct;
        data["gl_subacct"] = this.gl_subacct;
        data["lupd_datetime"] = this.lupd_datetime ? this.lupd_datetime.toISOString() : <any>undefined;
        data["lupd_prog"] = this.lupd_prog;
        data["lupd_user"] = this.lupd_user;
        data["pjt_entity"] = this.pjt_entity;
        data["post_date"] = this.post_date ? this.post_date.toISOString() : <any>undefined;
        data["project"] = this.project;
        data["Subcontract"] = this.subcontract;
        data["system_cd"] = this.system_cd;
        data["trans_date"] = this.trans_date ? this.trans_date.toISOString() : <any>undefined;
        data["tr_comment"] = this.tr_comment;
        data["tr_id01"] = this.tr_id01;
        data["InvoiceNumber"] = this.invoiceNumber;
        data["PONumber"] = this.pONumber;
        data["SourceBatchNumber"] = this.sourceBatchNumber;
        data["LaborClass"] = this.laborClass;
        data["tr_status"] = this.tr_status;
        data["unit_of_measure"] = this.unit_of_measure;
        data["units"] = this.units;
        data["vendor_num"] = this.vendor_num;
        data["voucher_line"] = this.voucher_line;
        data["voucher_num"] = this.voucher_num;
        data["emp_name"] = this.emp_name;
        data["name"] = this.name;
        data["equip_id"] = this.equip_id;
        data["invtid"] = this.invtid;
        data["lotsernbr"] = this.lotsernbr;
        data["siteid"] = this.siteid;
        data["whseloc"] = this.whseloc;
        data["Descr"] = this.descr;
        data["IsXTS"] = this.isXTS;
        data["DocMasterKey"] = this.docMasterKey;
        data["DocTitle"] = this.docTitle;
        data["Acct_Type"] = this.acct_Type;
        data["Acct_TranClass"] = this.acct_TranClass;
        data["Acct_Class"] = this.acct_Class;
        return data; 
    }

    clone(): ProjectTranDetail {
        const json = this.toJSON();
        let result = new ProjectTranDetail();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    rowKey: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount: number;
    /** Typically US */
    baseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    cpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    invoiceNumber?: string | undefined;
    /** PO Number */
    pONumber?: string | undefined;
    /** Source Batch Number */
    sourceBatchNumber?: string | undefined;
    /** Labor Class */
    laborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    descr?: string | undefined;
    /** Is XTS transaction  */
    isXTS: boolean;
    /** Identifies a Document */
    docMasterKey: string;
    /** Document Title */
    docTitle?: string | undefined;
    /** Account Type (EX or RV) */
    acct_Type?: string | undefined;
    /** No known use */
    acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    acct_Class?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}