/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { APIClientBase } from './APIClientBase';
import * as jQuery from 'jquery';

export class ProjectToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns a summary overview of the specified project
     * @param projectID Full Project ID
     */
    getProjectDetail(projectID: string) {
        return new Promise<ProjectAbstract | null>((resolve, reject) => {
            this.getProjectDetailWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDetailWithCallbacks(projectID: string, onSuccess?: (result: ProjectAbstract | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Abstract";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDetailWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDetail(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDetail(xhr: any): ProjectAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectAbstract.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that link to the specified project
     * @param projectID Full Project ID
     */
    getProjectLinks(projectID: string) {
        return new Promise<ProjectLink[] | null>((resolve, reject) => {
            this.getProjectLinksWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectLinksWithCallbacks(projectID: string, onSuccess?: (result: ProjectLink[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Links";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectLinks(xhr: any): ProjectLink[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCost(projectID: string, summaryByAccount?: boolean | undefined, summaryByTask?: boolean | undefined, showUnits?: boolean | undefined, showThousands?: boolean | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getProjectCostWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Costs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCost(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCostFooters(projectID: string, summaryByAccount?: boolean | undefined, summaryByTask?: boolean | undefined, showUnits?: boolean | undefined, showThousands?: boolean | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectCostFootersWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostFootersWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/CostSummary?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostFootersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostFooters(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostFooters(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns recent weather reading at the specified project site
     * @param projectID Full Project ID
     */
    getProjectWeatherReading(projectID: string) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.getProjectWeatherReadingWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherReadingWithCallbacks(projectID: string, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherReading";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherReadingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherReading(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherReading(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns history of weather readings at the specified project site INCOMPLETE
     * @param projectID Full Project ID
     */
    getProjectWeatherHistory(projectID: string) {
        return new Promise<WeatherAtLocation[] | null>((resolve, reject) => {
            this.getProjectWeatherHistoryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherHistoryWithCallbacks(projectID: string, onSuccess?: (result: WeatherAtLocation[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherHistory";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherHistory(xhr: any): WeatherAtLocation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAtLocation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns current note for the specified project
     * @param projectID Full Project ID
     */
    getProjectNote(projectID: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getProjectNoteWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNoteWithCallbacks(projectID: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNote(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Sets project note INCOMPLETE!!!
     * @param projectID Full Project ID
     */
    newProjectNote(projectID: string, newNote: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.newProjectNoteWithCallbacks(projectID, newNote, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private newProjectNoteWithCallbacks(projectID: string, newNote: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newNote);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processNewProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processNewProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processNewProjectNote(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns all notes for the specified project
     * @param projectID Full Project ID
     */
    getProjectNotes(projectID: string) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getProjectNotesWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNotesWithCallbacks(projectID: string, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Notes";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNotesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNotes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNotes(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns transactions that detail costs on the project
     * @param projectID Full Project ID
     * @param forWBS (optional) Cost Code Like
     * @param forAccount (optional) Account Catagory
     * @param forAccountType (optional) Account Catagory Type (RV,EX,%)
     * @param forAccountClass (optional) Account Catagory Class (L,LB,M,O,P)
     * @param forPeriod (optional) Fiscal Period
     * @param fromDate (optional) From Date
     * @param thruDate (optional) Thru Date
     * @param refDMK (optional) Reference Document
     * @param refVendor (optional) Reference Vendor ID (or Contact Key)
     */
    getProjectCostTransactions(projectID: string, forWBS?: string | null | undefined, forAccount?: string | null | undefined, forAccountType?: string | null | undefined, forAccountClass?: string | null | undefined, forPeriod?: string | null | undefined, fromDate?: string | null | undefined, thruDate?: string | null | undefined, refDMK?: string | null | undefined, refVendor?: string | null | undefined) {
        return new Promise<ProjectTranDetail[] | null>((resolve, reject) => {
            this.getProjectCostTransactionsWithCallbacks(projectID, forWBS, forAccount, forAccountType, forAccountClass, forPeriod, fromDate, thruDate, refDMK, refVendor, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostTransactionsWithCallbacks(projectID: string, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined, onSuccess?: (result: ProjectTranDetail[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cost/transactions?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forWBS !== undefined && forWBS !== null)
            url_ += "forWBS=" + encodeURIComponent("" + forWBS) + "&";
        if (forAccount !== undefined && forAccount !== null)
            url_ += "forAccount=" + encodeURIComponent("" + forAccount) + "&";
        if (forAccountType !== undefined && forAccountType !== null)
            url_ += "forAccountType=" + encodeURIComponent("" + forAccountType) + "&";
        if (forAccountClass !== undefined && forAccountClass !== null)
            url_ += "forAccountClass=" + encodeURIComponent("" + forAccountClass) + "&";
        if (forPeriod !== undefined && forPeriod !== null)
            url_ += "forPeriod=" + encodeURIComponent("" + forPeriod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (thruDate !== undefined && thruDate !== null)
            url_ += "thruDate=" + encodeURIComponent("" + thruDate) + "&";
        if (refDMK !== undefined && refDMK !== null)
            url_ += "refDMK=" + encodeURIComponent("" + refDMK) + "&";
        if (refVendor !== undefined && refVendor !== null)
            url_ += "refVendor=" + encodeURIComponent("" + refVendor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostTransactionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostTransactions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostTransactions(xhr: any): ProjectTranDetail[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Not found", status, _responseText, _headers, result404);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTranDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class SessionClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns nice fresh GUID(s) / UUID
     * @param count Number of GUIDs to return, max is 9
     */
    getNewGuid(count: number) {
        return new Promise<string[] | null>((resolve, reject) => {
            this.getNewGuidWithCallbacks(count, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getNewGuidWithCallbacks(count: number, onSuccess?: (result: string[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/guid/{count}";
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetNewGuidWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetNewGuidWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetNewGuidWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetNewGuid(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetNewGuid(xhr: any): string[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns this users permission flags for a specific capability and context.
     * @param ucModule ucModule (SYS, LIST, PAGE, PART, etc)
     * @param ucName ucName (substitute @ for slash and ! for periods)
     * @param projectID (optional) Project ID
     * @param documentType (optional) Document Type
     */
    getCapabilityPermits(ucModule: string, ucName: string, projectID?: string | null | undefined, documentType?: string | null | undefined) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getCapabilityPermitsWithCallbacks(ucModule, ucName, projectID, documentType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCapabilityPermitsWithCallbacks(ucModule: string, ucName: string, projectID: string | null | undefined, documentType: string | null | undefined, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/capability/{ucModule}/{ucName}?";
        if (ucModule === undefined || ucModule === null)
            throw new Error("The parameter 'ucModule' must be defined.");
        url_ = url_.replace("{ucModule}", encodeURIComponent("" + ucModule));
        if (ucName === undefined || ucName === null)
            throw new Error("The parameter 'ucName' must be defined.");
        url_ = url_.replace("{ucName}", encodeURIComponent("" + ucName));
        if (projectID !== undefined && projectID !== null)
            url_ += "projectID=" + encodeURIComponent("" + projectID) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCapabilityPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCapabilityPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCapabilityPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCapabilityPermits(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCapabilityPermits(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a token that can be exchanged for the specific packet of information
     */
    createExchangeToken(tokenPayload: TokenRequest) {
        return new Promise<string | null>((resolve, reject) => {
            this.createExchangeTokenWithCallbacks(tokenPayload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createExchangeTokenWithCallbacks(tokenPayload: TokenRequest, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/exchangetoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tokenPayload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateExchangeTokenWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processCreateExchangeToken(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateExchangeToken(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Request inappropriate", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the token-specific packet of information with Auth, Session and Args encrypted
     */
    exchangeToken(token: string) {
        return new Promise<AuthenticationExchangeData | null>((resolve, reject) => {
            this.exchangeTokenWithCallbacks(token, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private exchangeTokenWithCallbacks(token: string, onSuccess?: (result: AuthenticationExchangeData | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/exchangetoken/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processExchangeTokenWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processExchangeTokenWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processExchangeToken(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processExchangeToken(xhr: any): AuthenticationExchangeData | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Request inappropriate", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticationExchangeData.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions for a project
     * @param projectID Project ID
     */
    getProjectPermits(projectID: string) {
        return new Promise<UCPermitSet | null>((resolve, reject) => {
            this.getProjectPermitsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitsWithCallbacks(projectID: string, onSuccess?: (result: UCPermitSet | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/project/{projectID}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermits(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermits(xhr: any): UCPermitSet | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UCPermitSet.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns server version in for major.minor.build.t
     */
    getVersion() {
        return new Promise<string | null>((resolve, reject) => {
            this.getVersionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getVersionWithCallbacks(onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/version";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetVersionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetVersionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetVersion(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetVersion(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions by Module | Function
     * @param eTag (optional) Returns nothing if eTag matches supplied eTag
     */
    getProjectPermitNameMap(eTag?: string | null | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectPermitNameMapWithCallbacks(eTag, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitNameMapWithCallbacks(eTag: string | null | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/map?";
        if (eTag !== undefined && eTag !== null)
            url_ += "eTag=" + encodeURIComponent("" + eTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitNameMapWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermitNameMap(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermitNameMap(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result304 = resultData304 !== undefined ? resultData304 : <any>null;
            return throwException("This (fairly static) information matches the supplied eTag", status, _responseText, _headers, result304);
        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WCC Session data
     */
    getWCC() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getWCCWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getWCCWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/who";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetWCCWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetWCC(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetWCC(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param forTabType (optional) optional tab type (project,other, otheruser,blank for all)
     */
    getSessionTabs(forTabType?: string | null | undefined) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getSessionTabsWithCallbacks(forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabsWithCallbacks(forTabType: string | null | undefined, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSessionTabs(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds a tab to list of open tabs
     * @param tabKey tab key (perhaps project id or user key)
     * @param tabText tab text (displayed)
     * @param tabTip tab tip (display on mouse over)
     * @param tabAction tab action (must also be unique, so often includes tab key
     * @param forTabType (optional) optional tab type (project,other, otheruser)
     */
    addSessionTab(tabKey: string | null, tabText: string | null, tabTip: string | null, tabAction: string | null, forTabType?: string | null | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.addSessionTabWithCallbacks(tabKey, tabText, tabTip, tabAction, forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addSessionTabWithCallbacks(tabKey: string | null, tabText: string | null, tabTip: string | null, tabAction: string | null, forTabType: string | null | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (tabKey === undefined)
            throw new Error("The parameter 'tabKey' must be defined.");
        else if(tabKey !== null)
            url_ += "tabKey=" + encodeURIComponent("" + tabKey) + "&";
        if (tabText === undefined)
            throw new Error("The parameter 'tabText' must be defined.");
        else if(tabText !== null)
            url_ += "tabText=" + encodeURIComponent("" + tabText) + "&";
        if (tabTip === undefined)
            throw new Error("The parameter 'tabTip' must be defined.");
        else if(tabTip !== null)
            url_ += "tabTip=" + encodeURIComponent("" + tabTip) + "&";
        if (tabAction === undefined)
            throw new Error("The parameter 'tabAction' must be defined.");
        else if(tabAction !== null)
            url_ += "tabAction=" + encodeURIComponent("" + tabAction) + "&";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddSessionTabWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddSessionTab(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddSessionTab(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param tabKey Tab Key
     * @return No tabs (verify session)
     */
    deleteSessionTab(tabKey: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.deleteSessionTabWithCallbacks(tabKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteSessionTabWithCallbacks(tabKey: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (tabKey === undefined)
            throw new Error("The parameter 'tabKey' must be defined.");
        else if(tabKey !== null)
            url_ += "tabKey=" + encodeURIComponent("" + tabKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteSessionTabWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteSessionTabWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteSessionTab(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteSessionTab(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Tab not found", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns label and tip for new tab
     * @param id key for new tab, typically project id
     * @param forTabType (optional) optional tab type (project,other, otheruser,blank for all)
     */
    getSessionTabLabels(id: string, forTabType?: string | null | undefined) {
        return new Promise<TabDisplay | null>((resolve, reject) => {
            this.getSessionTabLabelsWithCallbacks(id, forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabLabelsWithCallbacks(id: string, forTabType: string | null | undefined, onSuccess?: (result: TabDisplay | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tab/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabLabelsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabLabelsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabLabelsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSessionTabLabels(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabLabels(xhr: any): TabDisplay | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TabDisplay.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Releases session by key
     * @param id Session Key
     * @return No session
     */
    deleteDocumentSession(id: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocumentSessionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocumentSessionWithCallbacks(id: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocumentSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocumentSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocumentSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocumentSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocumentSession(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("not found", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Encrypts and stores the posted information in xtsConfig
     * @param partnerType partner type (eg CloudStore)
     * @param servicePoint for Service.oAuthData
     * @param payload Quote enclosed JSON
     */
    postAuthData(partnerType: string, servicePoint: string, payload: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postAuthDataWithCallbacks(partnerType, servicePoint, payload, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postAuthDataWithCallbacks(partnerType: string, servicePoint: string, payload: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/oauthdata/{partnerType}/{servicePoint}";
        if (partnerType === undefined || partnerType === null)
            throw new Error("The parameter 'partnerType' must be defined.");
        url_ = url_.replace("{partnerType}", encodeURIComponent("" + partnerType));
        if (servicePoint === undefined || servicePoint === null)
            throw new Error("The parameter 'servicePoint' must be defined.");
        url_ = url_.replace("{servicePoint}", encodeURIComponent("" + servicePoint));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostAuthDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostAuthDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostAuthDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostAuthData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostAuthData(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Logs the posted data
     * @param logData Information To be logged
     */
    postToWebAppLog(logData: APIData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postToWebAppLogWithCallbacks(logData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postToWebAppLogWithCallbacks(logData: APIData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostToWebAppLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostToWebAppLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostToWebAppLog(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Patches the value In the indicated resource
     * @param tableName table
     * @param fieldName field
     * @param changeData Change information
     */
    patchFieldValue(tableName: string, fieldName: string, changeData: PDSData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchFieldValueWithCallbacks(tableName, fieldName, changeData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchFieldValueWithCallbacks(tableName: string, fieldName: string, changeData: PDSData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/value/{tableName}/{fieldName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchFieldValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchFieldValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchFieldValue(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Request inappropriate", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class DocumentToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Updates the addresses on the specified document
     * @param id Document Key
     * @param updatedData Replacement address data
     * @return Specified addresses not found
     */
    updateDocAddress(id: string, updatedData: DocAddress) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAddressWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAddressWithCallbacks(id: string, updatedData: DocAddress, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocAddress(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts addresses on the specified document
     * @param id Document Key
     * @param newData New address data
     */
    addDocAddresses(id: string, newData: DocAddress) {
        return new Promise<DocAddress | null>((resolve, reject) => {
            this.addDocAddressesWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAddressesWithCallbacks(id: string, newData: DocAddress, onSuccess?: (result: DocAddress | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAddressesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocAddresses(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAddresses(xhr: any): DocAddress | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAddress.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the addresses for the specified document
     * @param id Document Key
     */
    getDocAddresses(id: string) {
        return new Promise<DocAddress[] | null>((resolve, reject) => {
            this.getDocAddressesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAddressesWithCallbacks(id: string, onSuccess?: (result: DocAddress[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAddressesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAddressesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocAddresses(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAddresses(xhr: any): DocAddress[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAddress.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param key Address Key
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified route not found
     */
    patchDocAddress(id: string, key: string, fieldName: string, newValue: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.patchDocAddressWithCallbacks(id, key, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocAddressWithCallbacks(id: string, key: string, fieldName: string, newValue: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses/{key}/{fieldName}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocAddress(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Specified field invalid for route", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the attachments for the specified document
     * @param id Document Key
     */
    getDocAttachments(id: string) {
        return new Promise<DocAttachment[] | null>((resolve, reject) => {
            this.getDocAttachmentsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttachmentsWithCallbacks(id: string, onSuccess?: (result: DocAttachment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocAttachments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttachments(xhr: any): DocAttachment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttachment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attachments on the specified document
     * @param id Document Key
     * @param updatedData Replacement attachment data
     * @return Specified attachment not found
     */
    updateDocAttachments(id: string, updatedData: DocAttachment) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttachmentsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttachmentsWithCallbacks(id: string, updatedData: DocAttachment, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocAttachments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttachments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an attachment on the specified document
     * @param id Document Key
     * @param newData New attachment data
     */
    addDocAttachments(id: string, newData: DocAttachment) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.addDocAttachmentsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAttachmentsWithCallbacks(id: string, newData: DocAttachment, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocAttachments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAttachments(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attachment on the specified document
     * @param id Document Key
     * @param attachKey Doc Attachment Key
     * @return Specified attachment not found
     */
    deleteDocAttachments(id: string, attachKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttachmentsWithCallbacks(id, attachKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttachmentsWithCallbacks(id: string, attachKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attachments/{attachKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachKey === undefined || attachKey === null)
            throw new Error("The parameter 'attachKey' must be defined.");
        url_ = url_.replace("{attachKey}", encodeURIComponent("" + attachKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttachmentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttachmentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocAttachments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttachments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the inclusions for the specified document
     * @param id Document Key
     */
    getDocInclusions(id: string) {
        return new Promise<DocInclusion[] | null>((resolve, reject) => {
            this.getDocInclusionsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocInclusionsWithCallbacks(id: string, onSuccess?: (result: DocInclusion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocInclusions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocInclusions(xhr: any): DocInclusion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocInclusion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the inclusions on the specified document
     * @param id Document Key
     * @param updatedData Replacement inclusion(exclusion) data
     * @return Specified inclusion not found
     */
    updateDocInclusions(id: string, updatedData: DocInclusion) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocInclusionsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocInclusionsWithCallbacks(id: string, updatedData: DocInclusion, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocInclusions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocInclusions(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts an inclusions on the specified document
     * @param id Document Key
     * @param newData New inclusion(exclusion) data
     */
    addDocInclusions(id: string, newData: DocInclusion) {
        return new Promise<DocInclusion | null>((resolve, reject) => {
            this.addDocInclusionsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocInclusionsWithCallbacks(id: string, newData: DocInclusion, onSuccess?: (result: DocInclusion | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocInclusions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocInclusions(xhr: any): DocInclusion | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocInclusion.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the inclusions on the specified document
     * @param id Document Key
     * @param inclusionKey Inclusion Key
     * @return Specified inclusion not found
     */
    deleteDocInclusions(id: string, inclusionKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocInclusionsWithCallbacks(id, inclusionKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocInclusionsWithCallbacks(id: string, inclusionKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Inclusions/{inclusionKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (inclusionKey === undefined || inclusionKey === null)
            throw new Error("The parameter 'inclusionKey' must be defined.");
        url_ = url_.replace("{inclusionKey}", encodeURIComponent("" + inclusionKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocInclusionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocInclusionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocInclusions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocInclusions(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the compliance for the specified document
     * @param id Document Key
     */
    getDocCompliance(id: string) {
        return new Promise<DocCompliance[] | null>((resolve, reject) => {
            this.getDocComplianceWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocComplianceWithCallbacks(id: string, onSuccess?: (result: DocCompliance[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocCompliance(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocCompliance(xhr: any): DocCompliance[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocCompliance.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the compliance on the specified document
     * @param id Document Key
     * @param updatedData Replacement compliance data
     * @return Specified compliance not found
     */
    updateDocCompliance(id: string, updatedData: DocCompliance) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocComplianceWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocComplianceWithCallbacks(id: string, updatedData: DocCompliance, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocCompliance(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocCompliance(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts compliance on the specified document
     * @param id Document Key
     * @param newData New compliance data
     */
    addDocCompliance(id: string, newData: DocCompliance) {
        return new Promise<DocCompliance | null>((resolve, reject) => {
            this.addDocComplianceWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocComplianceWithCallbacks(id: string, newData: DocCompliance, onSuccess?: (result: DocCompliance | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocCompliance(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocCompliance(xhr: any): DocCompliance | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocCompliance.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the compliance on the specified document
     * @param id Document Key
     * @param complianceKey Compliance Item Key
     * @return Specified compliance not found
     */
    deleteDocCompliance(id: string, complianceKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocComplianceWithCallbacks(id, complianceKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocComplianceWithCallbacks(id: string, complianceKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Compliance/{complianceKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (complianceKey === undefined || complianceKey === null)
            throw new Error("The parameter 'complianceKey' must be defined.");
        url_ = url_.replace("{complianceKey}", encodeURIComponent("" + complianceKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocComplianceWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocComplianceWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocCompliance(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocCompliance(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the meeting attendees for the specified document
     * @param id Document Key
     */
    getDocAttendees(id: string) {
        return new Promise<DocMeetingAttendee[] | null>((resolve, reject) => {
            this.getDocAttendeesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttendeesWithCallbacks(id: string, onSuccess?: (result: DocMeetingAttendee[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttendeesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttendeesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttendeesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocAttendees(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttendees(xhr: any): DocMeetingAttendee[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocMeetingAttendee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attendees on the specified document
     * @param id Document Key
     * @param updatedData Replacement attendee data
     * @return Specified attendee not found
     */
    updateDocAttendee(id: string, updatedData: DocMeetingAttendee) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttendeeWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttendeeWithCallbacks(id: string, updatedData: DocMeetingAttendee, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocAttendee(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttendee(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts attendees on the specified document
     * @param id Document Key
     * @param newData New attendee data
     */
    addDocAttendee(id: string, newData: DocMeetingAttendee) {
        return new Promise<DocMeetingAttendee | null>((resolve, reject) => {
            this.addDocAttendeeWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocAttendeeWithCallbacks(id: string, newData: DocMeetingAttendee, onSuccess?: (result: DocMeetingAttendee | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocAttendee(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocAttendee(xhr: any): DocMeetingAttendee | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMeetingAttendee.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attendees on the specified document
     * @param id Document Key
     * @param attendeeKey Attendee Key
     * @return Specified attendee not found
     */
    deleteDocAttendee(id: string, attendeeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttendeeWithCallbacks(id, attendeeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttendeeWithCallbacks(id: string, attendeeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attendees/{attendeeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attendeeKey === undefined || attendeeKey === null)
            throw new Error("The parameter 'attendeeKey' must be defined.");
        url_ = url_.replace("{attendeeKey}", encodeURIComponent("" + attendeeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttendeeWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttendeeWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocAttendee(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttendee(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the attributes for the specified document
     * @param id Document Key
     */
    getDocAttributes(id: string) {
        return new Promise<DocAttribute[] | null>((resolve, reject) => {
            this.getDocAttributesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocAttributesWithCallbacks(id: string, onSuccess?: (result: DocAttribute[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocAttributes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocAttributes(xhr: any): DocAttribute[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttribute.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the attributes on the specified document
     * @param id Document Key
     * @param updatedData Replacement attribute data
     * @return Specified attribute not found
     */
    updateDocAttributes(id: string, updatedData: DocAttribute) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocAttributesWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocAttributesWithCallbacks(id: string, updatedData: DocAttribute, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocAttributes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocAttributes(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts attributes on the specified document
     * @param id Document Key
     * @param newData New attribute data
     */
    addDocDates(id: string, newData: DocAttribute) {
        return new Promise<DocAttribute | null>((resolve, reject) => {
            this.addDocDatesWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocDatesWithCallbacks(id: string, newData: DocAttribute, onSuccess?: (result: DocAttribute | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocDates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocDates(xhr: any): DocAttribute | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttribute.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attributes on the specified document
     * @param id Document Key
     * @param attributeKey Attribute Key
     * @return Specified attribute not found
     */
    deleteDocAttributes(id: string, attributeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAttributesWithCallbacks(id, attributeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAttributesWithCallbacks(id: string, attributeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Attributes/{attributeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAttributesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAttributesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocAttributes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAttributes(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the links for the specified document
     * @param id Document Key
     */
    getDocLinks(id: string) {
        return new Promise<DocAttachment[] | null>((resolve, reject) => {
            this.getDocLinksWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocLinksWithCallbacks(id: string, onSuccess?: (result: DocAttachment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocLinks(xhr: any): DocAttachment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocAttachment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts a Link on the specified document
     * @param id Document Key
     * @param newData New link data
     */
    addDocLinks(id: string, newData: DocAttachment) {
        return new Promise<DocAttachment | null>((resolve, reject) => {
            this.addDocLinksWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocLinksWithCallbacks(id: string, newData: DocAttachment, onSuccess?: (result: DocAttachment | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocLinks(xhr: any): DocAttachment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocAttachment.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the attachment on the specified document
     * @param id Document Key
     * @param linkKey Doc Link Key
     * @return Specified link not found
     */
    deleteDocLinks(id: string, linkKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocLinksWithCallbacks(id, linkKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocLinksWithCallbacks(id: string, linkKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Links/{linkKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (linkKey === undefined || linkKey === null)
            throw new Error("The parameter 'linkKey' must be defined.");
        url_ = url_.replace("{linkKey}", encodeURIComponent("" + linkKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocLinks(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the comments for the specified document
     * @param id Document Key
     */
    getDocComments(id: string) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getDocCommentsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocCommentsWithCallbacks(id: string, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocComments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocComments(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the comments on the specified document
     * @param id Document Key
     * @param updatedData Replacement comment data
     * @return Specified comments not found
     */
    updateDocComments(id: string, updatedData: Comment) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocCommentsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocCommentsWithCallbacks(id: string, updatedData: Comment, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocComments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocComments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts Comments on the specified document
     * @param id Document Key
     * @param newData New comment data
     */
    addDocComments(id: string, newData: Comment) {
        return new Promise<Comment | null>((resolve, reject) => {
            this.addDocCommentsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocCommentsWithCallbacks(id: string, newData: Comment, onSuccess?: (result: Comment | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocComments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocComments(xhr: any): Comment | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the comments on the specified document
     * @param id Document Key
     * @param commentKey Comment Key
     * @return Specified comments not found
     */
    deleteDocComments(id: string, commentKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocCommentsWithCallbacks(id, commentKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocCommentsWithCallbacks(id: string, commentKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Comments/{commentKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (commentKey === undefined || commentKey === null)
            throw new Error("The parameter 'commentKey' must be defined.");
        url_ = url_.replace("{commentKey}", encodeURIComponent("" + commentKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocComments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocComments(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the item comments for the specified document
     * @param id Document Key
     * @param itemId Item Key
     */
    getDocItemComments(id: string, itemId: string) {
        return new Promise<DocItemComment[] | null>((resolve, reject) => {
            this.getDocItemCommentsWithCallbacks(id, itemId, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemCommentsWithCallbacks(id: string, itemId: string, onSuccess?: (result: DocItemComment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Item/{itemId}/Comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemCommentsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemCommentsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocItemComments(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItemComments(xhr: any): DocItemComment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocItemComment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about copyability of the specified document
     * @param id Document Key
     */
    getDialogPreCopyThisDoc(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogPreCopyThisDocWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogPreCopyThisDocWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/copyable";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogPreCopyThisDocWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogPreCopyThisDocWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogPreCopyThisDocWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogPreCopyThisDoc(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogPreCopyThisDoc(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about date types for the specified document
     * @param id Document Key
     */
    getDialogDates(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogDatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogDatesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogDates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogDates(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about compliance types for the specified document
     * @param id Document Key
     */
    getDialogComplianceTypes(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogComplianceTypesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogComplianceTypesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/compliance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogComplianceTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogComplianceTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogComplianceTypesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogComplianceTypes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogComplianceTypes(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about inclusion types for the specified document
     * @param id Document Key
     */
    getDialogInclusionTypes(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogInclusionTypesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogInclusionTypesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/inclusions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogInclusionTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogInclusionTypesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogInclusionTypesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogInclusionTypes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogInclusionTypes(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about templates for the specified document
     * @param id Document Key
     */
    getDialogTemplates(id: string) {
        return new Promise<MenuAction | null>((resolve, reject) => {
            this.getDialogTemplatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogTemplatesWithCallbacks(id: string, onSuccess?: (result: MenuAction | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/templates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogTemplatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogTemplatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogTemplatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogTemplates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogTemplates(xhr: any): MenuAction | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuAction.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about attach actions for the specified document
     * @param id Document Key
     */
    getDialogAttachables(id: string) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogAttachablesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogAttachablesWithCallbacks(id: string, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/attachable";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogAttachablesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogAttachablesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogAttachablesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogAttachables(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogAttachables(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about route actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [build|apply|quickadd|all]
     */
    getDialogRoutables(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogRoutablesWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogRoutablesWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/routable?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogRoutablesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogRoutablesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogRoutablesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogRoutables(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogRoutables(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about exclusivity actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [HoldAuto,Hold24,Hold,HoldManual,HoldNone,HoldRoute,HoldInfo]
     */
    getDialogExclusivity(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogExclusivityWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogExclusivityWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/exclusive?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogExclusivityWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogExclusivityWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogExclusivity(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogExclusivity(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Information about actions for the specified document
     * @param id Document Key
     * @param action (optional) (Optional) Action [all]
     */
    getDialogAbstract(id: string, action?: string | null | undefined) {
        return new Promise<MenuAction[] | null>((resolve, reject) => {
            this.getDialogAbstractWithCallbacks(id, action, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDialogAbstractWithCallbacks(id: string, action: string | null | undefined, onSuccess?: (result: MenuAction[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/dialog/abstract?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDialogAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDialogAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDialogAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDialogAbstract(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDialogAbstract(xhr: any): MenuAction[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of tabs
     * @param id Document Key
     */
    getDocTabs(id: string) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getDocTabsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocTabsWithCallbacks(id: string, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/tabs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocTabs(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the ATC Workflow log for the current document session
     * @param id Document Key
     */
    getDocWorkflowLog(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocWorkflowLogWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocWorkflowLogWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/document/{id}/workflow/log";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocWorkflowLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocWorkflowLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocWorkflowLog(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the Document Session Key
     * @param id Document Key
     */
    getDocSession(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocSessionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocSessionWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocSession(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the specified session exists for the current user, associates the Document and Session Key
     * @param id Document Key
     * @param sessionID session id
     */
    patchDocSession(id: string, sessionID: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocSessionWithCallbacks(id, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocSessionWithCallbacks(id: string, sessionID: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/session/{sessionID}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocSession(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the document is in an appropriate state, change the document number
     * @param id Document Key
     * @param newNumber New Document Number
     */
    patchDocNumber(id: string, newNumber: string | null) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocNumberWithCallbacks(id, newNumber, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocNumberWithCallbacks(id: string, newNumber: string | null, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/docno?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newNumber === undefined)
            throw new Error("The parameter 'newNumber' must be defined.");
        else if(newNumber !== null)
            url_ += "newNumber=" + encodeURIComponent("" + newNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocNumberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocNumber(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocNumber(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found", status, _responseText, _headers, result404);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("Request not acceptible (document status or state?  already used?)", status, _responseText, _headers, result406);
        } else if (status === 422) {
            const _responseText = xhr.responseText;
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = resultData422 !== undefined ? resultData422 : <any>null;
            return throwException("Request not acceptible, number already used?)", status, _responseText, _headers, result422);
        } else if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Permission required", status, _responseText, _headers, result401);
        } else if (status === 304) {
            const _responseText = xhr.responseText;
            let result304: any = null;
            let resultData304 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result304 = resultData304 !== undefined ? resultData304 : <any>null;
            return throwException("The document already has the requested number", status, _responseText, _headers, result304);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Failed to persist the change", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Copies the specified document; returns a single guid for one of the created documents
     * @param id Document Key
     * @param destinationProject (optional) optional - target project; if not specified, same project
     * @param withItems (optional) optional - should items be copied
     * @param withAttachments (optional) optional - should attachments be copied (0=no,1=copy
     * @param withRoute (optional) Optional - how route should be handled (0=no,1=copy,or predefined route name
     * @param withLink (optional) Optional - include link to source
     * @param withDue (optional) Optional - specific new due date, default is tomorrow
     * @param withCopies (optional) Optional - number of copies, default is one
     * @param withRecur (optional) Optional - due interval between copies (NA-none;D:Daily;W:Weekly, see Code Set:[Recur])
     */
    postDocFrom(id: string, destinationProject?: string | null | undefined, withItems?: boolean | undefined, withAttachments?: boolean | undefined, withRoute?: string | null | undefined, withLink?: boolean | undefined, withDue?: Date | undefined, withCopies?: number | undefined, withRecur?: string | null | undefined) {
        return new Promise<void>((resolve, reject) => {
            this.postDocFromWithCallbacks(id, destinationProject, withItems, withAttachments, withRoute, withLink, withDue, withCopies, withRecur, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postDocFromWithCallbacks(id: string, destinationProject: string | null | undefined, withItems: boolean | undefined, withAttachments: boolean | undefined, withRoute: string | null | undefined, withLink: boolean | undefined, withDue: Date | undefined, withCopies: number | undefined, withRecur: string | null | undefined, onSuccess?: (result: void) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/from/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (destinationProject !== undefined && destinationProject !== null)
            url_ += "destinationProject=" + encodeURIComponent("" + destinationProject) + "&";
        if (withItems === null)
            throw new Error("The parameter 'withItems' cannot be null.");
        else if (withItems !== undefined)
            url_ += "withItems=" + encodeURIComponent("" + withItems) + "&";
        if (withAttachments === null)
            throw new Error("The parameter 'withAttachments' cannot be null.");
        else if (withAttachments !== undefined)
            url_ += "withAttachments=" + encodeURIComponent("" + withAttachments) + "&";
        if (withRoute !== undefined && withRoute !== null)
            url_ += "withRoute=" + encodeURIComponent("" + withRoute) + "&";
        if (withLink === null)
            throw new Error("The parameter 'withLink' cannot be null.");
        else if (withLink !== undefined)
            url_ += "withLink=" + encodeURIComponent("" + withLink) + "&";
        if (withDue === null)
            throw new Error("The parameter 'withDue' cannot be null.");
        else if (withDue !== undefined)
            url_ += "withDue=" + encodeURIComponent(withDue ? "" + withDue.toJSON() : "") + "&";
        if (withCopies === null)
            throw new Error("The parameter 'withCopies' cannot be null.");
        else if (withCopies !== undefined)
            url_ += "withCopies=" + encodeURIComponent("" + withCopies) + "&";
        if (withRecur !== undefined && withRecur !== null)
            url_ += "withRecur=" + encodeURIComponent("" + withRecur) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostDocFromWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostDocFromWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostDocFromWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostDocFrom(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostDocFrom(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Failed to persist", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Unexpected failure", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocHeader(id: string) {
        return new Promise<void>((resolve, reject) => {
            this.getDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeaderWithCallbacks(id: string, onSuccess?: (result: void) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Unexpected failure", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Deletes the specified document
     * @param id Document Key
     */
    deleteDocHeader(id: string) {
        return new Promise<any | null>((resolve, reject) => {
            this.deleteDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocHeaderWithCallbacks(id: string, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocHeader(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocHeader(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the header on the specified document
     * @param id Document Key
     * @param updatedData Replacement data
     */
    updateDocHeader(id: string, updatedData: DocMasterDetail) {
        return new Promise<any | null>((resolve, reject) => {
            this.updateDocHeaderWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocHeaderWithCallbacks(id: string, updatedData: DocMasterDetail, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocHeader(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocHeader(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("Document number cannot be changed by this method", status, _responseText, _headers, result406);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document revision, including a Document Session Key
     * @param id Document Key
     * @param revKey Revision Key
     */
    getDocHeader2(id: string, revKey: string) {
        return new Promise<void>((resolve, reject) => {
            this.getDocHeader2WithCallbacks(id, revKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeader2WithCallbacks(id: string, revKey: string, onSuccess?: (result: void) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{revKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revKey === undefined || revKey === null)
            throw new Error("The parameter 'revKey' must be defined.");
        url_ = url_.replace("{revKey}", encodeURIComponent("" + revKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeader2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader2(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Unexpected failure", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Returns the items of the specified document (current revision)
     * @param id Document Key
     */
    getDocItems(id: string) {
        return new Promise<void>((resolve, reject) => {
            this.getDocItemsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemsWithCallbacks(id: string, onSuccess?: (result: void) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItems(xhr: any): void | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Failed to persist", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Unexpected failure", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return;
    }

    /**
     * Updates the item on the specified document
     * @param id Document Key
     * @param updatedData Replacement item data
     * @return Specified item not found
     */
    updateDocItems(id: string, updatedData: DocItem) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocItemsWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocItemsWithCallbacks(id: string, updatedData: DocItem, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocItems(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts item on the specified document
     * @param id Document Key
     * @param newData New item data
     */
    addDocItems(id: string, newData: DocItem) {
        return new Promise<DocItem | null>((resolve, reject) => {
            this.addDocItemsWithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocItemsWithCallbacks(id: string, newData: DocItem, onSuccess?: (result: DocItem | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocItems(xhr: any): DocItem | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocItem.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the item on the specified document
     * @param id Document Key
     * @param itemKey Doc Item Key
     * @return Specified item not found
     */
    deleteDocItems(id: string, itemKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocItemsWithCallbacks(id, itemKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocItemsWithCallbacks(id: string, itemKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items/{itemKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (itemKey === undefined || itemKey === null)
            throw new Error("The parameter 'itemKey' must be defined.");
        url_ = url_.replace("{itemKey}", encodeURIComponent("" + itemKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocItems(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the route on the specified document
     * @param id Document Key
     */
    getDocRoute(id: string) {
        return new Promise<DocRoute[] | null>((resolve, reject) => {
            this.getDocRouteWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocRouteWithCallbacks(id: string, onSuccess?: (result: DocRoute[] | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocRoute(xhr: any): DocRoute[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Failed to persist", status, _responseText, _headers, result409);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Unexpected failure", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocRoute.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param updatedRoute Replacement Route
     * @return Specified route not found
     */
    updateDocRoute(id: string, updatedRoute: DocRoute) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocRouteWithCallbacks(id, updatedRoute, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocRouteWithCallbacks(id: string, updatedRoute: DocRoute, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedRoute);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts a route on the specified document
     * @param id Document Key
     * @param newRoute Route (DocRoute object)
     */
    addDocRoute(id: string, newRoute: DocRoute) {
        return new Promise<DocRoute | null>((resolve, reject) => {
            this.addDocRouteWithCallbacks(id, newRoute, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocRouteWithCallbacks(id: string, newRoute: DocRoute, onSuccess?: (result: DocRoute | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newRoute);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocRoute(xhr: any): DocRoute | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocRoute.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the route on the specified document
     * @param id Document Key
     * @param routeKey Route Key
     * @return Specified route not found
     */
    deleteDocRoute(id: string, routeKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocRouteWithCallbacks(id, routeKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocRouteWithCallbacks(id: string, routeKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route/{routeKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeKey === undefined || routeKey === null)
            throw new Error("The parameter 'routeKey' must be defined.");
        url_ = url_.replace("{routeKey}", encodeURIComponent("" + routeKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the route on the specified document
     * @param id Document Key
     * @param routeKey Route Key
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified route not found
     */
    patchDocRoute(id: string, routeKey: string, fieldName: string, newValue: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.patchDocRouteWithCallbacks(id, routeKey, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocRouteWithCallbacks(id: string, routeKey: string, fieldName: string, newValue: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route/{routeKey}/{fieldName}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (routeKey === undefined || routeKey === null)
            throw new Error("The parameter 'routeKey' must be defined.");
        url_ = url_.replace("{routeKey}", encodeURIComponent("" + routeKey));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocRoute(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Specified field invalid for route", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the dates for the specified document
     * @param id Document Key
     */
    getDocDates(id: string) {
        return new Promise<DocDate[] | null>((resolve, reject) => {
            this.getDocDatesWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocDatesWithCallbacks(id: string, onSuccess?: (result: DocDate[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocDates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocDates(xhr: any): DocDate[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocDate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the dates on the specified document
     * @param id Document Key
     * @param updatedData Replacement date data
     * @return Specified dates not found
     */
    updateDocDates(id: string, updatedData: DocDate) {
        return new Promise<string>((resolve, reject) => {
            this.updateDocDatesWithCallbacks(id, updatedData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateDocDatesWithCallbacks(id: string, updatedData: DocDate, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateDocDates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateDocDates(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Inserts dates on the specified document
     * @param id Document Key
     * @param newData New date data
     */
    addDocDates2(id: string, newData: DocDate) {
        return new Promise<DocDate | null>((resolve, reject) => {
            this.addDocDates2WithCallbacks(id, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addDocDates2WithCallbacks(id: string, newData: DocDate, onSuccess?: (result: DocDate | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddDocDates2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddDocDates2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddDocDates2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddDocDates2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddDocDates2(xhr: any): DocDate | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocDate.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the dates on the specified document
     * @param id Document Key
     * @param dateRowKey Doc Dates Row Key
     * @return Specified dates not found
     */
    deleteDocDates(id: string, dateRowKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocDatesWithCallbacks(id, dateRowKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocDatesWithCallbacks(id: string, dateRowKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Dates/{dateRowKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dateRowKey === undefined || dateRowKey === null)
            throw new Error("The parameter 'dateRowKey' must be defined.");
        url_ = url_.replace("{dateRowKey}", encodeURIComponent("" + dateRowKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocDatesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocDatesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocDates(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocDates(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the addresses on the specified document
     * @param id Document Key
     * @param addressKey Address Key
     * @return Specified addresses not found
     */
    deleteDocAddress(id: string, addressKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteDocAddressWithCallbacks(id, addressKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteDocAddressWithCallbacks(id: string, addressKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Addresses/{addressKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (addressKey === undefined || addressKey === null)
            throw new Error("The parameter 'addressKey' must be defined.");
        url_ = url_.replace("{addressKey}", encodeURIComponent("" + addressKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteDocAddressWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteDocAddressWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteDocAddress(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteDocAddress(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Document not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectDocListClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns a summary of document processes on a project
     * @param projectID Full Project ID
     */
    getProjectDocSummary(projectID: string) {
        return new Promise<TypeSummary[] | null>((resolve, reject) => {
            this.getProjectDocSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocSummaryWithCallbacks(projectID: string, onSuccess?: (result: TypeSummary[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/TypeSummary";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocSummary(xhr: any): TypeSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns full list of documents on a project that match the requested document type
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     */
    getProjectDocList(projectID: string, forDocType: string) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.getProjectDocListWithCallbacks(projectID, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocListWithCallbacks(projectID: string, forDocType: string, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match filters <b>INCOMPLETE</b>
     */
    matchingProjectDocList(projectID: string, usingFilters: QueryFilters) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.matchingProjectDocListWithCallbacks(projectID, usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingProjectDocListWithCallbacks(projectID: string, usingFilters: QueryFilters, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents data that has changed
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     * @param dataSummary KVP of current row keys and etags
     */
    getChangedDocList(projectID: string, forDocType: string, dataSummary: CurrentDataSummary[]) {
        return new Promise<DataDifferential | null>((resolve, reject) => {
            this.getChangedDocListWithCallbacks(projectID, forDocType, dataSummary, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getChangedDocListWithCallbacks(projectID: string, forDocType: string, dataSummary: CurrentDataSummary[], onSuccess?: (result: DataDifferential | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs/changes?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataSummary);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetChangedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetChangedDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetChangedDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetChangedDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetChangedDocList(xhr: any): DataDifferential | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataDifferential.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class LookupClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResultAll(lookupName: string, dataContext: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultAllWithCallbacks(lookupName, dataContext, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultAllWithCallbacks(lookupName: string, dataContext: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResultAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResultAll(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultWithCallbacks(lookupName, dataContext, depends1, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultWithCallbacks(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult2(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult2WithCallbacks(lookupName, dataContext, depends1, depends2, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult2(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult3(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult3WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult3WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult3WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult3(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult3(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of matches for a specified lookup and context
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResultBase(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultBaseWithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultBaseWithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultBaseWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultBaseWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultBaseWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResultBase(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResultBase(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns result of query given specified context
     * @param dataContext Data Set ID or 1
     * @param project Project ID (or 0 for none; 1 for from context)
     * @param id Guid key or 0 for none; 1 for from context
     * @param dtk (optional) Guid process type or omit or 0 for none; 1 from context
     * @param depends1 (optional) optional additional context for query
     * @param depends2 (optional) Optional additional context for query
     * @param depends3 (optional) Optional additional context for query
     * @param depends4 (optional) Optional additional context for query
     */
    getQueryResult(queryName: string, dataContext: string, project: string, id: string, dtk?: string | null | undefined, depends1?: string | null | undefined, depends2?: string | null | undefined, depends3?: string | null | undefined, depends4?: string | null | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getQueryResultWithCallbacks(queryName, dataContext, project, id, dtk, depends1, depends2, depends3, depends4, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getQueryResultWithCallbacks(queryName: string, dataContext: string, project: string, id: string, dtk: string | null | undefined, depends1: string | null | undefined, depends2: string | null | undefined, depends3: string | null | undefined, depends4: string | null | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/query/{queryName}/{dataContext}/{project}/{id}?";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (project === undefined || project === null)
            throw new Error("The parameter 'project' must be defined.");
        url_ = url_.replace("{project}", encodeURIComponent("" + project));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dtk !== undefined && dtk !== null)
            url_ += "dtk=" + encodeURIComponent("" + dtk) + "&";
        if (depends1 !== undefined && depends1 !== null)
            url_ += "depends1=" + encodeURIComponent("" + depends1) + "&";
        if (depends2 !== undefined && depends2 !== null)
            url_ += "depends2=" + encodeURIComponent("" + depends2) + "&";
        if (depends3 !== undefined && depends3 !== null)
            url_ += "depends3=" + encodeURIComponent("" + depends3) + "&";
        if (depends4 !== undefined && depends4 !== null)
            url_ += "depends4=" + encodeURIComponent("" + depends4) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetQueryResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetQueryResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetQueryResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetQueryResult(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetQueryResult(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns result of query given specified context
     * @param dataContext Data Set ID or 1
     * @param queryContext ProjectLike (or 0 for none; 1 for from context; or specific); depends1-4
     * @param id (optional) Guid key or 0 for none; 1 for from context
     * @param dtk (optional) Guid process type or omit or 0 for none; 1 from context
     */
    getQueryResultWithContextGET(queryName: string, dataContext: string, queryContext: QueryFilters, id?: string | null | undefined, dtk?: string | null | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getQueryResultWithContextGETWithCallbacks(queryName, dataContext, queryContext, id, dtk, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getQueryResultWithContextGETWithCallbacks(queryName: string, dataContext: string, queryContext: QueryFilters, id: string | null | undefined, dtk: string | null | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/query/{queryName}/{dataContext}?";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (dtk !== undefined && dtk !== null)
            url_ += "dtk=" + encodeURIComponent("" + dtk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryContext);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetQueryResultWithContextGETWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetQueryResultWithContextGETWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetQueryResultWithContextGETWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetQueryResultWithContextGET(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetQueryResultWithContextGET(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns result of query given specified context
     * @param dataContext Data Set ID or 1
     * @param queryContext ProjectLike (or 0 for none; 1 for from context; or specific); depends1-4
     * @param id (optional) Guid key or 0 for none; 1 for from context
     * @param dtk (optional) Guid process type or omit or 0 for none; 1 from context
     */
    getQueryResultWithContextPOST(queryName: string, dataContext: string, queryContext: QueryFilters, id?: string | null | undefined, dtk?: string | null | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getQueryResultWithContextPOSTWithCallbacks(queryName, dataContext, queryContext, id, dtk, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getQueryResultWithContextPOSTWithCallbacks(queryName: string, dataContext: string, queryContext: QueryFilters, id: string | null | undefined, dtk: string | null | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/query/{queryName}/{dataContext}?";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (dtk !== undefined && dtk !== null)
            url_ += "dtk=" + encodeURIComponent("" + dtk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryContext);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetQueryResultWithContextPOSTWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetQueryResultWithContextPOSTWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetQueryResultWithContextPOSTWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetQueryResultWithContextPOST(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetQueryResultWithContextPOST(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestionsAll(lookupName: string, dataContext: string, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsAllWithCallbacks(lookupName, dataContext, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsAllWithCallbacks(lookupName: string, dataContext: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestionsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsAll(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions(lookupName: string, dataContext: string, depends1: string, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithCallbacks(lookupName, dataContext, depends1, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithCallbacks(lookupName: string, dataContext: string, depends1: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions2(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term?: string | null | undefined, limit?: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions2WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions2(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param sessionContext Session Context for Suggestions, use 1 for default
     * @param searchContext Search Context for Suggestions (depends on list, seed, limit)
     */
    getSuggestionsWithContext(lookupName: string, sessionContext: string, searchContext: QueryFilters) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithContextWithCallbacks(lookupName, sessionContext, searchContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithContextWithCallbacks(lookupName: string, sessionContext: string, searchContext: QueryFilters, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{sessionContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (sessionContext === undefined || sessionContext === null)
            throw new Error("The parameter 'sessionContext' must be defined.");
        url_ = url_.replace("{sessionContext}", encodeURIComponent("" + sessionContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchContext);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithContextWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithContextWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestionsWithContext(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsWithContext(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns viewable/printable value
     * @param displayName Name of Display Rule
     * @param dataContext Context for Suggestions, use 1 for default
     * @param dataValue Value to be described
     * @param depends1 Optional context for Suggestions, pass empty or undefined
     * @param depends2 Optional context for Suggestions, pass empty or undefined
     * @param depends3 Optional context for Suggestions, pass empty or undefined
     * @param depends4 Optional context for Suggestions, pass empty or undefined
     */
    getDisplayValue(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDisplayValueWithCallbacks(displayName, dataContext, dataValue, depends1, depends2, depends3, depends4, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayValueWithCallbacks(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}/{dataContext}/{dataValue}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (dataValue === undefined || dataValue === null)
            throw new Error("The parameter 'dataValue' must be defined.");
        url_ = url_.replace("{dataValue}", encodeURIComponent("" + dataValue));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDisplayValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayValue(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns viewable/printable value
     * @param displayName Name of Display Rule
     * @param dataContext Context for Suggestions, use 1 for default
     * @param valueFilters Value to be described {MatchingSeed:'pv',DependsOn:['1','2','3','4']}
     */
    getDisplayValueViaPost(displayName: string, dataContext: string, valueFilters: QueryFilters) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDisplayValueViaPostWithCallbacks(displayName, dataContext, valueFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayValueViaPostWithCallbacks(displayName: string, dataContext: string, valueFilters: QueryFilters, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}/{dataContext}";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(valueFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayValueViaPostWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayValueViaPostWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayValueViaPostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDisplayValueViaPost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayValueViaPost(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of choices for a specified context
     * @param setName Name of Code Set
     * @param forDocType Document / Process Context for choices, use 1 for default
     */
    getCodeChoices(setName: string, forDocType: string) {
        return new Promise<CodeChoice[] | null>((resolve, reject) => {
            this.getCodeChoicesWithCallbacks(setName, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCodeChoicesWithCallbacks(setName: string, forDocType: string, onSuccess?: (result: CodeChoice[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/choices/{setName}/{forDocType}";
        if (setName === undefined || setName === null)
            throw new Error("The parameter 'setName' must be defined.");
        url_ = url_.replace("{setName}", encodeURIComponent("" + setName));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined.");
        url_ = url_.replace("{forDocType}", encodeURIComponent("" + forDocType));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCodeChoicesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCodeChoices(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCodeChoices(xhr: any): CodeChoice[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeChoice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AlertsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns alert items for a specified user
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserAlertList(forUserKey: string) {
        return new Promise<UserAlert[] | null>((resolve, reject) => {
            this.getUserAlertListWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserAlertListWithCallbacks(forUserKey: string, onSuccess?: (result: UserAlert[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserAlertListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserAlertList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserAlertList(xhr: any): UserAlert[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAlert.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates and stores an alert
     * @param theAlert Model with new alert. Specify AlertText, Description.  UserKey, DocMasterKey, Project, Source, SourceKey and Info1 are optional;
     */
    createAlert(theAlert: UserAlert) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.createAlertWithCallbacks(theAlert, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createAlertWithCallbacks(theAlert: UserAlert, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(theAlert);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processCreateAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes all alert item for the specified user
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAllAlerts(forUserKey?: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAllAlertsWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAllAlertsWithCallbacks(forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/all?";
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAllAlertsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAllAlerts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAllAlerts(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes a specific alert item for the specified user
     * @param id Alert Key
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAlert(id: string, forUserKey?: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAlertWithCallbacks(id, forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAlertWithCallbacks(id: string, forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("key not found", status, _responseText, _headers, result404);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectTeamClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns members of the specified project team
     * @param projectID Full Project ID
     * @param includeHidden True to include hidden team members
     */
    getProjectTeamList(projectID: string, includeHidden: boolean) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.getProjectTeamListWithCallbacks(projectID, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectTeamListWithCallbacks(projectID: string, includeHidden: boolean, onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectTeamListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectTeamList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectTeamList(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Adds new team member(s) to the specified project.  Send collection of ProjectTeamMember, only value required is UserKey
     */
    addProjectTeamMembers(projectID: string, newUserData: ProjectTeamMember[]) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.addProjectTeamMembersWithCallbacks(projectID, newUserData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private addProjectTeamMembersWithCallbacks(projectID: string, newUserData: ProjectTeamMember[], onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAddProjectTeamMembersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddProjectTeamMembersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAddProjectTeamMembersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAddProjectTeamMembers(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAddProjectTeamMembers(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the insert", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Deletes the team member on the specified project
     * @param projectID Full Project ID
     * @param teamMemberKey Team Member Key (not the User Key)
     * @return Specified team member not found
     */
    deleteTeamMember(projectID: string, teamMemberKey: string) {
        return new Promise<string>((resolve, reject) => {
            this.deleteTeamMemberWithCallbacks(projectID, teamMemberKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteTeamMemberWithCallbacks(projectID: string, teamMemberKey: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{teamMemberKey}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (teamMemberKey === undefined || teamMemberKey === null)
            throw new Error("The parameter 'teamMemberKey' must be defined.");
        url_ = url_.replace("{teamMemberKey}", encodeURIComponent("" + teamMemberKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteTeamMember(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the delete", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the team member on the specified project
     * @param projectID Project ID
     * @param teamMemberKey ID of team member entity to replace, not the UserKey.  When empty, taken from newData.UserProjectKey!
     * @param newData updated data for this entity
     * @return Specified team member not found
     */
    updateTeamMember(projectID: string, teamMemberKey: string, newData: ProjectTeamMember) {
        return new Promise<string>((resolve, reject) => {
            this.updateTeamMemberWithCallbacks(projectID, teamMemberKey, newData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private updateTeamMemberWithCallbacks(projectID: string, teamMemberKey: string, newData: ProjectTeamMember, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{teamMemberKey}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (teamMemberKey === undefined || teamMemberKey === null)
            throw new Error("The parameter 'teamMemberKey' must be defined.");
        url_ = url_.replace("{teamMemberKey}", encodeURIComponent("" + teamMemberKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUpdateTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUpdateTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUpdateTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUpdateTeamMember(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUpdateTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Attempted to change read only data", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the team member on the specified project
     * @param projectID Project ID
     * @param userProjectTeamKey Key for Team Member Row
     * @param fieldName Field Name
     * @param newValue Replacement Value
     * @return Specified team member not found
     */
    patchProjectTeam(projectID: string, userProjectTeamKey: string, fieldName: string, newValue: string | null) {
        return new Promise<string>((resolve, reject) => {
            this.patchProjectTeamWithCallbacks(projectID, userProjectTeamKey, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchProjectTeamWithCallbacks(projectID: string, userProjectTeamKey: string, fieldName: string, newValue: string | null, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{userProjectTeamKey}/{fieldName}?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (userProjectTeamKey === undefined || userProjectTeamKey === null)
            throw new Error("The parameter 'userProjectTeamKey' must be defined.");
        url_ = url_.replace("{userProjectTeamKey}", encodeURIComponent("" + userProjectTeamKey));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchProjectTeamWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchProjectTeamWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchProjectTeamWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchProjectTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchProjectTeam(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Specified field invalid for team member", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Replaces the specified team member on a given project or projects that match the scope
     * @param projectID Project ID
     * @param fromUser ID of team member to replace
     * @param toUser ID of new team member
     * @param scope A project id mask or % for all
     * @return Specified team member not found
     */
    replaceTeamMember(projectID: string, fromUser: string, toUser: string, scope: string) {
        return new Promise<string>((resolve, reject) => {
            this.replaceTeamMemberWithCallbacks(projectID, fromUser, toUser, scope, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private replaceTeamMemberWithCallbacks(projectID: string, fromUser: string, toUser: string, scope: string, onSuccess?: (result: string) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team/{fromUser}/{toUser}/{scope}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (fromUser === undefined || fromUser === null)
            throw new Error("The parameter 'fromUser' must be defined.");
        url_ = url_.replace("{fromUser}", encodeURIComponent("" + fromUser));
        if (toUser === undefined || toUser === null)
            throw new Error("The parameter 'toUser' must be defined.");
        url_ = url_.replace("{toUser}", encodeURIComponent("" + toUser));
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReplaceTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReplaceTeamMemberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReplaceTeamMemberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processReplaceTeamMember(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReplaceTeamMember(xhr: any): string | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 204) {
            const _responseText = xhr.responseText;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the update", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AccountClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Authenticates a session and generates a FormsAuthenticationTicket and cookie
     */
    postLogin(credentials: SiteLogin) {
        return new Promise<string | null>((resolve, reject) => {
            this.postLoginWithCallbacks(credentials, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postLoginWithCallbacks(credentials: SiteLogin, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostLoginWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostLogin(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 302) {
            const _responseText = xhr.responseText;
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result302 = resultData302 !== undefined ? resultData302 : <any>null;
            return throwException("Unusable credentials with redirect to login ", status, _responseText, _headers, result302);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Not allowed now (see message for issue) ", status, _responseText, _headers, result409);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Not allowed now (already authenticated?)", status, _responseText, _headers, result400);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general information about the Authenticed user
     */
    getUserData() {
        return new Promise<CurrentUser | null>((resolve, reject) => {
            this.getUserDataWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserDataWithCallbacks(onSuccess?: (result: CurrentUser | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserData(xhr: any): CurrentUser | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUser.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns information about password composition
     */
    getPasswordOptions() {
        return new Promise<PasswordConfiguredOptions | null>((resolve, reject) => {
            this.getPasswordOptionsWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getPasswordOptionsWithCallbacks(onSuccess?: (result: PasswordConfiguredOptions | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/PasswordOptions";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetPasswordOptionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetPasswordOptionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetPasswordOptionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetPasswordOptions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetPasswordOptions(xhr: any): PasswordConfiguredOptions | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PasswordConfiguredOptions.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns authorization flags for specified demand if they match or exceed the request
     * @param demand Demand Context
     */
    getAccess(demand: PermissionContext) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getAccessWithCallbacks(demand, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getAccessWithCallbacks(demand: PermissionContext, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Authorized";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(demand);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetAccessWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetAccess(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetAccess(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ContactClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns contacts that match filters
     * @param usingFilters Search Criteria
     */
    matchingContactList(usingFilters: ContactFilters) {
        return new Promise<ContactSummary[] | null>((resolve, reject) => {
            this.matchingContactListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingContactListWithCallbacks(usingFilters: ContactFilters, onSuccess?: (result: ContactSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingContactListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingContactList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingContactList(xhr: any): ContactSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the contact
     * @param id Contact Key
     */
    getContact(id: string) {
        return new Promise<Contact | null>((resolve, reject) => {
            this.getContactWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getContactWithCallbacks(id: string, onSuccess?: (result: Contact | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetContact(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetContact(xhr: any): Contact | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ActionItemsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns action items for specified User
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserActionItemsAll(forUserKey: string) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getUserActionItemsAllWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsAllWithCallbacks(forUserKey: string, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItemsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItemsAll(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns action items that match filters ProjectLike, TitleLike, ForDocType, FromDate, ThruDate, NewOnly
     */
    getMatchingUserActionItems(usingFilters: QueryFilters) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getMatchingUserActionItemsWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingUserActionItemsWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/matching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingUserActionItems(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     */
    getUserActionItems(userID: string, routeID: string) {
        return new Promise<RouteActionInfo | null>((resolve, reject) => {
            this.getUserActionItemsWithCallbacks(userID, routeID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsWithCallbacks(userID: string, routeID: string, onSuccess?: (result: RouteActionInfo | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItems(xhr: any): RouteActionInfo | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result500);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Requested route not found", status, _responseText, _headers, result404);
        } else if (status === 503) {
            const _responseText = xhr.responseText;
            let result503: any = null;
            let resultData503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result503 = resultData503 !== undefined ? resultData503 : <any>null;
            return throwException("Try again after reauthentication", status, _responseText, _headers, result503);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RouteActionInfo.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     * @param actionData action is patch data
     * @param actionMode (optional) Mode is id,match,every
     */
    patchUserActionItems(userID: string, routeID: string, actionData: RouteActionData, actionMode?: string | null | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchUserActionItemsWithCallbacks(userID, routeID, actionData, actionMode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserActionItemsWithCallbacks(userID: string, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}?";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        if (actionMode !== undefined && actionMode !== null)
            url_ += "actionMode=" + encodeURIComponent("" + actionMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserActionItems(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns projects that match User and hidden filter
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param includeHidden True to include hidden projects in the result
     */
    getList(forUserKey: string, includeHidden: boolean) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getListWithCallbacks(forUserKey, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getListWithCallbacks(forUserKey: string, includeHidden: boolean, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that match User, Program, hidden filter
     */
    getMatchingList(usingFilters: QueryFilters) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getMatchingListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingListWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates the specified entry on the user project list
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param projectID Project ID or UserProjectKey
     * @param fieldName Field Name
     * @param newValue Replacement Value
     */
    patchUserProjectList(forUserKey: string, projectID: string, fieldName: string, newValue: string | null) {
        return new Promise<any | null>((resolve, reject) => {
            this.patchUserProjectListWithCallbacks(forUserKey, projectID, fieldName, newValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserProjectListWithCallbacks(forUserKey: string, projectID: string, fieldName: string, newValue: string | null, onSuccess?: (result: any | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects/list/{forUserKey}/{projectID}/{fieldName}?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined.");
        url_ = url_.replace("{forUserKey}", encodeURIComponent("" + forUserKey));
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        if (newValue === undefined)
            throw new Error("The parameter 'newValue' must be defined.");
        else if(newValue !== null)
            url_ += "newValue=" + encodeURIComponent("" + newValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserProjectListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserProjectListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserProjectListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchUserProjectList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserProjectList(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Not currently authenticated or lacks authorization", status, _responseText, _headers, result403);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Project not found, or not accessible", status, _responseText, _headers, result404);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("Specified field invalid ", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("Could not persist the patch", status, _responseText, _headers, result409);
        } else if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectKPIClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns list of KPI facts for the specified project
     * @param projectID Full Project ID
     */
    getProjectKPIFacts(projectID: string) {
        return new Promise<ProjKPIFact[] | null>((resolve, reject) => {
            this.getProjectKPIFactsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectKPIFactsWithCallbacks(projectID: string, onSuccess?: (result: ProjKPIFact[] | null) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/KPI";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectKPIFactsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectKPIFacts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectKPIFacts(xhr: any): ProjKPIFact[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("Not currently authenticated", status, _responseText, _headers, result401);
        } else if (status === 403) {
            const _responseText = xhr.responseText;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 !== undefined ? resultData403 : <any>null;
            return throwException("Access denied", status, _responseText, _headers, result403);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("Internal failure; see response", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjKPIFact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ExcelToolsClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns general context information
     * @param id Key of BFA document or project ID
     */
    getBFAAbstract(id: string) {
        return new Promise<BFAAbstract | null>((resolve, reject) => {
            this.getBFAAbstractWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getBFAAbstractWithCallbacks(id: string, onSuccess?: (result: BFAAbstract | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/excel/bfa/{id}/abtract";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetBFAAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetBFAAbstractWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetBFAAbstractWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetBFAAbstract(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetBFAAbstract(xhr: any): BFAAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BFAAbstract.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class CatalogClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns a history of access to the specified ID
     * @param iD Catalog File Key
     */
    getCatalogAccessHistory(iD: string) {
        return new Promise<FileAccessHistory[] | null>((resolve, reject) => {
            this.getCatalogAccessHistoryWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogAccessHistoryWithCallbacks(iD: string, onSuccess?: (result: FileAccessHistory[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/AccessHistory";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogAccessHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogAccessHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogAccessHistory(xhr: any): FileAccessHistory[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileAccessHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list of versions for the specified ID
     * @param iD Catalog File Key
     */
    getCatalogVersions(iD: string) {
        return new Promise<FileVersion[] | null>((resolve, reject) => {
            this.getCatalogVersionsWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogVersionsWithCallbacks(iD: string, onSuccess?: (result: FileVersion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/versions";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogVersionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogVersions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogVersions(xhr: any): FileVersion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileVersion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UICFGClient extends APIClientBase {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("http://stany2017/SFPMS");
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param partName Part Name
     * @param forDocType (optional) optional document type (guid format)
     * @param forContext (optional) optional context (subtype, container, etc)
     */
    getLiveDisplay(partName: string, forDocType?: string | null | undefined, forContext?: string | null | undefined) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLiveDisplayWithCallbacks(partName, forDocType, forContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLiveDisplayWithCallbacks(partName: string, forDocType: string | null | undefined, forContext: string | null | undefined, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/live/{partName}?";
        if (partName === undefined || partName === null)
            throw new Error("The parameter 'partName' must be defined.");
        url_ = url_.replace("{partName}", encodeURIComponent("" + partName));
        if (forDocType !== undefined && forDocType !== null)
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        if (forContext !== undefined && forContext !== null)
            url_ += "forContext=" + encodeURIComponent("" + forContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLiveDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLiveDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLiveDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param lookupName Part Name
     */
    getLookupDisplay(lookupName: string) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLookupDisplayWithCallbacks(lookupName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupDisplayWithCallbacks(lookupName: string, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/lookup/{lookupName}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResult(ruleName: string, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: string | null | undefined) {
        return new Promise<string | null>((resolve, reject) => {
            this.getRuleResultWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultWithCallbacks(ruleName: string, testValue: string | null, filterValue: string | null | undefined, defaultValue: string | null | undefined, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/string?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue !== undefined && defaultValue !== null)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetRuleResult(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResult(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResultAsBoolean(ruleName: string, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: boolean | undefined) {
        return new Promise<boolean>((resolve, reject) => {
            this.getRuleResultAsBooleanWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultAsBooleanWithCallbacks(ruleName: string, testValue: string | null, filterValue: string | null | undefined, defaultValue: boolean | undefined, onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/boolean?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue === null)
            throw new Error("The parameter 'defaultValue' cannot be null.");
        else if (defaultValue !== undefined)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultAsBooleanWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultAsBooleanWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultAsBooleanWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetRuleResultAsBoolean(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResultAsBoolean(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns CFG Rule result information
     * @param ruleName Rule Name (eq DocTypeConfig or PresetSearch)
     * @param testValue Test Value (eq DocTypeConfig or PresetSearch)
     * @param filterValue (optional) Filter Value (often a Doc Type Key)
     * @param defaultValue (optional) Default Value (mostly helps indicate type)
     */
    getRuleResultAsNumber(ruleName: string, testValue: string | null, filterValue?: string | null | undefined, defaultValue?: number | undefined) {
        return new Promise<number>((resolve, reject) => {
            this.getRuleResultAsNumberWithCallbacks(ruleName, testValue, filterValue, defaultValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getRuleResultAsNumberWithCallbacks(ruleName: string, testValue: string | null, filterValue: string | null | undefined, defaultValue: number | undefined, onSuccess?: (result: number) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/rule/{ruleName}/integer?";
        if (ruleName === undefined || ruleName === null)
            throw new Error("The parameter 'ruleName' must be defined.");
        url_ = url_.replace("{ruleName}", encodeURIComponent("" + ruleName));
        if (testValue === undefined)
            throw new Error("The parameter 'testValue' must be defined.");
        else if(testValue !== null)
            url_ += "testValue=" + encodeURIComponent("" + testValue) + "&";
        if (filterValue !== undefined && filterValue !== null)
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&";
        if (defaultValue === null)
            throw new Error("The parameter 'defaultValue' cannot be null.");
        else if (defaultValue !== undefined)
            url_ += "defaultValue=" + encodeURIComponent("" + defaultValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetRuleResultAsNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetRuleResultAsNumberWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetRuleResultAsNumberWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetRuleResultAsNumber(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetRuleResultAsNumber(xhr: any): number | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

/** Abstracted information about a project */
export class ProjectAbstract implements IProjectAbstract {
    /** Project ID */
    Project!: string;
    /** Key for Project */
    ProjectKey!: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey!: string;
    /** Key for Site Address */
    SiteAddrKey!: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold!: number;
    /** Geo latitude (project setup) */
    latitude!: number;
    /** Geo longitude (project setup) */
    longitude!: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey!: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active!: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate!: Date;
    /** From Dates on project setup */
    ProjectFinishDate!: Date;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks!: boolean;
    /** When true, disable Note */
    ExcludeNoteUI!: boolean;
    /** When true, disable Links */
    ExcludeLinkUI!: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI!: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI!: boolean;
    /** Indicates when this abstract was generated */
    dataResolved!: Date;

    constructor(data?: IProjectAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectKey = _data["ProjectKey"];
            this.ProjectType = _data["ProjectType"];
            this.SetupDocKey = _data["SetupDocKey"];
            this.SiteAddrKey = _data["SiteAddrKey"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Phone = _data["Phone"];
            this.Fax = _data["Fax"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.SCBudgetMode = _data["SCBudgetMode"];
            this.PlanRoomMode = _data["PlanRoomMode"];
            this.WebCamURL = _data["WebCamURL"];
            this.Description = _data["Description"];
            this.ForecastThreshold = _data["ForecastThreshold"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.cldStoreKey = _data["cldStoreKey"];
            this.CloudDrivePath = _data["CloudDrivePath"];
            this.GLSUB = _data["GLSUB"];
            this.Active = _data["Active"];
            this.Status = _data["Status"];
            this.StatusText = _data["StatusText"];
            this.Subtype = _data["Subtype"];
            this.DocState = _data["DocState"];
            this.ProjectDocReference = _data["ProjectDocReference"];
            this.ProjectUniReference = _data["ProjectUniReference"];
            this.ProjectCustomerID = _data["ProjectCustomerID"];
            this.ProjectCustomerName = _data["ProjectCustomerName"];
            this.ProjectTitle = _data["ProjectTitle"];
            this.ProjectIDMasked = _data["ProjectIDMasked"];
            this.ProjectTabName = _data["ProjectTabName"];
            this.ProjectTabTip = _data["ProjectTabTip"];
            this.ProjectBar = _data["ProjectBar"];
            this.ProjectStartDate = _data["ProjectStartDate"] ? new Date(_data["ProjectStartDate"].toString()) : <any>undefined;
            this.ProjectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.ProjectStartFormat = _data["ProjectStartFormat"];
            this.ProjectFinishFormat = _data["ProjectFinishFormat"];
            this.ProjectPhoto = _data["ProjectPhoto"];
            this.ProjectCurrentNote = _data["ProjectCurrentNote"];
            if (Array.isArray(_data["actionsMenu"])) {
                this.actionsMenu = [] as any;
                for (let item of _data["actionsMenu"])
                    this.actionsMenu!.push(MenuAction.fromJS(item));
            }
            if (Array.isArray(_data["registerMenu"])) {
                this.registerMenu = [] as any;
                for (let item of _data["registerMenu"])
                    this.registerMenu!.push(MenuAction.fromJS(item));
            }
            this.AlwaysShowLinks = _data["AlwaysShowLinks"];
            this.ExcludeNoteUI = _data["ExcludeNoteUI"];
            this.ExcludeLinkUI = _data["ExcludeLinkUI"];
            this.ExcludeCostAnalysisUI = _data["ExcludeCostAnalysisUI"];
            this.ExcludeKPIUI = _data["ExcludeKPIUI"];
            this.dataResolved = _data["dataResolved"] ? new Date(_data["dataResolved"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectKey"] = this.ProjectKey;
        data["ProjectType"] = this.ProjectType;
        data["SetupDocKey"] = this.SetupDocKey;
        data["SiteAddrKey"] = this.SiteAddrKey;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Phone"] = this.Phone;
        data["Fax"] = this.Fax;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["SCBudgetMode"] = this.SCBudgetMode;
        data["PlanRoomMode"] = this.PlanRoomMode;
        data["WebCamURL"] = this.WebCamURL;
        data["Description"] = this.Description;
        data["ForecastThreshold"] = this.ForecastThreshold;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["cldStoreKey"] = this.cldStoreKey;
        data["CloudDrivePath"] = this.CloudDrivePath;
        data["GLSUB"] = this.GLSUB;
        data["Active"] = this.Active;
        data["Status"] = this.Status;
        data["StatusText"] = this.StatusText;
        data["Subtype"] = this.Subtype;
        data["DocState"] = this.DocState;
        data["ProjectDocReference"] = this.ProjectDocReference;
        data["ProjectUniReference"] = this.ProjectUniReference;
        data["ProjectCustomerID"] = this.ProjectCustomerID;
        data["ProjectCustomerName"] = this.ProjectCustomerName;
        data["ProjectTitle"] = this.ProjectTitle;
        data["ProjectIDMasked"] = this.ProjectIDMasked;
        data["ProjectTabName"] = this.ProjectTabName;
        data["ProjectTabTip"] = this.ProjectTabTip;
        data["ProjectBar"] = this.ProjectBar;
        data["ProjectStartDate"] = this.ProjectStartDate ? this.ProjectStartDate.toISOString() : <any>undefined;
        data["ProjectFinishDate"] = this.ProjectFinishDate ? this.ProjectFinishDate.toISOString() : <any>undefined;
        data["ProjectStartFormat"] = this.ProjectStartFormat;
        data["ProjectFinishFormat"] = this.ProjectFinishFormat;
        data["ProjectPhoto"] = this.ProjectPhoto;
        data["ProjectCurrentNote"] = this.ProjectCurrentNote;
        if (Array.isArray(this.actionsMenu)) {
            data["actionsMenu"] = [];
            for (let item of this.actionsMenu)
                data["actionsMenu"].push(item.toJSON());
        }
        if (Array.isArray(this.registerMenu)) {
            data["registerMenu"] = [];
            for (let item of this.registerMenu)
                data["registerMenu"].push(item.toJSON());
        }
        data["AlwaysShowLinks"] = this.AlwaysShowLinks;
        data["ExcludeNoteUI"] = this.ExcludeNoteUI;
        data["ExcludeLinkUI"] = this.ExcludeLinkUI;
        data["ExcludeCostAnalysisUI"] = this.ExcludeCostAnalysisUI;
        data["ExcludeKPIUI"] = this.ExcludeKPIUI;
        data["dataResolved"] = this.dataResolved ? this.dataResolved.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectAbstract {
        const json = this.toJSON();
        let result = new ProjectAbstract();
        result.init(json);
        return result;
    }
}

/** Abstracted information about a project */
export interface IProjectAbstract {
    /** Project ID */
    Project: string;
    /** Key for Project */
    ProjectKey: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey: string;
    /** Key for Site Address */
    SiteAddrKey: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold: number;
    /** Geo latitude (project setup) */
    latitude: number;
    /** Geo longitude (project setup) */
    longitude: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate: Date;
    /** From Dates on project setup */
    ProjectFinishDate: Date;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks: boolean;
    /** When true, disable Note */
    ExcludeNoteUI: boolean;
    /** When true, disable Links */
    ExcludeLinkUI: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI: boolean;
    /** Indicates when this abstract was generated */
    dataResolved: Date;
}

/** Describes a Menu or Action or Dialog Field */
export class MenuAction implements IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string | undefined;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** optional arguement */
    CommandArgument?: string | undefined;
    /** True if enabled */
    Enabled!: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits?: number | undefined;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string | undefined;
    /** Optional additional help information */
    InfoText?: string | undefined;
    /** Default value */
    DefaultValue?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits?: number | undefined;
    /** Controls order of choices within MenuID */
    MenuSeq?: number | undefined;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** list of choices for this element (if applicable) */
    Items?: MenuAction[] | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled?: boolean | undefined;

    constructor(data?: IMenuAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.MenuID = _data["MenuID"];
            this.CommandName = _data["CommandName"];
            this.CommandArgument = _data["CommandArgument"];
            this.Enabled = _data["Enabled"];
            this.HasPermits = _data["HasPermits"];
            this.IconImageUrl = _data["IconImageUrl"];
            this.ItemText = _data["ItemText"];
            this.InfoText = _data["InfoText"];
            this.DefaultValue = _data["DefaultValue"];
            this.HRef = _data["HRef"];
            this.HrefTarget = _data["HrefTarget"];
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.NeedPermits = _data["NeedPermits"];
            this.MenuSeq = _data["MenuSeq"];
            this.Confirm = _data["Confirm"];
            if (Array.isArray(_data["Choices"])) {
                this.Choices = [] as any;
                for (let item of _data["Choices"])
                    this.Choices!.push(Suggestion.fromJS(item));
            }
            if (Array.isArray(_data["Items"])) {
                this.Items = [] as any;
                for (let item of _data["Items"])
                    this.Items!.push(MenuAction.fromJS(item));
            }
            this.HideifDisabled = _data["HideifDisabled"];
        }
    }

    static fromJS(data: any): MenuAction {
        data = typeof data === 'object' ? data : {};
        let result = new MenuAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MenuID"] = this.MenuID;
        data["CommandName"] = this.CommandName;
        data["CommandArgument"] = this.CommandArgument;
        data["Enabled"] = this.Enabled;
        data["HasPermits"] = this.HasPermits;
        data["IconImageUrl"] = this.IconImageUrl;
        data["ItemText"] = this.ItemText;
        data["InfoText"] = this.InfoText;
        data["DefaultValue"] = this.DefaultValue;
        data["HRef"] = this.HRef;
        data["HrefTarget"] = this.HrefTarget;
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["NeedPermits"] = this.NeedPermits;
        data["MenuSeq"] = this.MenuSeq;
        data["Confirm"] = this.Confirm;
        if (Array.isArray(this.Choices)) {
            data["Choices"] = [];
            for (let item of this.Choices)
                data["Choices"].push(item.toJSON());
        }
        if (Array.isArray(this.Items)) {
            data["Items"] = [];
            for (let item of this.Items)
                data["Items"].push(item.toJSON());
        }
        data["HideifDisabled"] = this.HideifDisabled;
        return data; 
    }

    clone(): MenuAction {
        const json = this.toJSON();
        let result = new MenuAction();
        result.init(json);
        return result;
    }
}

/** Describes a Menu or Action or Dialog Field */
export interface IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string | undefined;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** optional arguement */
    CommandArgument?: string | undefined;
    /** True if enabled */
    Enabled: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits?: number | undefined;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string | undefined;
    /** Optional additional help information */
    InfoText?: string | undefined;
    /** Default value */
    DefaultValue?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits?: number | undefined;
    /** Controls order of choices within MenuID */
    MenuSeq?: number | undefined;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** list of choices for this element (if applicable) */
    Choices?: Suggestion[] | undefined;
    /** list of choices for this element (if applicable) */
    Items?: MenuAction[] | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled?: boolean | undefined;
}

/** Attributes describing a member of a project team */
export class Suggestion implements ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;

    constructor(data?: ISuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Suggestion {
        data = typeof data === 'object' ? data : {};
        let result = new Suggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): Suggestion {
        const json = this.toJSON();
        let result = new Suggestion();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;
}

/** Attributes describing a Link to a parent or child  project */
export class ProjectLink implements IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey!: string;
    /** Key for document that owns the link */
    DocMasterKey?: string | undefined;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart!: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish!: Date;
    /** EAC Contract Value  */
    CurrentContract!: number;
    /** When True, this is a child project */
    IsChild!: boolean;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttachKey = _data["DocAttachKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.LinkedProjectContractKey = _data["LinkedProjectContractKey"];
            this.Project = _data["Project"];
            this.Title = _data["Title"];
            this.Location = _data["Location"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.StatusDescription = _data["StatusDescription"];
            this.ProjectStart = _data["ProjectStart"] ? new Date(_data["ProjectStart"].toString()) : <any>undefined;
            this.ProjectFinish = _data["ProjectFinish"] ? new Date(_data["ProjectFinish"].toString()) : <any>undefined;
            this.CurrentContract = _data["CurrentContract"];
            this.IsChild = _data["IsChild"];
        }
    }

    static fromJS(data: any): ProjectLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.DocAttachKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["LinkedProjectContractKey"] = this.LinkedProjectContractKey;
        data["Project"] = this.Project;
        data["Title"] = this.Title;
        data["Location"] = this.Location;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["StatusDescription"] = this.StatusDescription;
        data["ProjectStart"] = this.ProjectStart ? this.ProjectStart.toISOString() : <any>undefined;
        data["ProjectFinish"] = this.ProjectFinish ? this.ProjectFinish.toISOString() : <any>undefined;
        data["CurrentContract"] = this.CurrentContract;
        data["IsChild"] = this.IsChild;
        return data; 
    }

    clone(): ProjectLink {
        const json = this.toJSON();
        let result = new ProjectLink();
        result.init(json);
        return result;
    }
}

/** Attributes describing a Link to a parent or child  project */
export interface IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey: string;
    /** Key for document that owns the link */
    DocMasterKey?: string | undefined;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish: Date;
    /** EAC Contract Value  */
    CurrentContract: number;
    /** When True, this is a child project */
    IsChild: boolean;
}

/** Primary Site Weather Now */
export class ProjectWeatherNow implements IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer!: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint!: number;
    /** Feels Like */
    FeelsLike!: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity!: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained!: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature!: number;
    /** Visibility (miles) */
    Visibility!: number;
    /** Wind (MPH) */
    Wind!: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    ZipCode?: string | undefined;

    constructor(data?: IProjectWeatherNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.At = _data["At"];
            this.Barometer = _data["Barometer"];
            this.Condition = _data["Condition"];
            this.DewPoint = _data["DewPoint"];
            this.FeelsLike = _data["FeelsLike"];
            this.Forecast = _data["Forecast"];
            this.Humidity = _data["Humidity"];
            this.Icon = _data["Icon"];
            this.Obtained = _data["Obtained"] ? new Date(_data["Obtained"].toString()) : <any>undefined;
            this.Provider = _data["Provider"];
            this.Reported = _data["Reported"];
            this.Temperature = _data["Temperature"];
            this.Visibility = _data["Visibility"];
            this.Wind = _data["Wind"];
            this.WindInfo = _data["WindInfo"];
            this.ZipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): ProjectWeatherNow {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWeatherNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["At"] = this.At;
        data["Barometer"] = this.Barometer;
        data["Condition"] = this.Condition;
        data["DewPoint"] = this.DewPoint;
        data["FeelsLike"] = this.FeelsLike;
        data["Forecast"] = this.Forecast;
        data["Humidity"] = this.Humidity;
        data["Icon"] = this.Icon;
        data["Obtained"] = this.Obtained ? this.Obtained.toISOString() : <any>undefined;
        data["Provider"] = this.Provider;
        data["Reported"] = this.Reported;
        data["Temperature"] = this.Temperature;
        data["Visibility"] = this.Visibility;
        data["Wind"] = this.Wind;
        data["WindInfo"] = this.WindInfo;
        data["ZipCode"] = this.ZipCode;
        return data; 
    }

    clone(): ProjectWeatherNow {
        const json = this.toJSON();
        let result = new ProjectWeatherNow();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint: number;
    /** Feels Like */
    FeelsLike: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature: number;
    /** Visibility (miles) */
    Visibility: number;
    /** Wind (MPH) */
    Wind: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    ZipCode?: string | undefined;
}

/** Primary Site Weather Now */
export class WeatherAtLocation implements IWeatherAtLocation {
    /** Location (typically zipcode) */
    LocationCode!: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey!: string;
    /** Key of this location */
    WeatherLocationKey!: string;
    /** When this reading was acquired */
    Reported!: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility!: number;
    /** Temperature (F) */
    Temperature!: number;
    /** Feels like (F) */
    FeelsLike!: number;
    /** Dewpoint (F) */
    Dewpoint!: number;
    /** Relative Humidity */
    HumidityPct!: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind!: number;
    /** Barametric Pressure */
    Barometer!: number;

    constructor(data?: IWeatherAtLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.LocationCode = _data["LocationCode"];
            this.Location = _data["Location"];
            this.RecordedAt = _data["RecordedAt"];
            this.Provider = _data["Provider"];
            this.WeatherInfoKey = _data["WeatherInfoKey"];
            this.WeatherLocationKey = _data["WeatherLocationKey"];
            this.Reported = _data["Reported"] ? new Date(_data["Reported"].toString()) : <any>undefined;
            this.Conditions = _data["Conditions"];
            this.Visibility = _data["Visibility"];
            this.Temperature = _data["Temperature"];
            this.FeelsLike = _data["FeelsLike"];
            this.Dewpoint = _data["Dewpoint"];
            this.HumidityPct = _data["HumidityPct"];
            this.WindDirection = _data["WindDirection"];
            this.Wind = _data["Wind"];
            this.Barometer = _data["Barometer"];
        }
    }

    static fromJS(data: any): WeatherAtLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAtLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocationCode"] = this.LocationCode;
        data["Location"] = this.Location;
        data["RecordedAt"] = this.RecordedAt;
        data["Provider"] = this.Provider;
        data["WeatherInfoKey"] = this.WeatherInfoKey;
        data["WeatherLocationKey"] = this.WeatherLocationKey;
        data["Reported"] = this.Reported ? this.Reported.toISOString() : <any>undefined;
        data["Conditions"] = this.Conditions;
        data["Visibility"] = this.Visibility;
        data["Temperature"] = this.Temperature;
        data["FeelsLike"] = this.FeelsLike;
        data["Dewpoint"] = this.Dewpoint;
        data["HumidityPct"] = this.HumidityPct;
        data["WindDirection"] = this.WindDirection;
        data["Wind"] = this.Wind;
        data["Barometer"] = this.Barometer;
        return data; 
    }

    clone(): WeatherAtLocation {
        const json = this.toJSON();
        let result = new WeatherAtLocation();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IWeatherAtLocation {
    /** Location (typically zipcode) */
    LocationCode: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey: string;
    /** Key of this location */
    WeatherLocationKey: string;
    /** When this reading was acquired */
    Reported: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility: number;
    /** Temperature (F) */
    Temperature: number;
    /** Feels like (F) */
    FeelsLike: number;
    /** Dewpoint (F) */
    Dewpoint: number;
    /** Relative Humidity */
    HumidityPct: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind: number;
    /** Barametric Pressure */
    Barometer: number;
}

/** Comment about a topic */
export class Comment implements IComment {
    /** Key for this comment */
    DocCommentKey!: string;
    /** Key for the topic relating a group of comments */
    TopicKey!: string;
    /** Key for the author of this comment */
    FromUser!: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost!: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage!: number;
    /** When this comment was created (editable given sufficient permission) */
    Created!: Date;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocCommentKey = _data["DocCommentKey"];
            this.TopicKey = _data["TopicKey"];
            this.FromUser = _data["FromUser"];
            this.Note = _data["Note"];
            this.Cost = _data["Cost"];
            this.Stage = _data["Stage"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.DocCommentKey;
        data["TopicKey"] = this.TopicKey;
        data["FromUser"] = this.FromUser;
        data["Note"] = this.Note;
        data["Cost"] = this.Cost;
        data["Stage"] = this.Stage;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Comment {
        const json = this.toJSON();
        let result = new Comment();
        result.init(json);
        return result;
    }
}

/** Comment about a topic */
export interface IComment {
    /** Key for this comment */
    DocCommentKey: string;
    /** Key for the topic relating a group of comments */
    TopicKey: string;
    /** Key for the author of this comment */
    FromUser: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage: number;
    /** When this comment was created (editable given sufficient permission) */
    Created: Date;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Readonly description of an cost transaction posted to a project */
export class ProjectTranDetail implements IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey!: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount!: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime!: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num!: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime!: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date!: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date!: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units!: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line!: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS!: boolean;
    /** Identifies a Document */
    DocMasterKey!: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;

    constructor(data?: IProjectTranDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.acct = _data["acct"];
            this.alloc_flag = _data["alloc_flag"];
            this.amount = _data["amount"];
            this.BaseCuryId = _data["BaseCuryId"];
            this.batch_id = _data["batch_id"];
            this.batch_type = _data["batch_type"];
            this.bill_batch_id = _data["bill_batch_id"];
            this.CpnyId = _data["CpnyId"];
            this.crtd_datetime = _data["crtd_datetime"] ? new Date(_data["crtd_datetime"].toString()) : <any>undefined;
            this.crtd_prog = _data["crtd_prog"];
            this.crtd_user = _data["crtd_user"];
            this.data1 = _data["data1"];
            this.detail_num = _data["detail_num"];
            this.employee = _data["employee"];
            this.fiscalno = _data["fiscalno"];
            this.gl_acct = _data["gl_acct"];
            this.gl_subacct = _data["gl_subacct"];
            this.lupd_datetime = _data["lupd_datetime"] ? new Date(_data["lupd_datetime"].toString()) : <any>undefined;
            this.lupd_prog = _data["lupd_prog"];
            this.lupd_user = _data["lupd_user"];
            this.pjt_entity = _data["pjt_entity"];
            this.post_date = _data["post_date"] ? new Date(_data["post_date"].toString()) : <any>undefined;
            this.project = _data["project"];
            this.Subcontract = _data["Subcontract"];
            this.system_cd = _data["system_cd"];
            this.trans_date = _data["trans_date"] ? new Date(_data["trans_date"].toString()) : <any>undefined;
            this.tr_comment = _data["tr_comment"];
            this.tr_id01 = _data["tr_id01"];
            this.InvoiceNumber = _data["InvoiceNumber"];
            this.PONumber = _data["PONumber"];
            this.SourceBatchNumber = _data["SourceBatchNumber"];
            this.LaborClass = _data["LaborClass"];
            this.tr_status = _data["tr_status"];
            this.unit_of_measure = _data["unit_of_measure"];
            this.units = _data["units"];
            this.vendor_num = _data["vendor_num"];
            this.voucher_line = _data["voucher_line"];
            this.voucher_num = _data["voucher_num"];
            this.emp_name = _data["emp_name"];
            this.name = _data["name"];
            this.equip_id = _data["equip_id"];
            this.invtid = _data["invtid"];
            this.lotsernbr = _data["lotsernbr"];
            this.siteid = _data["siteid"];
            this.whseloc = _data["whseloc"];
            this.Descr = _data["Descr"];
            this.IsXTS = _data["IsXTS"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTitle = _data["DocTitle"];
            this.Acct_Type = _data["Acct_Type"];
            this.Acct_TranClass = _data["Acct_TranClass"];
            this.Acct_Class = _data["Acct_Class"];
        }
    }

    static fromJS(data: any): ProjectTranDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTranDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["acct"] = this.acct;
        data["alloc_flag"] = this.alloc_flag;
        data["amount"] = this.amount;
        data["BaseCuryId"] = this.BaseCuryId;
        data["batch_id"] = this.batch_id;
        data["batch_type"] = this.batch_type;
        data["bill_batch_id"] = this.bill_batch_id;
        data["CpnyId"] = this.CpnyId;
        data["crtd_datetime"] = this.crtd_datetime ? this.crtd_datetime.toISOString() : <any>undefined;
        data["crtd_prog"] = this.crtd_prog;
        data["crtd_user"] = this.crtd_user;
        data["data1"] = this.data1;
        data["detail_num"] = this.detail_num;
        data["employee"] = this.employee;
        data["fiscalno"] = this.fiscalno;
        data["gl_acct"] = this.gl_acct;
        data["gl_subacct"] = this.gl_subacct;
        data["lupd_datetime"] = this.lupd_datetime ? this.lupd_datetime.toISOString() : <any>undefined;
        data["lupd_prog"] = this.lupd_prog;
        data["lupd_user"] = this.lupd_user;
        data["pjt_entity"] = this.pjt_entity;
        data["post_date"] = this.post_date ? this.post_date.toISOString() : <any>undefined;
        data["project"] = this.project;
        data["Subcontract"] = this.Subcontract;
        data["system_cd"] = this.system_cd;
        data["trans_date"] = this.trans_date ? this.trans_date.toISOString() : <any>undefined;
        data["tr_comment"] = this.tr_comment;
        data["tr_id01"] = this.tr_id01;
        data["InvoiceNumber"] = this.InvoiceNumber;
        data["PONumber"] = this.PONumber;
        data["SourceBatchNumber"] = this.SourceBatchNumber;
        data["LaborClass"] = this.LaborClass;
        data["tr_status"] = this.tr_status;
        data["unit_of_measure"] = this.unit_of_measure;
        data["units"] = this.units;
        data["vendor_num"] = this.vendor_num;
        data["voucher_line"] = this.voucher_line;
        data["voucher_num"] = this.voucher_num;
        data["emp_name"] = this.emp_name;
        data["name"] = this.name;
        data["equip_id"] = this.equip_id;
        data["invtid"] = this.invtid;
        data["lotsernbr"] = this.lotsernbr;
        data["siteid"] = this.siteid;
        data["whseloc"] = this.whseloc;
        data["Descr"] = this.Descr;
        data["IsXTS"] = this.IsXTS;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTitle"] = this.DocTitle;
        data["Acct_Type"] = this.Acct_Type;
        data["Acct_TranClass"] = this.Acct_TranClass;
        data["Acct_Class"] = this.Acct_Class;
        return data; 
    }

    clone(): ProjectTranDetail {
        const json = this.toJSON();
        let result = new ProjectTranDetail();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS: boolean;
    /** Identifies a Document */
    DocMasterKey: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;
}

/** Permission required flag -- bit flags can be combined */
export enum PermissionFlags {
    None = 0,
    Read = 1,
    Insert = 2,
    Update = 4,
    Delete = 8,
    Blanket = 16,
}

/** Defines a payload intended for retrieval using a token */
export class TokenRequest implements ITokenRequest {
    /** Key for User for whom the alert was generated */
    UserKey!: string;
    /** Name of User  */
    FullName?: string | undefined;
    /** Max Idle time allowed in minutes */
    IdleForce!: number;
    /** Icon Height (for classic UI)   */
    IconHeight!: number;
    /** Key for Operation */
    DataPK?: string | undefined;
    /** Key for Document Session */
    DocSessionKey?: string | undefined;
    /** Key for User Session */
    LoginSessionKey!: string;
    /** Key for Site  */
    SiteID!: string;
    /** Context ID String */
    dsCacheKey?: string | undefined;
    /** Page Name  */
    PageName?: string | undefined;
    /** Part Name  */
    PartName?: string | undefined;
    /** Magic number. When changes, UI settings have changed */
    uiVaryBy!: number;
    /** Indicates if user holds exclusive access  */
    DataLockFlag?: string | undefined;
    /** When true, this user has opted out of Analytic data collection */
    GAFMOptOut!: boolean;
    /** Time offset in hours */
    TZOffset!: number;
    /** Payload  */
    Args?: string | undefined;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.FullName = _data["FullName"];
            this.IdleForce = _data["IdleForce"];
            this.IconHeight = _data["IconHeight"];
            this.DataPK = _data["DataPK"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.LoginSessionKey = _data["LoginSessionKey"];
            this.SiteID = _data["SiteID"];
            this.dsCacheKey = _data["dsCacheKey"];
            this.PageName = _data["PageName"];
            this.PartName = _data["PartName"];
            this.uiVaryBy = _data["uiVaryBy"];
            this.DataLockFlag = _data["DataLockFlag"];
            this.GAFMOptOut = _data["GAFMOptOut"];
            this.TZOffset = _data["TZOffset"];
            this.Args = _data["Args"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["FullName"] = this.FullName;
        data["IdleForce"] = this.IdleForce;
        data["IconHeight"] = this.IconHeight;
        data["DataPK"] = this.DataPK;
        data["DocSessionKey"] = this.DocSessionKey;
        data["LoginSessionKey"] = this.LoginSessionKey;
        data["SiteID"] = this.SiteID;
        data["dsCacheKey"] = this.dsCacheKey;
        data["PageName"] = this.PageName;
        data["PartName"] = this.PartName;
        data["uiVaryBy"] = this.uiVaryBy;
        data["DataLockFlag"] = this.DataLockFlag;
        data["GAFMOptOut"] = this.GAFMOptOut;
        data["TZOffset"] = this.TZOffset;
        data["Args"] = this.Args;
        return data; 
    }

    clone(): TokenRequest {
        const json = this.toJSON();
        let result = new TokenRequest();
        result.init(json);
        return result;
    }
}

/** Defines a payload intended for retrieval using a token */
export interface ITokenRequest {
    /** Key for User for whom the alert was generated */
    UserKey: string;
    /** Name of User  */
    FullName?: string | undefined;
    /** Max Idle time allowed in minutes */
    IdleForce: number;
    /** Icon Height (for classic UI)   */
    IconHeight: number;
    /** Key for Operation */
    DataPK?: string | undefined;
    /** Key for Document Session */
    DocSessionKey?: string | undefined;
    /** Key for User Session */
    LoginSessionKey: string;
    /** Key for Site  */
    SiteID: string;
    /** Context ID String */
    dsCacheKey?: string | undefined;
    /** Page Name  */
    PageName?: string | undefined;
    /** Part Name  */
    PartName?: string | undefined;
    /** Magic number. When changes, UI settings have changed */
    uiVaryBy: number;
    /** Indicates if user holds exclusive access  */
    DataLockFlag?: string | undefined;
    /** When true, this user has opted out of Analytic data collection */
    GAFMOptOut: boolean;
    /** Time offset in hours */
    TZOffset: number;
    /** Payload  */
    Args?: string | undefined;
}

export class AuthenticationExchangeData implements IAuthenticationExchangeData {
    XID?: string | undefined;
    IsValid!: boolean;
    GAFMOptOut!: boolean;
    IdleForce!: number;
    iconHeight!: number;
    uiVaryBy!: number;
    SessionID?: string | undefined;
    AuthData?: string | undefined;
    Args?: string | undefined;
    FullName?: string | undefined;
    UserKey?: string | undefined;
    DataPK?: string | undefined;
    dsCacheKey?: string | undefined;
    PageName?: string | undefined;
    PartName?: string | undefined;
    DocSessionKey?: string | undefined;
    DataLockFlag?: string | undefined;
    LoginSessionKey?: string | undefined;
    TZOffset!: number;
    SiteID?: string | undefined;

    constructor(data?: IAuthenticationExchangeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.XID = _data["XID"];
            this.IsValid = _data["IsValid"];
            this.GAFMOptOut = _data["GAFMOptOut"];
            this.IdleForce = _data["IdleForce"];
            this.iconHeight = _data["iconHeight"];
            this.uiVaryBy = _data["uiVaryBy"];
            this.SessionID = _data["SessionID"];
            this.AuthData = _data["AuthData"];
            this.Args = _data["Args"];
            this.FullName = _data["FullName"];
            this.UserKey = _data["UserKey"];
            this.DataPK = _data["DataPK"];
            this.dsCacheKey = _data["dsCacheKey"];
            this.PageName = _data["PageName"];
            this.PartName = _data["PartName"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.DataLockFlag = _data["DataLockFlag"];
            this.LoginSessionKey = _data["LoginSessionKey"];
            this.TZOffset = _data["TZOffset"];
            this.SiteID = _data["SiteID"];
        }
    }

    static fromJS(data: any): AuthenticationExchangeData {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationExchangeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["XID"] = this.XID;
        data["IsValid"] = this.IsValid;
        data["GAFMOptOut"] = this.GAFMOptOut;
        data["IdleForce"] = this.IdleForce;
        data["iconHeight"] = this.iconHeight;
        data["uiVaryBy"] = this.uiVaryBy;
        data["SessionID"] = this.SessionID;
        data["AuthData"] = this.AuthData;
        data["Args"] = this.Args;
        data["FullName"] = this.FullName;
        data["UserKey"] = this.UserKey;
        data["DataPK"] = this.DataPK;
        data["dsCacheKey"] = this.dsCacheKey;
        data["PageName"] = this.PageName;
        data["PartName"] = this.PartName;
        data["DocSessionKey"] = this.DocSessionKey;
        data["DataLockFlag"] = this.DataLockFlag;
        data["LoginSessionKey"] = this.LoginSessionKey;
        data["TZOffset"] = this.TZOffset;
        data["SiteID"] = this.SiteID;
        return data; 
    }

    clone(): AuthenticationExchangeData {
        const json = this.toJSON();
        let result = new AuthenticationExchangeData();
        result.init(json);
        return result;
    }
}

export interface IAuthenticationExchangeData {
    XID?: string | undefined;
    IsValid: boolean;
    GAFMOptOut: boolean;
    IdleForce: number;
    iconHeight: number;
    uiVaryBy: number;
    SessionID?: string | undefined;
    AuthData?: string | undefined;
    Args?: string | undefined;
    FullName?: string | undefined;
    UserKey?: string | undefined;
    DataPK?: string | undefined;
    dsCacheKey?: string | undefined;
    PageName?: string | undefined;
    PartName?: string | undefined;
    DocSessionKey?: string | undefined;
    DataLockFlag?: string | undefined;
    LoginSessionKey?: string | undefined;
    TZOffset: number;
    SiteID?: string | undefined;
}

/** Describes a set of permissions for this user */
export class UCPermitSet implements IUCPermitSet {
    /** Key of this item */
    Project!: string;
    /** Links to Module|Function  */
    Permits!: { [key: string]: UCPermit[]; };

    constructor(data?: IUCPermitSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.Permits = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            if (_data["Permits"]) {
                this.Permits = {} as any;
                for (let key in _data["Permits"]) {
                    if (_data["Permits"].hasOwnProperty(key))
                        (<any>this.Permits)![key] = _data["Permits"][key] ? _data["Permits"][key].map((i: any) => UCPermit.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): UCPermitSet {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermitSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        if (this.Permits) {
            data["Permits"] = {};
            for (let key in this.Permits) {
                if (this.Permits.hasOwnProperty(key))
                    (<any>data["Permits"])[key] = this.Permits[key];
            }
        }
        return data; 
    }

    clone(): UCPermitSet {
        const json = this.toJSON();
        let result = new UCPermitSet();
        result.init(json);
        return result;
    }
}

/** Describes a set of permissions for this user */
export interface IUCPermitSet {
    /** Key of this item */
    Project: string;
    /** Links to Module|Function  */
    Permits: { [key: string]: UCPermit[]; };
}

/** Permissions for a specific function */
export class UCPermit implements IUCPermit {
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** When true, has read permission */
    ReadOK!: boolean;
    /** When true, has read permission */
    InsOK!: boolean;
    /** When true, has read permission */
    UpdOK!: boolean;
    /** When true, has read permission */
    DelOK!: boolean;
    /** When true, has read permission */
    BlanketOK!: boolean;
    /** When true, there is no restriction on this permission */
    IsGlobal!: boolean;

    constructor(data?: IUCPermit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocReference = _data["DocReference"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.ReadOK = _data["ReadOK"];
            this.InsOK = _data["InsOK"];
            this.UpdOK = _data["UpdOK"];
            this.DelOK = _data["DelOK"];
            this.BlanketOK = _data["BlanketOK"];
            this.IsGlobal = _data["IsGlobal"];
        }
    }

    static fromJS(data: any): UCPermit {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocReference"] = this.DocReference;
        data["DocTypeKey"] = this.DocTypeKey;
        data["ReadOK"] = this.ReadOK;
        data["InsOK"] = this.InsOK;
        data["UpdOK"] = this.UpdOK;
        data["DelOK"] = this.DelOK;
        data["BlanketOK"] = this.BlanketOK;
        data["IsGlobal"] = this.IsGlobal;
        return data; 
    }

    clone(): UCPermit {
        const json = this.toJSON();
        let result = new UCPermit();
        result.init(json);
        return result;
    }
}

/** Permissions for a specific function */
export interface IUCPermit {
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** When true, has read permission */
    ReadOK: boolean;
    /** When true, has read permission */
    InsOK: boolean;
    /** When true, has read permission */
    UpdOK: boolean;
    /** When true, has read permission */
    DelOK: boolean;
    /** When true, has read permission */
    BlanketOK: boolean;
    /** When true, there is no restriction on this permission */
    IsGlobal: boolean;
}

export class TabStripDetails implements ITabStripDetails {
    TabId!: number;
    TabKey?: string | undefined;
    TabText?: string | undefined;
    TabOrder!: number;
    TabType?: string | undefined;
    AuthorizedRoles?: string | undefined;
    LinkURL?: string | undefined;
    Tip?: string | undefined;
    IsVisible!: boolean;

    constructor(data?: ITabStripDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.TabId = _data["TabId"];
            this.TabKey = _data["TabKey"];
            this.TabText = _data["TabText"];
            this.TabOrder = _data["TabOrder"];
            this.TabType = _data["TabType"];
            this.AuthorizedRoles = _data["AuthorizedRoles"];
            this.LinkURL = _data["LinkURL"];
            this.Tip = _data["Tip"];
            this.IsVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): TabStripDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TabStripDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TabId"] = this.TabId;
        data["TabKey"] = this.TabKey;
        data["TabText"] = this.TabText;
        data["TabOrder"] = this.TabOrder;
        data["TabType"] = this.TabType;
        data["AuthorizedRoles"] = this.AuthorizedRoles;
        data["LinkURL"] = this.LinkURL;
        data["Tip"] = this.Tip;
        data["IsVisible"] = this.IsVisible;
        return data; 
    }

    clone(): TabStripDetails {
        const json = this.toJSON();
        let result = new TabStripDetails();
        result.init(json);
        return result;
    }
}

export interface ITabStripDetails {
    TabId: number;
    TabKey?: string | undefined;
    TabText?: string | undefined;
    TabOrder: number;
    TabType?: string | undefined;
    AuthorizedRoles?: string | undefined;
    LinkURL?: string | undefined;
    Tip?: string | undefined;
    IsVisible: boolean;
}

/** Legacy Site Authentication */
export class TabDisplay implements ITabDisplay {
    /** Primary display of tab */
    Label?: string | undefined;
    /** Mouseover display (mostly for classic UI) */
    Tip?: string | undefined;

    constructor(data?: ITabDisplay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Label = _data["Label"];
            this.Tip = _data["Tip"];
        }
    }

    static fromJS(data: any): TabDisplay {
        data = typeof data === 'object' ? data : {};
        let result = new TabDisplay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Label"] = this.Label;
        data["Tip"] = this.Tip;
        return data; 
    }

    clone(): TabDisplay {
        const json = this.toJSON();
        let result = new TabDisplay();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ITabDisplay {
    /** Primary display of tab */
    Label?: string | undefined;
    /** Mouseover display (mostly for classic UI) */
    Tip?: string | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UpgradeRequired = 426,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
}

/** Passes data to a simple API */
export class APIData implements IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded!: boolean;

    constructor(data?: IAPIData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Data = _data["Data"];
            this.IsURIEncoded = _data["IsURIEncoded"];
        }
    }

    static fromJS(data: any): APIData {
        data = typeof data === 'object' ? data : {};
        let result = new APIData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.Data;
        data["IsURIEncoded"] = this.IsURIEncoded;
        return data; 
    }

    clone(): APIData {
        const json = this.toJSON();
        let result = new APIData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded: boolean;
}

/** Passes data to a simple API */
export class PDSData extends APIData implements IPDSData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly!: boolean;

    constructor(data?: IPDSData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.PDSKey = _data["PDSKey"];
            this.Mode = _data["Mode"];
            this.Path = _data["Path"];
            this.Type = _data["Type"];
            this.UpdateReadOnly = _data["UpdateReadOnly"];
        }
    }

    static fromJS(data: any): PDSData {
        data = typeof data === 'object' ? data : {};
        let result = new PDSData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PDSKey"] = this.PDSKey;
        data["Mode"] = this.Mode;
        data["Path"] = this.Path;
        data["Type"] = this.Type;
        data["UpdateReadOnly"] = this.UpdateReadOnly;
        super.toJSON(data);
        return data; 
    }

    clone(): PDSData {
        const json = this.toJSON();
        let result = new PDSData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IPDSData extends IAPIData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly: boolean;
}

/** Describes an Docr Condition */
export class DocAddress implements IDocAddress {
    /** Key for record */
    DocAddrKey!: string;
    /** To or From */
    AddrType?: string | undefined;
    /** User/Contact(Customer, Vendor), or Manual */
    SourceType?: string | undefined;
    /** When TRUE the corresponding AddrType from the Project Setup is copied here and becomes read only */
    UseSource!: boolean;
    /** Link to user/contact */
    UserKey!: string;
    /** Free form, typically a name */
    Person?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    Addr1?: string | undefined;
    /** Second line of address */
    Addr2?: string | undefined;
    /** City (for address) */
    City?: string | undefined;
    /** For Address */
    State?: string | undefined;
    /** Zipcode for address */
    Zip?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    Phone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Freeform and Informational. Intended for External contacts project reference */
    ContactProject?: string | undefined;
    /** Descriptive name */
    RoleName?: string | undefined;
    /** Short description */
    Title?: string | undefined;

    constructor(data?: IDocAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAddrKey = _data["DocAddrKey"];
            this.AddrType = _data["AddrType"];
            this.SourceType = _data["SourceType"];
            this.UseSource = _data["UseSource"];
            this.UserKey = _data["UserKey"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.Phone = _data["Phone"];
            this.Fax = _data["Fax"];
            this.Email = _data["Email"];
            this.ContactProject = _data["ContactProject"];
            this.RoleName = _data["RoleName"];
            this.Title = _data["Title"];
        }
    }

    static fromJS(data: any): DocAddress {
        data = typeof data === 'object' ? data : {};
        let result = new DocAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAddrKey"] = this.DocAddrKey;
        data["AddrType"] = this.AddrType;
        data["SourceType"] = this.SourceType;
        data["UseSource"] = this.UseSource;
        data["UserKey"] = this.UserKey;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["Phone"] = this.Phone;
        data["Fax"] = this.Fax;
        data["Email"] = this.Email;
        data["ContactProject"] = this.ContactProject;
        data["RoleName"] = this.RoleName;
        data["Title"] = this.Title;
        return data; 
    }

    clone(): DocAddress {
        const json = this.toJSON();
        let result = new DocAddress();
        result.init(json);
        return result;
    }
}

/** Describes an Docr Condition */
export interface IDocAddress {
    /** Key for record */
    DocAddrKey: string;
    /** To or From */
    AddrType?: string | undefined;
    /** User/Contact(Customer, Vendor), or Manual */
    SourceType?: string | undefined;
    /** When TRUE the corresponding AddrType from the Project Setup is copied here and becomes read only */
    UseSource: boolean;
    /** Link to user/contact */
    UserKey: string;
    /** Free form, typically a name */
    Person?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    Addr1?: string | undefined;
    /** Second line of address */
    Addr2?: string | undefined;
    /** City (for address) */
    City?: string | undefined;
    /** For Address */
    State?: string | undefined;
    /** Zipcode for address */
    Zip?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    Phone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Freeform and Informational. Intended for External contacts project reference */
    ContactProject?: string | undefined;
    /** Descriptive name */
    RoleName?: string | undefined;
    /** Short description */
    Title?: string | undefined;
}

/** Describes an DocAttachedFile Condition */
export class DocAttachment implements IDocAttachment {
    /** Key of this attachment */
    DocAttachKey!: string;
    /** Optional: Key for attached file */
    DocKey!: string;
    /** Optional: references another routed document */
    AttachedDocMaster!: string;
    /** Weak Link to an item */
    LinkedItemKey!: string;
    /** Resolved to item number of key  */
    AttachedItemNumber?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Links to a user/contact  */
    FromUser!: string;
    /** Indicates route that attached this to the document */
    FromRouteID!: string;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    /** Current Revision Number when attached */
    AttachedRevID!: number;
    /** View or Update */
    AccessLevel?: string | undefined;
    /** Indicates how this attachment is sent to non-web route parties, eg: 0=never;1=always;M=Assembled;P=PDF (see code set!) */
    MailRoute?: string | undefined;
    /** Controls order of attachments in merges and emails, etc */
    AttachSeq!: number;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference!: string;
    /** Category (Scanned Invoice;Site Photo) */
    CatType!: string;
    /** Status code */
    Status?: string | undefined;
    /** Resolves to cost impact carried by the attachment */
    CostImpact!: number;
    /** Resolves to responsible name of the attachment */
    ResponsibleName?: string | undefined;
    /** Code for Relationship type of attachment */
    RelationshipType?: string | undefined;
    /** Indicates the "folder" where the resource resides */
    ContainerKey!: string;
    /** free form; Text Indexed */
    FileName?: string | undefined;
    /** Free form; text indexed */
    keyword?: string | undefined;
    /** Free format keywords */
    Other?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** Optional; Text Indexed */
    SourceBatchNo?: string | undefined;
    /** Date of source attachment */
    ReferenceDate!: Date;
    /** TIF/DOC/JPG etc */
    FileType?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** link to contact/user; the source  */
    SourceContact!: string;
    /** Approved Revision ID  */
    ApprRevID!: number;
    /** Most recent Revision ID  */
    LastRevID!: number;
    /** External reference */
    SourceRevision?: string | undefined;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** Date and time cataloged  */
    Cataloged!: Date;
    /** Size of native binary data, regardless of current Data storage Method */
    BinSize!: number;
    /** Internal document, output of a routed document */
    sfGenerated!: boolean;
    /** If sfGenerated and current document is ByDocMaster and this field is true, bookmarks are refreshed */
    RefreshBookmarks!: boolean;
    /** When True, e-signature tabs have been detected */
    HasSignTabs!: boolean;
    /** When true, access is strictly restricted */
    Confidential!: boolean;
    /** When true, this attachment is a mirror of the attachment on the other doc */
    IsInherited!: boolean;
    /** When TRUE (default), file is elligible for cloud sync */
    CloudSync!: boolean;
    /** When true, inbound changes are blocked */
    CloudBlockIn!: boolean;
    /** When true, outbound changes are blocked */
    CloudBlockOut!: boolean;
    LastSyncDir?: string | undefined;
    LastSync!: Date;
    /** Key of XTS mapping */
    TDKeyMapKey!: string;
    DocLinks!: number;
    RCLinks!: number;
    /** Key of user that has this attachment checked out */
    CheckOutUser!: string;
    /** Code of current check out status (O==Out; L==Locked, etc) */
    CheckOutStatus?: string | undefined;
    /** When checked out */
    CheckedOut!: Date;
    /** When checked in */
    CheckedIn!: Date;
    /** When checked out will expire on its own */
    Expires!: Date;

    constructor(data?: IDocAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttachKey = _data["DocAttachKey"];
            this.DocKey = _data["DocKey"];
            this.AttachedDocMaster = _data["AttachedDocMaster"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.AttachedItemNumber = _data["AttachedItemNumber"];
            this.Note = _data["Note"];
            this.FromUser = _data["FromUser"];
            this.FromRouteID = _data["FromRouteID"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.AttachedRevID = _data["AttachedRevID"];
            this.AccessLevel = _data["AccessLevel"];
            this.MailRoute = _data["MailRoute"];
            this.AttachSeq = _data["AttachSeq"];
            this.DocReference = _data["DocReference"];
            this.CatType = _data["CatType"];
            this.Status = _data["Status"];
            this.CostImpact = _data["CostImpact"];
            this.ResponsibleName = _data["ResponsibleName"];
            this.RelationshipType = _data["RelationshipType"];
            this.ContainerKey = _data["ContainerKey"];
            this.FileName = _data["FileName"];
            this.keyword = _data["keyword"];
            this.Other = _data["Other"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.SourceBatchNo = _data["SourceBatchNo"];
            this.ReferenceDate = _data["ReferenceDate"] ? new Date(_data["ReferenceDate"].toString()) : <any>undefined;
            this.FileType = _data["FileType"];
            this.Project = _data["Project"];
            this.DivisionID = _data["DivisionID"];
            this.SourceContact = _data["SourceContact"];
            this.ApprRevID = _data["ApprRevID"];
            this.LastRevID = _data["LastRevID"];
            this.SourceRevision = _data["SourceRevision"];
            this.DataHash = _data["DataHash"];
            this.Cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.BinSize = _data["BinSize"];
            this.sfGenerated = _data["sfGenerated"];
            this.RefreshBookmarks = _data["RefreshBookmarks"];
            this.HasSignTabs = _data["HasSignTabs"];
            this.Confidential = _data["Confidential"];
            this.IsInherited = _data["IsInherited"];
            this.CloudSync = _data["CloudSync"];
            this.CloudBlockIn = _data["CloudBlockIn"];
            this.CloudBlockOut = _data["CloudBlockOut"];
            this.LastSyncDir = _data["LastSyncDir"];
            this.LastSync = _data["LastSync"] ? new Date(_data["LastSync"].toString()) : <any>undefined;
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.DocLinks = _data["DocLinks"];
            this.RCLinks = _data["RCLinks"];
            this.CheckOutUser = _data["CheckOutUser"];
            this.CheckOutStatus = _data["CheckOutStatus"];
            this.CheckedOut = _data["CheckedOut"] ? new Date(_data["CheckedOut"].toString()) : <any>undefined;
            this.CheckedIn = _data["CheckedIn"] ? new Date(_data["CheckedIn"].toString()) : <any>undefined;
            this.Expires = _data["Expires"] ? new Date(_data["Expires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new DocAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.DocAttachKey;
        data["DocKey"] = this.DocKey;
        data["AttachedDocMaster"] = this.AttachedDocMaster;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["AttachedItemNumber"] = this.AttachedItemNumber;
        data["Note"] = this.Note;
        data["FromUser"] = this.FromUser;
        data["FromRouteID"] = this.FromRouteID;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["AttachedRevID"] = this.AttachedRevID;
        data["AccessLevel"] = this.AccessLevel;
        data["MailRoute"] = this.MailRoute;
        data["AttachSeq"] = this.AttachSeq;
        data["DocReference"] = this.DocReference;
        data["CatType"] = this.CatType;
        data["Status"] = this.Status;
        data["CostImpact"] = this.CostImpact;
        data["ResponsibleName"] = this.ResponsibleName;
        data["RelationshipType"] = this.RelationshipType;
        data["ContainerKey"] = this.ContainerKey;
        data["FileName"] = this.FileName;
        data["keyword"] = this.keyword;
        data["Other"] = this.Other;
        data["SourceDocNo"] = this.SourceDocNo;
        data["SourceBatchNo"] = this.SourceBatchNo;
        data["ReferenceDate"] = this.ReferenceDate ? this.ReferenceDate.toISOString() : <any>undefined;
        data["FileType"] = this.FileType;
        data["Project"] = this.Project;
        data["DivisionID"] = this.DivisionID;
        data["SourceContact"] = this.SourceContact;
        data["ApprRevID"] = this.ApprRevID;
        data["LastRevID"] = this.LastRevID;
        data["SourceRevision"] = this.SourceRevision;
        data["DataHash"] = this.DataHash;
        data["Cataloged"] = this.Cataloged ? this.Cataloged.toISOString() : <any>undefined;
        data["BinSize"] = this.BinSize;
        data["sfGenerated"] = this.sfGenerated;
        data["RefreshBookmarks"] = this.RefreshBookmarks;
        data["HasSignTabs"] = this.HasSignTabs;
        data["Confidential"] = this.Confidential;
        data["IsInherited"] = this.IsInherited;
        data["CloudSync"] = this.CloudSync;
        data["CloudBlockIn"] = this.CloudBlockIn;
        data["CloudBlockOut"] = this.CloudBlockOut;
        data["LastSyncDir"] = this.LastSyncDir;
        data["LastSync"] = this.LastSync ? this.LastSync.toISOString() : <any>undefined;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["DocLinks"] = this.DocLinks;
        data["RCLinks"] = this.RCLinks;
        data["CheckOutUser"] = this.CheckOutUser;
        data["CheckOutStatus"] = this.CheckOutStatus;
        data["CheckedOut"] = this.CheckedOut ? this.CheckedOut.toISOString() : <any>undefined;
        data["CheckedIn"] = this.CheckedIn ? this.CheckedIn.toISOString() : <any>undefined;
        data["Expires"] = this.Expires ? this.Expires.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocAttachment {
        const json = this.toJSON();
        let result = new DocAttachment();
        result.init(json);
        return result;
    }
}

/** Describes an DocAttachedFile Condition */
export interface IDocAttachment {
    /** Key of this attachment */
    DocAttachKey: string;
    /** Optional: Key for attached file */
    DocKey: string;
    /** Optional: references another routed document */
    AttachedDocMaster: string;
    /** Weak Link to an item */
    LinkedItemKey: string;
    /** Resolved to item number of key  */
    AttachedItemNumber?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Links to a user/contact  */
    FromUser: string;
    /** Indicates route that attached this to the document */
    FromRouteID: string;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    /** Current Revision Number when attached */
    AttachedRevID: number;
    /** View or Update */
    AccessLevel?: string | undefined;
    /** Indicates how this attachment is sent to non-web route parties, eg: 0=never;1=always;M=Assembled;P=PDF (see code set!) */
    MailRoute?: string | undefined;
    /** Controls order of attachments in merges and emails, etc */
    AttachSeq: number;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference: string;
    /** Category (Scanned Invoice;Site Photo) */
    CatType: string;
    /** Status code */
    Status?: string | undefined;
    /** Resolves to cost impact carried by the attachment */
    CostImpact: number;
    /** Resolves to responsible name of the attachment */
    ResponsibleName?: string | undefined;
    /** Code for Relationship type of attachment */
    RelationshipType?: string | undefined;
    /** Indicates the "folder" where the resource resides */
    ContainerKey: string;
    /** free form; Text Indexed */
    FileName?: string | undefined;
    /** Free form; text indexed */
    keyword?: string | undefined;
    /** Free format keywords */
    Other?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** Optional; Text Indexed */
    SourceBatchNo?: string | undefined;
    /** Date of source attachment */
    ReferenceDate: Date;
    /** TIF/DOC/JPG etc */
    FileType?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** link to contact/user; the source  */
    SourceContact: string;
    /** Approved Revision ID  */
    ApprRevID: number;
    /** Most recent Revision ID  */
    LastRevID: number;
    /** External reference */
    SourceRevision?: string | undefined;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** Date and time cataloged  */
    Cataloged: Date;
    /** Size of native binary data, regardless of current Data storage Method */
    BinSize: number;
    /** Internal document, output of a routed document */
    sfGenerated: boolean;
    /** If sfGenerated and current document is ByDocMaster and this field is true, bookmarks are refreshed */
    RefreshBookmarks: boolean;
    /** When True, e-signature tabs have been detected */
    HasSignTabs: boolean;
    /** When true, access is strictly restricted */
    Confidential: boolean;
    /** When true, this attachment is a mirror of the attachment on the other doc */
    IsInherited: boolean;
    /** When TRUE (default), file is elligible for cloud sync */
    CloudSync: boolean;
    /** When true, inbound changes are blocked */
    CloudBlockIn: boolean;
    /** When true, outbound changes are blocked */
    CloudBlockOut: boolean;
    LastSyncDir?: string | undefined;
    LastSync: Date;
    /** Key of XTS mapping */
    TDKeyMapKey: string;
    DocLinks: number;
    RCLinks: number;
    /** Key of user that has this attachment checked out */
    CheckOutUser: string;
    /** Code of current check out status (O==Out; L==Locked, etc) */
    CheckOutStatus?: string | undefined;
    /** When checked out */
    CheckedOut: Date;
    /** When checked in */
    CheckedIn: Date;
    /** When checked out will expire on its own */
    Expires: Date;
}

/** Describes an DocInclusion Condition */
export class DocInclusion implements IDocInclusion {
    /** Key to this contract annotation */
    InclusionKey!: string;
    /** See code list */
    ItemType?: string | undefined;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Amount, for custom use */
    csAmount!: number;
    csValue!: number;
    csQty!: number;
    csNumber!: number;
    /** date, for custom use */
    csDate!: Date;
    csWhen!: Date;
    /** for custom use */
    csCheck!: boolean;
    csFlag!: boolean;
    csContactKey!: string;
    csKey!: string;
    /** FreeForm */
    ItemText?: string | undefined;

    constructor(data?: IDocInclusion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.InclusionKey = _data["InclusionKey"];
            this.ItemType = _data["ItemType"];
            this.ItemNumber = _data["ItemNumber"];
            this.Paragraph = _data["Paragraph"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.ItemText = _data["ItemText"];
        }
    }

    static fromJS(data: any): DocInclusion {
        data = typeof data === 'object' ? data : {};
        let result = new DocInclusion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["InclusionKey"] = this.InclusionKey;
        data["ItemType"] = this.ItemType;
        data["ItemNumber"] = this.ItemNumber;
        data["Paragraph"] = this.Paragraph;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["ItemText"] = this.ItemText;
        return data; 
    }

    clone(): DocInclusion {
        const json = this.toJSON();
        let result = new DocInclusion();
        result.init(json);
        return result;
    }
}

/** Describes an DocInclusion Condition */
export interface IDocInclusion {
    /** Key to this contract annotation */
    InclusionKey: string;
    /** See code list */
    ItemType?: string | undefined;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Amount, for custom use */
    csAmount: number;
    csValue: number;
    csQty: number;
    csNumber: number;
    /** date, for custom use */
    csDate: Date;
    csWhen: Date;
    /** for custom use */
    csCheck: boolean;
    csFlag: boolean;
    csContactKey: string;
    csKey: string;
    /** FreeForm */
    ItemText?: string | undefined;
}

/** Describes an DocCompliance Condition */
export class DocCompliance implements IDocCompliance {
    /** Key for this compliance item */
    ComplianceItemKey!: string;
    /** Reference to compliance type */
    ComplianceTypeKey!: string;
    /** Weak reference xsfUser; set by data layer each time a user changes the Released column value */
    LastReleasedBy!: string;
    /** Reference to document to notifiy party about compliance issue */
    NotificationDocKey!: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Informational */
    Carrier?: string | undefined;
    /** Brief description of last compliance item */
    LastReason?: string | undefined;
    /** See Code List "Recur" */
    Recurs?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** No longer used */
    CertificateReqd!: boolean;
    /** OUTPUT of compliance engine. When true, this item was deemed in compliance at last evaluation */
    Complied!: boolean;
    /** When true, this compliance item can generate alerts and notifications */
    Alerts!: boolean;
    /** When false, this row is ignored and ineffective */
    Active!: boolean;
    /** Applied to comparison of current date and expiration to resolve "expires soon" */
    LeadDays!: number;
    /** Amount; Optionally compared to total current subcontract amount to determine compliance */
    Amount!: number;
    /** Out of compliance when this date is compared to the Subcontract Current Start Date */
    Effective?: Date | undefined;
    /** Date of Expiration  */
    Expiration?: Date | undefined;
    /** Only editable if type has AllowProof set true.?? When NULL, defaults to the parent document due date */
    RequiredBy?: Date | undefined;
    /** When this field is set, the item is in compliance. Period! */
    Released?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** When Alert was generated */
    LastAlertWas?: Date | undefined;
    /** For recurring alerts: set to indicate the next point in time that alerts will be considered */
    NextAlertAfter?: Date | undefined;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired!: boolean;
    /** Display name of compliance type */
    ComplianceName?: string | undefined;
    /** When true, this compliance item is dynamically evaluated by the system */
    AutoControl!: boolean;
    /** When true, the description field is editable */
    AllowDescription!: boolean;
    /** Track carrier field on compliance items */
    AllowCarrier!: boolean;
    /** When true, the RequiredBy and Received compliance fields are editable */
    AllowProof!: boolean;
    /** Track amount */
    AllowAmount!: boolean;
    /** Track effective date */
    AllowEffective!: boolean;
    /** Track expiration date */
    AllowExpiration!: boolean;
    /** Track lead days on items */
    AllowLeadDays!: boolean;
    /** Not used! */
    AllowRecurs!: boolean;
    /** Allows multiple compliance items of the same type */
    AllowMultiple!: boolean;

    constructor(data?: IDocCompliance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ComplianceItemKey = _data["ComplianceItemKey"];
            this.ComplianceTypeKey = _data["ComplianceTypeKey"];
            this.LastReleasedBy = _data["LastReleasedBy"];
            this.NotificationDocKey = _data["NotificationDocKey"];
            this.Description = _data["Description"];
            this.Carrier = _data["Carrier"];
            this.LastReason = _data["LastReason"];
            this.Recurs = _data["Recurs"];
            this.PayControl = _data["PayControl"];
            this.CertificateReqd = _data["CertificateReqd"];
            this.Complied = _data["Complied"];
            this.Alerts = _data["Alerts"];
            this.Active = _data["Active"];
            this.LeadDays = _data["LeadDays"];
            this.Amount = _data["Amount"];
            this.Effective = _data["Effective"] ? new Date(_data["Effective"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.RequiredBy = _data["RequiredBy"] ? new Date(_data["RequiredBy"].toString()) : <any>undefined;
            this.Released = _data["Released"] ? new Date(_data["Released"].toString()) : <any>undefined;
            this.Received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.LastAlertWas = _data["LastAlertWas"] ? new Date(_data["LastAlertWas"].toString()) : <any>undefined;
            this.NextAlertAfter = _data["NextAlertAfter"] ? new Date(_data["NextAlertAfter"].toString()) : <any>undefined;
            this.IsRequired = _data["IsRequired"];
            this.ComplianceName = _data["ComplianceName"];
            this.AutoControl = _data["AutoControl"];
            this.AllowDescription = _data["AllowDescription"];
            this.AllowCarrier = _data["AllowCarrier"];
            this.AllowProof = _data["AllowProof"];
            this.AllowAmount = _data["AllowAmount"];
            this.AllowEffective = _data["AllowEffective"];
            this.AllowExpiration = _data["AllowExpiration"];
            this.AllowLeadDays = _data["AllowLeadDays"];
            this.AllowRecurs = _data["AllowRecurs"];
            this.AllowMultiple = _data["AllowMultiple"];
        }
    }

    static fromJS(data: any): DocCompliance {
        data = typeof data === 'object' ? data : {};
        let result = new DocCompliance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ComplianceItemKey"] = this.ComplianceItemKey;
        data["ComplianceTypeKey"] = this.ComplianceTypeKey;
        data["LastReleasedBy"] = this.LastReleasedBy;
        data["NotificationDocKey"] = this.NotificationDocKey;
        data["Description"] = this.Description;
        data["Carrier"] = this.Carrier;
        data["LastReason"] = this.LastReason;
        data["Recurs"] = this.Recurs;
        data["PayControl"] = this.PayControl;
        data["CertificateReqd"] = this.CertificateReqd;
        data["Complied"] = this.Complied;
        data["Alerts"] = this.Alerts;
        data["Active"] = this.Active;
        data["LeadDays"] = this.LeadDays;
        data["Amount"] = this.Amount;
        data["Effective"] = this.Effective ? this.Effective.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["RequiredBy"] = this.RequiredBy ? this.RequiredBy.toISOString() : <any>undefined;
        data["Released"] = this.Released ? this.Released.toISOString() : <any>undefined;
        data["Received"] = this.Received ? this.Received.toISOString() : <any>undefined;
        data["LastAlertWas"] = this.LastAlertWas ? this.LastAlertWas.toISOString() : <any>undefined;
        data["NextAlertAfter"] = this.NextAlertAfter ? this.NextAlertAfter.toISOString() : <any>undefined;
        data["IsRequired"] = this.IsRequired;
        data["ComplianceName"] = this.ComplianceName;
        data["AutoControl"] = this.AutoControl;
        data["AllowDescription"] = this.AllowDescription;
        data["AllowCarrier"] = this.AllowCarrier;
        data["AllowProof"] = this.AllowProof;
        data["AllowAmount"] = this.AllowAmount;
        data["AllowEffective"] = this.AllowEffective;
        data["AllowExpiration"] = this.AllowExpiration;
        data["AllowLeadDays"] = this.AllowLeadDays;
        data["AllowRecurs"] = this.AllowRecurs;
        data["AllowMultiple"] = this.AllowMultiple;
        return data; 
    }

    clone(): DocCompliance {
        const json = this.toJSON();
        let result = new DocCompliance();
        result.init(json);
        return result;
    }
}

/** Describes an DocCompliance Condition */
export interface IDocCompliance {
    /** Key for this compliance item */
    ComplianceItemKey: string;
    /** Reference to compliance type */
    ComplianceTypeKey: string;
    /** Weak reference xsfUser; set by data layer each time a user changes the Released column value */
    LastReleasedBy: string;
    /** Reference to document to notifiy party about compliance issue */
    NotificationDocKey: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Informational */
    Carrier?: string | undefined;
    /** Brief description of last compliance item */
    LastReason?: string | undefined;
    /** See Code List "Recur" */
    Recurs?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** No longer used */
    CertificateReqd: boolean;
    /** OUTPUT of compliance engine. When true, this item was deemed in compliance at last evaluation */
    Complied: boolean;
    /** When true, this compliance item can generate alerts and notifications */
    Alerts: boolean;
    /** When false, this row is ignored and ineffective */
    Active: boolean;
    /** Applied to comparison of current date and expiration to resolve "expires soon" */
    LeadDays: number;
    /** Amount; Optionally compared to total current subcontract amount to determine compliance */
    Amount: number;
    /** Out of compliance when this date is compared to the Subcontract Current Start Date */
    Effective?: Date | undefined;
    /** Date of Expiration  */
    Expiration?: Date | undefined;
    /** Only editable if type has AllowProof set true.?? When NULL, defaults to the parent document due date */
    RequiredBy?: Date | undefined;
    /** When this field is set, the item is in compliance. Period! */
    Released?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** When Alert was generated */
    LastAlertWas?: Date | undefined;
    /** For recurring alerts: set to indicate the next point in time that alerts will be considered */
    NextAlertAfter?: Date | undefined;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired: boolean;
    /** Display name of compliance type */
    ComplianceName?: string | undefined;
    /** When true, this compliance item is dynamically evaluated by the system */
    AutoControl: boolean;
    /** When true, the description field is editable */
    AllowDescription: boolean;
    /** Track carrier field on compliance items */
    AllowCarrier: boolean;
    /** When true, the RequiredBy and Received compliance fields are editable */
    AllowProof: boolean;
    /** Track amount */
    AllowAmount: boolean;
    /** Track effective date */
    AllowEffective: boolean;
    /** Track expiration date */
    AllowExpiration: boolean;
    /** Track lead days on items */
    AllowLeadDays: boolean;
    /** Not used! */
    AllowRecurs: boolean;
    /** Allows multiple compliance items of the same type */
    AllowMultiple: boolean;
}

/** Describes an DocMeetingAttendee Condition */
export class DocMeetingAttendee implements IDocMeetingAttendee {
    /** Key for this attendee */
    AttendeeKey!: string;
    /** Link to user/contact */
    UserKey!: string;
    /** Weak Link to another item */
    LinkedItemKey!: string;
    /** Attendee Name */
    AttendeeName?: string | undefined;
    /** Reference to Item number */
    Reference?: string | undefined;
    /** Free form  */
    Purpose?: string | undefined;
    /** Amount */
    Amount!: number;
    /** Amount, for custom use */
    csAmount!: number;
    csValue!: number;
    csQty!: number;
    csNumber!: number;
    Resolved!: Date;
    /** date, for custom use */
    csDate!: Date;
    csWhen!: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    csContactKey!: string;
    csKey!: string;
    Present!: boolean;
    /** When TRUE, auto copied to next meeting */
    IsRegular!: boolean;
    /** for custom use */
    csCheck!: boolean;
    csFlag!: boolean;
    /** Free form */
    Note?: string | undefined;

    constructor(data?: IDocMeetingAttendee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AttendeeKey = _data["AttendeeKey"];
            this.UserKey = _data["UserKey"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.AttendeeName = _data["AttendeeName"];
            this.Reference = _data["Reference"];
            this.Purpose = _data["Purpose"];
            this.Amount = _data["Amount"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.Resolved = _data["Resolved"] ? new Date(_data["Resolved"].toString()) : <any>undefined;
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.Present = _data["Present"];
            this.IsRegular = _data["IsRegular"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.Note = _data["Note"];
        }
    }

    static fromJS(data: any): DocMeetingAttendee {
        data = typeof data === 'object' ? data : {};
        let result = new DocMeetingAttendee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttendeeKey"] = this.AttendeeKey;
        data["UserKey"] = this.UserKey;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["AttendeeName"] = this.AttendeeName;
        data["Reference"] = this.Reference;
        data["Purpose"] = this.Purpose;
        data["Amount"] = this.Amount;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["Resolved"] = this.Resolved ? this.Resolved.toISOString() : <any>undefined;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["Present"] = this.Present;
        data["IsRegular"] = this.IsRegular;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.Note;
        return data; 
    }

    clone(): DocMeetingAttendee {
        const json = this.toJSON();
        let result = new DocMeetingAttendee();
        result.init(json);
        return result;
    }
}

/** Describes an DocMeetingAttendee Condition */
export interface IDocMeetingAttendee {
    /** Key for this attendee */
    AttendeeKey: string;
    /** Link to user/contact */
    UserKey: string;
    /** Weak Link to another item */
    LinkedItemKey: string;
    /** Attendee Name */
    AttendeeName?: string | undefined;
    /** Reference to Item number */
    Reference?: string | undefined;
    /** Free form  */
    Purpose?: string | undefined;
    /** Amount */
    Amount: number;
    /** Amount, for custom use */
    csAmount: number;
    csValue: number;
    csQty: number;
    csNumber: number;
    Resolved: Date;
    /** date, for custom use */
    csDate: Date;
    csWhen: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    csContactKey: string;
    csKey: string;
    Present: boolean;
    /** When TRUE, auto copied to next meeting */
    IsRegular: boolean;
    /** for custom use */
    csCheck: boolean;
    csFlag: boolean;
    /** Free form */
    Note?: string | undefined;
}

/** Describes an DocInstruction Condition */
export class DocAttribute implements IDocAttribute {
    DocAttributeKey!: string;
    /** Indicates the set of attributes from which this row was derived */
    AttrType?: string | undefined;
    /** Specifies the specific attribute of the set */
    AttrValue?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Amount */
    Amount!: number;
    /** pjcosubd.change_units */
    Quantity!: number;
    /** System table */
    Value!: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form */
    Recorded!: Date;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed!: Date;

    constructor(data?: IDocAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttributeKey = _data["DocAttributeKey"];
            this.AttrType = _data["AttrType"];
            this.AttrValue = _data["AttrValue"];
            this.Paragraph = _data["Paragraph"];
            this.Specification = _data["Specification"];
            this.Amount = _data["Amount"];
            this.Quantity = _data["Quantity"];
            this.Value = _data["Value"];
            this.Description = _data["Description"];
            this.Note = _data["Note"];
            this.Recorded = _data["Recorded"] ? new Date(_data["Recorded"].toString()) : <any>undefined;
            this.Reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new DocAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttributeKey"] = this.DocAttributeKey;
        data["AttrType"] = this.AttrType;
        data["AttrValue"] = this.AttrValue;
        data["Paragraph"] = this.Paragraph;
        data["Specification"] = this.Specification;
        data["Amount"] = this.Amount;
        data["Quantity"] = this.Quantity;
        data["Value"] = this.Value;
        data["Description"] = this.Description;
        data["Note"] = this.Note;
        data["Recorded"] = this.Recorded ? this.Recorded.toISOString() : <any>undefined;
        data["Reviewed"] = this.Reviewed ? this.Reviewed.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocAttribute {
        const json = this.toJSON();
        let result = new DocAttribute();
        result.init(json);
        return result;
    }
}

/** Describes an DocInstruction Condition */
export interface IDocAttribute {
    DocAttributeKey: string;
    /** Indicates the set of attributes from which this row was derived */
    AttrType?: string | undefined;
    /** Specifies the specific attribute of the set */
    AttrValue?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Amount */
    Amount: number;
    /** pjcosubd.change_units */
    Quantity: number;
    /** System table */
    Value: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form */
    Recorded: Date;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed: Date;
}

/** Describes an DocItemComment Condition */
export class DocItemComment implements IDocItemComment {
    /** key for this comment */
    DocCommentKey!: string;
    /** Links to a user/contact  */
    FromUser!: string;
    /** Free form */
    Note?: string | undefined;
    /** free form */
    Cost!: number;
    /** Initialized to current stage when added */
    Stage!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    /** Amount, for custom use */
    csAmount!: number;
    /** for custom user */
    csValue!: number;
    /** for custom user */
    csQty!: number;
    /** for custom user */
    csNumber!: number;
    /** for custom use */
    csCheck!: boolean;
    /** for custom user */
    csFlag!: boolean;
    /** for custom user */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom user */
    csContactKey!: string;
    /** for custom user */
    csKey!: string;
    /** date, for custom use */
    csDate!: Date;
    /** for custom user */
    csWhen!: Date;

    constructor(data?: IDocItemComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocCommentKey = _data["DocCommentKey"];
            this.FromUser = _data["FromUser"];
            this.Note = _data["Note"];
            this.Cost = _data["Cost"];
            this.Stage = _data["Stage"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocItemComment {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.DocCommentKey;
        data["FromUser"] = this.FromUser;
        data["Note"] = this.Note;
        data["Cost"] = this.Cost;
        data["Stage"] = this.Stage;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocItemComment {
        const json = this.toJSON();
        let result = new DocItemComment();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemComment Condition */
export interface IDocItemComment {
    /** key for this comment */
    DocCommentKey: string;
    /** Links to a user/contact  */
    FromUser: string;
    /** Free form */
    Note?: string | undefined;
    /** free form */
    Cost: number;
    /** Initialized to current stage when added */
    Stage: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    /** Amount, for custom use */
    csAmount: number;
    /** for custom user */
    csValue: number;
    /** for custom user */
    csQty: number;
    /** for custom user */
    csNumber: number;
    /** for custom use */
    csCheck: boolean;
    /** for custom user */
    csFlag: boolean;
    /** for custom user */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom user */
    csContactKey: string;
    /** for custom user */
    csKey: string;
    /** date, for custom use */
    csDate: Date;
    /** for custom user */
    csWhen: Date;
}

/** Document Header informat for a process */
export class DocMasterDetail implements IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey!: string;
    /** References a Document Process Type */
    DocTypeKey!: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference!: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate!: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority!: number;
    /** Number to send */
    NumToSend!: number;
    /** Number to forward  */
    NumToForward!: number;
    /** numeric probability. valid values 0 to 100 */
    Probability!: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled!: boolean;
    /** When true, access is strictly restricted */
    Confidential!: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit!: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final!: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag!: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due!: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed!: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff!: Date;
    /** For example, invoice date of pay request */
    SourceDate!: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey!: string;
    /** key to global reference */
    UniReferenceKey!: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty!: string;
    /** link to contact/user; the source  */
    SourceContact!: string;
    /** Validated in Contact Table */
    OwnerApprover!: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy!: string;
    /** Predefined route last resolved */
    LastRouteKey!: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area!: number;
    /** Numeric duration - units implied by SOP */
    Duration!: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask!: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags!: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser!: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage!: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo!: number;
    /** Readonly Links to document revision */
    DocRevKey!: string;
    /** Readonly key for document session */
    DocSessionKey!: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq!: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS!: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn!: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut!: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey!: string;
    /** Key to user currently editing  */
    EditUser!: string;
    /** summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;
    /** Revision Number - System Generated */
    RevNo!: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Scheduled Impact Requested in Days */
    DaysRequested!: number;
    /** Scheduled Impact Approved */
    DaysApproved!: number;
    /** Amount of Completed Work Retention */
    CWRetention!: number;
    /** Amount of Stored Material Retention */
    SMRetention!: number;
    /** Cost Impact - often computed by a configurable formula sumarizing the items */
    CostImpact!: number;
    RangeFrom!: number;
    RangeThru!: number;
    Bond!: number;
    BondRate!: number;
    /** 8.25% as .0825 */
    TaxRate!: number;
    /** Code defined in DocType specific list */
    Segment?: string | undefined;
    /** Code defined in DocType specific list */
    Subsegment?: string | undefined;
    /** Link to external document  */
    DraftNumber?: string | undefined;
    /** Architect's Project (External Reference) */
    ArchProject?: string | undefined;
    /** Tax ID code */
    TaxID?: string | undefined;
    /** Codes assigned by Spitfire with special handling for Tax Included, Tax Added, No Tax */
    TaxHandling?: string | undefined;
    /** YYYYMM */
    InPeriod?: string | undefined;
    /** Free format notes */
    Notes?: string | undefined;
    /** Free format notes */
    NoteA?: string | undefined;
    /** Free format notes */
    NoteB?: string | undefined;
    /** Free format notes */
    NoteEML?: string | undefined;
    /** Subject for Email generated (See ATC: EMAIL workflow) */
    EmailSubject?: string | undefined;
    /** Amount, for custom use */
    csAmount!: number;
    /** for custom use */
    csValue!: number;
    /** for custom use */
    csQty!: number;
    /** for custom use */
    csNumber!: number;
    /** date, for custom use */
    csDate!: Date;
    /** for custom use */
    csWhen!: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** for custom use */
    csContactKey!: string;
    /** for custom use */
    csKey!: string;
    /** for custom use */
    csCheck!: boolean;
    /** for custom use */
    csFlag!: boolean;
    /** Version of SFPMS when revision created (4.1 and later) */
    sfVersion!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    /** When true, a financial snapshot exists for this Revision Key */
    HasBFASS!: boolean;

    constructor(data?: IDocMasterDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Title = _data["Title"];
            this.Source = _data["Source"];
            this.Priority = _data["Priority"];
            this.NumToSend = _data["NumToSend"];
            this.NumToForward = _data["NumToForward"];
            this.Probability = _data["Probability"];
            this.AutoTitled = _data["AutoTitled"];
            this.Confidential = _data["Confidential"];
            this.DocEdit = _data["DocEdit"];
            this.Final = _data["Final"];
            this.DocFlag = _data["DocFlag"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.SourceContact = _data["SourceContact"];
            this.OwnerApprover = _data["OwnerApprover"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.LastRouteKey = _data["LastRouteKey"];
            this.Status = _data["Status"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(Suggestion.fromJS(item));
            }
            this.Subtype = _data["Subtype"];
            this.ContractType = _data["ContractType"];
            this.Reason = _data["Reason"];
            this.Area = _data["Area"];
            this.Duration = _data["Duration"];
            this.UpdateMask = _data["UpdateMask"];
            this.RouteFlags = _data["RouteFlags"];
            this.Location = _data["Location"];
            this.PayItemNumber = _data["PayItemNumber"];
            this.DivisionID = _data["DivisionID"];
            this.Project = _data["Project"];
            this.ProjEntity = _data["ProjEntity"];
            this.Specification = _data["Specification"];
            this.BudgetRevFlag = _data["BudgetRevFlag"];
            this.SOVItemNumber = _data["SOVItemNumber"];
            this.Section = _data["Section"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.FromUser = _data["FromUser"];
            this.MaxStage = _data["MaxStage"];
            this.MaxRevNo = _data["MaxRevNo"];
            this.DocRevKey = _data["DocRevKey"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.ProjectSubtype = _data["ProjectSubtype"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.EditUser = _data["EditUser"];
            this.ComplianceInfo = _data["ComplianceInfo"];
            this.RevNo = _data["RevNo"];
            this.Description = _data["Description"];
            this.DaysRequested = _data["DaysRequested"];
            this.DaysApproved = _data["DaysApproved"];
            this.CWRetention = _data["CWRetention"];
            this.SMRetention = _data["SMRetention"];
            this.CostImpact = _data["CostImpact"];
            this.RangeFrom = _data["RangeFrom"];
            this.RangeThru = _data["RangeThru"];
            this.Bond = _data["Bond"];
            this.BondRate = _data["BondRate"];
            this.TaxRate = _data["TaxRate"];
            this.Segment = _data["Segment"];
            this.Subsegment = _data["Subsegment"];
            this.DraftNumber = _data["DraftNumber"];
            this.ArchProject = _data["ArchProject"];
            this.TaxID = _data["TaxID"];
            this.TaxHandling = _data["TaxHandling"];
            this.InPeriod = _data["InPeriod"];
            this.Notes = _data["Notes"];
            this.NoteA = _data["NoteA"];
            this.NoteB = _data["NoteB"];
            this.NoteEML = _data["NoteEML"];
            this.EmailSubject = _data["EmailSubject"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.sfVersion = _data["sfVersion"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.HasBFASS = _data["HasBFASS"];
        }
    }

    static fromJS(data: any): DocMasterDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DocMasterDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Title"] = this.Title;
        data["Source"] = this.Source;
        data["Priority"] = this.Priority;
        data["NumToSend"] = this.NumToSend;
        data["NumToForward"] = this.NumToForward;
        data["Probability"] = this.Probability;
        data["AutoTitled"] = this.AutoTitled;
        data["Confidential"] = this.Confidential;
        data["DocEdit"] = this.DocEdit;
        data["Final"] = this.Final;
        data["DocFlag"] = this.DocFlag;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["SourceContact"] = this.SourceContact;
        data["OwnerApprover"] = this.OwnerApprover;
        data["LastStatusBy"] = this.LastStatusBy;
        data["LastRouteKey"] = this.LastRouteKey;
        data["Status"] = this.Status;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        data["Subtype"] = this.Subtype;
        data["ContractType"] = this.ContractType;
        data["Reason"] = this.Reason;
        data["Area"] = this.Area;
        data["Duration"] = this.Duration;
        data["UpdateMask"] = this.UpdateMask;
        data["RouteFlags"] = this.RouteFlags;
        data["Location"] = this.Location;
        data["PayItemNumber"] = this.PayItemNumber;
        data["DivisionID"] = this.DivisionID;
        data["Project"] = this.Project;
        data["ProjEntity"] = this.ProjEntity;
        data["Specification"] = this.Specification;
        data["BudgetRevFlag"] = this.BudgetRevFlag;
        data["SOVItemNumber"] = this.SOVItemNumber;
        data["Section"] = this.Section;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["FromUser"] = this.FromUser;
        data["MaxStage"] = this.MaxStage;
        data["MaxRevNo"] = this.MaxRevNo;
        data["DocRevKey"] = this.DocRevKey;
        data["DocSessionKey"] = this.DocSessionKey;
        data["CurrentSeq"] = this.CurrentSeq;
        data["ProjectSubtype"] = this.ProjectSubtype;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["EditUser"] = this.EditUser;
        data["ComplianceInfo"] = this.ComplianceInfo;
        data["RevNo"] = this.RevNo;
        data["Description"] = this.Description;
        data["DaysRequested"] = this.DaysRequested;
        data["DaysApproved"] = this.DaysApproved;
        data["CWRetention"] = this.CWRetention;
        data["SMRetention"] = this.SMRetention;
        data["CostImpact"] = this.CostImpact;
        data["RangeFrom"] = this.RangeFrom;
        data["RangeThru"] = this.RangeThru;
        data["Bond"] = this.Bond;
        data["BondRate"] = this.BondRate;
        data["TaxRate"] = this.TaxRate;
        data["Segment"] = this.Segment;
        data["Subsegment"] = this.Subsegment;
        data["DraftNumber"] = this.DraftNumber;
        data["ArchProject"] = this.ArchProject;
        data["TaxID"] = this.TaxID;
        data["TaxHandling"] = this.TaxHandling;
        data["InPeriod"] = this.InPeriod;
        data["Notes"] = this.Notes;
        data["NoteA"] = this.NoteA;
        data["NoteB"] = this.NoteB;
        data["NoteEML"] = this.NoteEML;
        data["EmailSubject"] = this.EmailSubject;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["sfVersion"] = this.sfVersion;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["HasBFASS"] = this.HasBFASS;
        return data; 
    }

    clone(): DocMasterDetail {
        const json = this.toJSON();
        let result = new DocMasterDetail();
        result.init(json);
        return result;
    }
}

/** Document Header informat for a process */
export interface IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey: string;
    /** References a Document Process Type */
    DocTypeKey: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority: number;
    /** Number to send */
    NumToSend: number;
    /** Number to forward  */
    NumToForward: number;
    /** numeric probability. valid values 0 to 100 */
    Probability: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled: boolean;
    /** When true, access is strictly restricted */
    Confidential: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff: Date;
    /** For example, invoice date of pay request */
    SourceDate: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey: string;
    /** key to global reference */
    UniReferenceKey: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty: string;
    /** link to contact/user; the source  */
    SourceContact: string;
    /** Validated in Contact Table */
    OwnerApprover: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy: string;
    /** Predefined route last resolved */
    LastRouteKey: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area: number;
    /** Numeric duration - units implied by SOP */
    Duration: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo: number;
    /** Readonly Links to document revision */
    DocRevKey: string;
    /** Readonly key for document session */
    DocSessionKey: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey: string;
    /** Key to user currently editing  */
    EditUser: string;
    /** summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;
    /** Revision Number - System Generated */
    RevNo: number;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Scheduled Impact Requested in Days */
    DaysRequested: number;
    /** Scheduled Impact Approved */
    DaysApproved: number;
    /** Amount of Completed Work Retention */
    CWRetention: number;
    /** Amount of Stored Material Retention */
    SMRetention: number;
    /** Cost Impact - often computed by a configurable formula sumarizing the items */
    CostImpact: number;
    RangeFrom: number;
    RangeThru: number;
    Bond: number;
    BondRate: number;
    /** 8.25% as .0825 */
    TaxRate: number;
    /** Code defined in DocType specific list */
    Segment?: string | undefined;
    /** Code defined in DocType specific list */
    Subsegment?: string | undefined;
    /** Link to external document  */
    DraftNumber?: string | undefined;
    /** Architect's Project (External Reference) */
    ArchProject?: string | undefined;
    /** Tax ID code */
    TaxID?: string | undefined;
    /** Codes assigned by Spitfire with special handling for Tax Included, Tax Added, No Tax */
    TaxHandling?: string | undefined;
    /** YYYYMM */
    InPeriod?: string | undefined;
    /** Free format notes */
    Notes?: string | undefined;
    /** Free format notes */
    NoteA?: string | undefined;
    /** Free format notes */
    NoteB?: string | undefined;
    /** Free format notes */
    NoteEML?: string | undefined;
    /** Subject for Email generated (See ATC: EMAIL workflow) */
    EmailSubject?: string | undefined;
    /** Amount, for custom use */
    csAmount: number;
    /** for custom use */
    csValue: number;
    /** for custom use */
    csQty: number;
    /** for custom use */
    csNumber: number;
    /** date, for custom use */
    csDate: Date;
    /** for custom use */
    csWhen: Date;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** for custom use */
    csContactKey: string;
    /** for custom use */
    csKey: string;
    /** for custom use */
    csCheck: boolean;
    /** for custom use */
    csFlag: boolean;
    /** Version of SFPMS when revision created (4.1 and later) */
    sfVersion: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    /** When true, a financial snapshot exists for this Revision Key */
    HasBFASS: boolean;
}

/** Describes an DocItem Condition */
export class DocItem implements IDocItem {
    /** Key of this item */
    DocItemKey!: string;
    /** Readonly Number of task entries for this item; often 1 */
    TaskCount!: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount!: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty!: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey!: string;
    /** Weak Link to another item */
    LinkedItemKey!: string;
    /** Key to global reference  */
    UniReferenceKey!: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy!: string;
    /** Key Reference user/contact */
    Approver!: string;
    /** References user/contact */
    Author!: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage!: number;
    /** Money - Completed Work Retention */
    CWRetention!: number;
    /** Money - Stored Material Retention */
    SMRetention!: number;
    /** Original Estimate (of cost) */
    OriginalEstimate!: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote!: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity!: number;
    /** when true, is billable/included */
    Billable!: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey!: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey!: string;
    /** Reference to user/contact */
    ItemFromUser!: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated!: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc!: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared!: boolean;
    /** Hmm */
    ResponsibleNow!: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;

    constructor(data?: IDocItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocItemKey = _data["DocItemKey"];
            this.TaskCount = _data["TaskCount"];
            this.CommentCount = _data["CommentCount"];
            this.ItemRevisionMap = _data["ItemRevisionMap"] ? DocItemMap.fromJS(_data["ItemRevisionMap"]) : <any>undefined;
            if (Array.isArray(_data["DocItemTask"])) {
                this.DocItemTask = [] as any;
                for (let item of _data["DocItemTask"])
                    this.DocItemTask!.push(DocItemTask.fromJS(item));
            }
            this.RelatedLineDetails = _data["RelatedLineDetails"] ? RelatedItemDetail.fromJS(_data["RelatedLineDetails"]) : <any>undefined;
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.Approver = _data["Approver"];
            this.Author = _data["Author"];
            this.Description = _data["Description"];
            this.DrawingNumber = _data["DrawingNumber"];
            this.RevisionNumber = _data["RevisionNumber"];
            this.Paragraph = _data["Paragraph"];
            this.Specification = _data["Specification"];
            this.ItemStatus = _data["ItemStatus"];
            this.ItemSource = _data["ItemSource"];
            this.ItemType = _data["ItemType"];
            this.ItemSubtype = _data["ItemSubtype"];
            this.Drawings = _data["Drawings"];
            this.Samples = _data["Samples"];
            this.ProductData = _data["ProductData"];
            this.TestReport = _data["TestReport"];
            this.MixDesign = _data["MixDesign"];
            this.Schedule = _data["Schedule"];
            this.FieldMockup = _data["FieldMockup"];
            this.Guarantee = _data["Guarantee"];
            this.Certification = _data["Certification"];
            this.Evaluation = _data["Evaluation"];
            this.Shop = _data["Shop"];
            this.SourceItemNumber = _data["SourceItemNumber"];
            this.SourceInitialNumber = _data["SourceInitialNumber"];
            this.ArchitectInitialNumber = _data["ArchitectInitialNumber"];
            this.ArchitectItemNumber = _data["ArchitectItemNumber"];
            this.SOVLineNumber = _data["SOVLineNumber"];
            this.Manufacturer = _data["Manufacturer"];
            this.Supplier = _data["Supplier"];
            this.RevenueEntity = _data["RevenueEntity"];
            this.Stage = _data["Stage"];
            this.CWRetention = _data["CWRetention"];
            this.SMRetention = _data["SMRetention"];
            this.OriginalEstimate = _data["OriginalEstimate"];
            this.OriginalQuote = _data["OriginalQuote"];
            this.ItemQuantity = _data["ItemQuantity"];
            this.Billable = _data["Billable"];
            this.Started = _data["Started"] ? new Date(_data["Started"].toString()) : <any>undefined;
            this.Submitted = _data["Submitted"] ? new Date(_data["Submitted"].toString()) : <any>undefined;
            this.Requested = _data["Requested"] ? new Date(_data["Requested"].toString()) : <any>undefined;
            this.Received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.Reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Completed = _data["Completed"] ? new Date(_data["Completed"].toString()) : <any>undefined;
            this.ItemRevKey = _data["ItemRevKey"];
            this.ItemFolderKey = _data["ItemFolderKey"];
            this.ItemFromUser = _data["ItemFromUser"];
            this.DocItemNumber = _data["DocItemNumber"];
            this.ItemCreated = _data["ItemCreated"] ? new Date(_data["ItemCreated"].toString()) : <any>undefined;
            this.IsRegisterDoc = _data["IsRegisterDoc"];
            this.ItemRegisterNumber = _data["ItemRegisterNumber"];
            this.ItemIsShared = _data["ItemIsShared"];
            this.ResponsibleNow = _data["ResponsibleNow"];
            this.ResponsibleCommon = _data["ResponsibleCommon"];
        }
    }

    static fromJS(data: any): DocItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocItemKey"] = this.DocItemKey;
        data["TaskCount"] = this.TaskCount;
        data["CommentCount"] = this.CommentCount;
        data["ItemRevisionMap"] = this.ItemRevisionMap ? this.ItemRevisionMap.toJSON() : <any>undefined;
        if (Array.isArray(this.DocItemTask)) {
            data["DocItemTask"] = [];
            for (let item of this.DocItemTask)
                data["DocItemTask"].push(item.toJSON());
        }
        data["RelatedLineDetails"] = this.RelatedLineDetails ? this.RelatedLineDetails.toJSON() : <any>undefined;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["LastStatusBy"] = this.LastStatusBy;
        data["Approver"] = this.Approver;
        data["Author"] = this.Author;
        data["Description"] = this.Description;
        data["DrawingNumber"] = this.DrawingNumber;
        data["RevisionNumber"] = this.RevisionNumber;
        data["Paragraph"] = this.Paragraph;
        data["Specification"] = this.Specification;
        data["ItemStatus"] = this.ItemStatus;
        data["ItemSource"] = this.ItemSource;
        data["ItemType"] = this.ItemType;
        data["ItemSubtype"] = this.ItemSubtype;
        data["Drawings"] = this.Drawings;
        data["Samples"] = this.Samples;
        data["ProductData"] = this.ProductData;
        data["TestReport"] = this.TestReport;
        data["MixDesign"] = this.MixDesign;
        data["Schedule"] = this.Schedule;
        data["FieldMockup"] = this.FieldMockup;
        data["Guarantee"] = this.Guarantee;
        data["Certification"] = this.Certification;
        data["Evaluation"] = this.Evaluation;
        data["Shop"] = this.Shop;
        data["SourceItemNumber"] = this.SourceItemNumber;
        data["SourceInitialNumber"] = this.SourceInitialNumber;
        data["ArchitectInitialNumber"] = this.ArchitectInitialNumber;
        data["ArchitectItemNumber"] = this.ArchitectItemNumber;
        data["SOVLineNumber"] = this.SOVLineNumber;
        data["Manufacturer"] = this.Manufacturer;
        data["Supplier"] = this.Supplier;
        data["RevenueEntity"] = this.RevenueEntity;
        data["Stage"] = this.Stage;
        data["CWRetention"] = this.CWRetention;
        data["SMRetention"] = this.SMRetention;
        data["OriginalEstimate"] = this.OriginalEstimate;
        data["OriginalQuote"] = this.OriginalQuote;
        data["ItemQuantity"] = this.ItemQuantity;
        data["Billable"] = this.Billable;
        data["Started"] = this.Started ? this.Started.toISOString() : <any>undefined;
        data["Submitted"] = this.Submitted ? this.Submitted.toISOString() : <any>undefined;
        data["Requested"] = this.Requested ? this.Requested.toISOString() : <any>undefined;
        data["Received"] = this.Received ? this.Received.toISOString() : <any>undefined;
        data["Reviewed"] = this.Reviewed ? this.Reviewed.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Completed"] = this.Completed ? this.Completed.toISOString() : <any>undefined;
        data["ItemRevKey"] = this.ItemRevKey;
        data["ItemFolderKey"] = this.ItemFolderKey;
        data["ItemFromUser"] = this.ItemFromUser;
        data["DocItemNumber"] = this.DocItemNumber;
        data["ItemCreated"] = this.ItemCreated ? this.ItemCreated.toISOString() : <any>undefined;
        data["IsRegisterDoc"] = this.IsRegisterDoc;
        data["ItemRegisterNumber"] = this.ItemRegisterNumber;
        data["ItemIsShared"] = this.ItemIsShared;
        data["ResponsibleNow"] = this.ResponsibleNow;
        data["ResponsibleCommon"] = this.ResponsibleCommon;
        return data; 
    }

    clone(): DocItem {
        const json = this.toJSON();
        let result = new DocItem();
        result.init(json);
        return result;
    }
}

/** Describes an DocItem Condition */
export interface IDocItem {
    /** Key of this item */
    DocItemKey: string;
    /** Readonly Number of task entries for this item; often 1 */
    TaskCount: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey: string;
    /** Weak Link to another item */
    LinkedItemKey: string;
    /** Key to global reference  */
    UniReferenceKey: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy: string;
    /** Key Reference user/contact */
    Approver: string;
    /** References user/contact */
    Author: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage: number;
    /** Money - Completed Work Retention */
    CWRetention: number;
    /** Money - Stored Material Retention */
    SMRetention: number;
    /** Original Estimate (of cost) */
    OriginalEstimate: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity: number;
    /** when true, is billable/included */
    Billable: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey: string;
    /** Reference to user/contact */
    ItemFromUser: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared: boolean;
    /** Hmm */
    ResponsibleNow: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;
}

/** Describes an DocRevItem Condition */
export class DocItemMap implements IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey!: string;
    /** Links to item */
    DocItemKey!: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey!: string;
    /** Links to a user/contact  */
    FromUser!: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;

    constructor(data?: IDocItemMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocRevItemKey = _data["DocRevItemKey"];
            this.DocItemKey = _data["DocItemKey"];
            this.ContainerKey = _data["ContainerKey"];
            this.FromUser = _data["FromUser"];
            this.ItemNumber = _data["ItemNumber"];
            this.ItemSeq = _data["ItemSeq"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocItemMap {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocRevItemKey"] = this.DocRevItemKey;
        data["DocItemKey"] = this.DocItemKey;
        data["ContainerKey"] = this.ContainerKey;
        data["FromUser"] = this.FromUser;
        data["ItemNumber"] = this.ItemNumber;
        data["ItemSeq"] = this.ItemSeq;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocItemMap {
        const json = this.toJSON();
        let result = new DocItemMap();
        result.init(json);
        return result;
    }
}

/** Describes an DocRevItem Condition */
export interface IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey: string;
    /** Links to item */
    DocItemKey: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey: string;
    /** Links to a user/contact  */
    FromUser: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
}

/** Describes an DocItemTask Condition */
export class DocItemTask implements IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey!: string;
    LinkedLineKey!: string;
    /** Weak link to RFQ */
    LinkedRFQKey!: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey!: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent!: number;
    /** pjcosubd.change_units */
    Quantity!: number;
    /** Calculated, but editable */
    RevenueAmount!: number;
    Rate!: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount!: number;
    /** Material part of RevenueAmount */
    StoredAmount!: number;
    /** Labor part of RevenueAmount */
    WorkAmount!: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount!: number;
    SMRetentionAmount!: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork!: number;
    /** Total material value on SOV */
    SOVMaterials!: number;
    MarkupRate!: number;
    /** Amount, for custom use */
    csAmount!: number;
    csValue!: number;
    csQty!: number;
    csNumber!: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl!: boolean;
    /** for custom use */
    csCheck!: boolean;
    csFlag!: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey!: string;
    csKey!: string;
    /** date, for custom use */
    csDate!: Date;
    csWhen!: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    LinkedEstimate!: number;
    LinkedQuote!: number;
    LinkedExpense!: number;
    LinkedLines!: number;
    LinkedContact!: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;

    constructor(data?: IDocItemTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ItemTaskKey = _data["ItemTaskKey"];
            this.LinkedLineKey = _data["LinkedLineKey"];
            this.LinkedRFQKey = _data["LinkedRFQKey"];
            this.LinkedCCCKey = _data["LinkedCCCKey"];
            this.ProjEntity = _data["ProjEntity"];
            this.AccountCategory = _data["AccountCategory"];
            this.Subcontract = _data["Subcontract"];
            this.SubChangeOrder = _data["SubChangeOrder"];
            this.CostType = _data["CostType"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.UOM = _data["UOM"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.Vendor = _data["Vendor"];
            this.ProjectReference = _data["ProjectReference"];
            this.ItemPercent = _data["ItemPercent"];
            this.Quantity = _data["Quantity"];
            this.RevenueAmount = _data["RevenueAmount"];
            this.Rate = _data["Rate"];
            this.ExpenseAmount = _data["ExpenseAmount"];
            this.StoredAmount = _data["StoredAmount"];
            this.WorkAmount = _data["WorkAmount"];
            this.RetentionAmount = _data["RetentionAmount"];
            this.SMRetentionAmount = _data["SMRetentionAmount"];
            this.SOVWork = _data["SOVWork"];
            this.SOVMaterials = _data["SOVMaterials"];
            this.MarkupRate = _data["MarkupRate"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.MarkupControl = _data["MarkupControl"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.Note = _data["Note"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.LinkedEstimate = _data["LinkedEstimate"];
            this.LinkedQuote = _data["LinkedQuote"];
            this.LinkedExpense = _data["LinkedExpense"];
            this.LinkedLines = _data["LinkedLines"];
            this.LinkedContact = _data["LinkedContact"];
            this.LinkedRFQSC = _data["LinkedRFQSC"];
            this.LinkedStatus = _data["LinkedStatus"];
        }
    }

    static fromJS(data: any): DocItemTask {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemTaskKey"] = this.ItemTaskKey;
        data["LinkedLineKey"] = this.LinkedLineKey;
        data["LinkedRFQKey"] = this.LinkedRFQKey;
        data["LinkedCCCKey"] = this.LinkedCCCKey;
        data["ProjEntity"] = this.ProjEntity;
        data["AccountCategory"] = this.AccountCategory;
        data["Subcontract"] = this.Subcontract;
        data["SubChangeOrder"] = this.SubChangeOrder;
        data["CostType"] = this.CostType;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["UOM"] = this.UOM;
        data["RetentionMethod"] = this.RetentionMethod;
        data["Vendor"] = this.Vendor;
        data["ProjectReference"] = this.ProjectReference;
        data["ItemPercent"] = this.ItemPercent;
        data["Quantity"] = this.Quantity;
        data["RevenueAmount"] = this.RevenueAmount;
        data["Rate"] = this.Rate;
        data["ExpenseAmount"] = this.ExpenseAmount;
        data["StoredAmount"] = this.StoredAmount;
        data["WorkAmount"] = this.WorkAmount;
        data["RetentionAmount"] = this.RetentionAmount;
        data["SMRetentionAmount"] = this.SMRetentionAmount;
        data["SOVWork"] = this.SOVWork;
        data["SOVMaterials"] = this.SOVMaterials;
        data["MarkupRate"] = this.MarkupRate;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["MarkupControl"] = this.MarkupControl;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.Note;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["LinkedEstimate"] = this.LinkedEstimate;
        data["LinkedQuote"] = this.LinkedQuote;
        data["LinkedExpense"] = this.LinkedExpense;
        data["LinkedLines"] = this.LinkedLines;
        data["LinkedContact"] = this.LinkedContact;
        data["LinkedRFQSC"] = this.LinkedRFQSC;
        data["LinkedStatus"] = this.LinkedStatus;
        return data; 
    }

    clone(): DocItemTask {
        const json = this.toJSON();
        let result = new DocItemTask();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemTask Condition */
export interface IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey: string;
    LinkedLineKey: string;
    /** Weak link to RFQ */
    LinkedRFQKey: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent: number;
    /** pjcosubd.change_units */
    Quantity: number;
    /** Calculated, but editable */
    RevenueAmount: number;
    Rate: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount: number;
    /** Material part of RevenueAmount */
    StoredAmount: number;
    /** Labor part of RevenueAmount */
    WorkAmount: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount: number;
    SMRetentionAmount: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork: number;
    /** Total material value on SOV */
    SOVMaterials: number;
    MarkupRate: number;
    /** Amount, for custom use */
    csAmount: number;
    csValue: number;
    csQty: number;
    csNumber: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl: boolean;
    /** for custom use */
    csCheck: boolean;
    csFlag: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey: string;
    csKey: string;
    /** date, for custom use */
    csDate: Date;
    csWhen: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    LinkedEstimate: number;
    LinkedQuote: number;
    LinkedExpense: number;
    LinkedLines: number;
    LinkedContact: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;
}

/** Describes an SPRLineDetails Condition */
export class RelatedItemDetail implements IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey!: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity!: number;
    /** Approved Retention  */
    ApprovedRetention!: number;
    /** Change Order Approved  */
    ApprovedAmount!: number;
    /** Change Order Approved  */
    ApprovedExpense!: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits!: number;
    /** not yet approved */
    PendingChangeRetention!: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount!: number;
    /** not yet approved */
    PendingChangeExpense!: number;
    /** Paid Units */
    VoucheredUnits!: number;
    /** Paid Amount */
    VoucheredAmount!: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount!: number;
    /** Amount Earned but held as retention */
    VoucheredRetention!: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention!: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity!: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention!: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount!: number;
    /** Units received */
    ReceivedUnits!: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits!: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount!: number;
    /** Units on line, includes change orders */
    ContractUnits!: number;
    /** Percent */
    TotalPercentRequest!: number;
    /** Units */
    TotalUnitsCompleted!: number;
    /** Amount */
    TotalAmountCompleted!: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount!: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent!: number;
    Rate!: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap!: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;

    constructor(data?: IRelatedItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.Subcontract = _data["Subcontract"];
            this.SCDocItemKey = _data["SCDocItemKey"];
            this.ApprovedQuantity = _data["ApprovedQuantity"];
            this.ApprovedRetention = _data["ApprovedRetention"];
            this.ApprovedAmount = _data["ApprovedAmount"];
            this.ApprovedExpense = _data["ApprovedExpense"];
            this.PendingChangeUnits = _data["PendingChangeUnits"];
            this.PendingChangeRetention = _data["PendingChangeRetention"];
            this.PendingChangeAmount = _data["PendingChangeAmount"];
            this.PendingChangeExpense = _data["PendingChangeExpense"];
            this.VoucheredUnits = _data["VoucheredUnits"];
            this.VoucheredAmount = _data["VoucheredAmount"];
            this.VoucheredSMAmount = _data["VoucheredSMAmount"];
            this.VoucheredRetention = _data["VoucheredRetention"];
            this.VoucheredSMRetention = _data["VoucheredSMRetention"];
            this.PRInProgressQuantity = _data["PRInProgressQuantity"];
            this.PRInProgressRetention = _data["PRInProgressRetention"];
            this.PRInProgressAmount = _data["PRInProgressAmount"];
            this.ReceivedUnits = _data["ReceivedUnits"];
            this.ReceiptInProgressUnits = _data["ReceiptInProgressUnits"];
            this.ContractAmount = _data["ContractAmount"];
            this.ContractUnits = _data["ContractUnits"];
            this.TotalPercentRequest = _data["TotalPercentRequest"];
            this.TotalUnitsCompleted = _data["TotalUnitsCompleted"];
            this.TotalAmountCompleted = _data["TotalAmountCompleted"];
            this.TotalPriorAmount = _data["TotalPriorAmount"];
            this.ProjEntity = _data["ProjEntity"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.AccountCategory = _data["AccountCategory"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.ItemPercent = _data["ItemPercent"];
            this.Rate = _data["Rate"];
            this.LineDesc = _data["LineDesc"];
            this.Cap = _data["Cap"];
            this.UOM = _data["UOM"];
        }
    }

    static fromJS(data: any): RelatedItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["Subcontract"] = this.Subcontract;
        data["SCDocItemKey"] = this.SCDocItemKey;
        data["ApprovedQuantity"] = this.ApprovedQuantity;
        data["ApprovedRetention"] = this.ApprovedRetention;
        data["ApprovedAmount"] = this.ApprovedAmount;
        data["ApprovedExpense"] = this.ApprovedExpense;
        data["PendingChangeUnits"] = this.PendingChangeUnits;
        data["PendingChangeRetention"] = this.PendingChangeRetention;
        data["PendingChangeAmount"] = this.PendingChangeAmount;
        data["PendingChangeExpense"] = this.PendingChangeExpense;
        data["VoucheredUnits"] = this.VoucheredUnits;
        data["VoucheredAmount"] = this.VoucheredAmount;
        data["VoucheredSMAmount"] = this.VoucheredSMAmount;
        data["VoucheredRetention"] = this.VoucheredRetention;
        data["VoucheredSMRetention"] = this.VoucheredSMRetention;
        data["PRInProgressQuantity"] = this.PRInProgressQuantity;
        data["PRInProgressRetention"] = this.PRInProgressRetention;
        data["PRInProgressAmount"] = this.PRInProgressAmount;
        data["ReceivedUnits"] = this.ReceivedUnits;
        data["ReceiptInProgressUnits"] = this.ReceiptInProgressUnits;
        data["ContractAmount"] = this.ContractAmount;
        data["ContractUnits"] = this.ContractUnits;
        data["TotalPercentRequest"] = this.TotalPercentRequest;
        data["TotalUnitsCompleted"] = this.TotalUnitsCompleted;
        data["TotalAmountCompleted"] = this.TotalAmountCompleted;
        data["TotalPriorAmount"] = this.TotalPriorAmount;
        data["ProjEntity"] = this.ProjEntity;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["AccountCategory"] = this.AccountCategory;
        data["RetentionMethod"] = this.RetentionMethod;
        data["ItemPercent"] = this.ItemPercent;
        data["Rate"] = this.Rate;
        data["LineDesc"] = this.LineDesc;
        data["Cap"] = this.Cap;
        data["UOM"] = this.UOM;
        return data; 
    }

    clone(): RelatedItemDetail {
        const json = this.toJSON();
        let result = new RelatedItemDetail();
        result.init(json);
        return result;
    }
}

/** Describes an SPRLineDetails Condition */
export interface IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity: number;
    /** Approved Retention  */
    ApprovedRetention: number;
    /** Change Order Approved  */
    ApprovedAmount: number;
    /** Change Order Approved  */
    ApprovedExpense: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits: number;
    /** not yet approved */
    PendingChangeRetention: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount: number;
    /** not yet approved */
    PendingChangeExpense: number;
    /** Paid Units */
    VoucheredUnits: number;
    /** Paid Amount */
    VoucheredAmount: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount: number;
    /** Amount Earned but held as retention */
    VoucheredRetention: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount: number;
    /** Units received */
    ReceivedUnits: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount: number;
    /** Units on line, includes change orders */
    ContractUnits: number;
    /** Percent */
    TotalPercentRequest: number;
    /** Units */
    TotalUnitsCompleted: number;
    /** Amount */
    TotalAmountCompleted: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent: number;
    Rate: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
}

/** Describes a sequenced recipient in a document route */
export class DocRoute implements IDocRoute {
    /** associates the row with a specific doc route */
    RouteID!: string;
    /** Link to user/contact */
    UserKey!: string;
    /** When true, the user is inactive */
    UserKey_Inactive!: boolean;
    /** Initialized to current stage when added */
    Stage!: number;
    /** Display sequence (by name withing sequence) */
    Sequence!: number;
    /** Parallel Route Group ID */
    GroupNo!: number;
    /** Links to the user/contact that added this route */
    FromUser!: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit!: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts!: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo!: boolean;
    /** Name of Person email routes are sent on-behalf-of (output only) */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route receipient  */
    Request?: string | undefined;
    /** Free form response to route receipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    RouteeProxy!: string;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil!: Date;
    /** When 1, no notification emails are sent */
    PriorityOver!: number;
    ExpectProxy!: boolean;
    HasContent!: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal!: boolean;
    /** associates the row with a doc route sequence */
    RouteStepKey!: string;
    /** When this route was reached (estimated) */
    Reached!: Date;
    /** Identifies the user that added the route  */
    ByUser!: string;
    /** The transmittal control number */
    TransNumber!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** If transmital has data */
    HasBinData!: boolean;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RouteID = _data["RouteID"];
            this.UserKey = _data["UserKey"];
            this.UserKey_Inactive = _data["UserKey_Inactive"];
            this.Stage = _data["Stage"];
            this.Sequence = _data["Sequence"];
            this.GroupNo = _data["GroupNo"];
            this.FromUser = _data["FromUser"];
            this.Status = _data["Status"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(Suggestion.fromJS(item));
            }
            this.RouteVia = _data["RouteVia"];
            if (Array.isArray(_data["RouteViaChoices"])) {
                this.RouteViaChoices = [] as any;
                for (let item of _data["RouteViaChoices"])
                    this.RouteViaChoices!.push(Suggestion.fromJS(item));
            }
            this.UserDocEdit = _data["UserDocEdit"];
            this.SendAlerts = _data["SendAlerts"];
            this.ReplyTo = _data["ReplyTo"];
            this.EmailFrom = _data["EmailFrom"];
            this.Note = _data["Note"];
            this.Request = _data["Request"];
            this.Response = _data["Response"];
            this.ResponseCode = _data["ResponseCode"];
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(Suggestion.fromJS(item));
            }
            this.WorkflowScript = _data["WorkflowScript"];
            this.Alerted = _data["Alerted"] ? new Date(_data["Alerted"].toString()) : <any>undefined;
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Downloaded = _data["Downloaded"] ? new Date(_data["Downloaded"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Acted = _data["Acted"] ? new Date(_data["Acted"].toString()) : <any>undefined;
            this.UserName = _data["UserName"];
            this.Activity = _data["Activity"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.PriorityOver = _data["PriorityOver"];
            this.ExpectProxy = _data["ExpectProxy"];
            this.HasContent = _data["HasContent"];
            this.IsInternal = _data["IsInternal"];
            this.RouteStepKey = _data["RouteStepKey"];
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.ByUser = _data["ByUser"];
            this.TransNumber = _data["TransNumber"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.TransStatus = _data["TransStatus"];
            this.BinType = _data["BinType"];
            this.HasBinData = _data["HasBinData"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocRoute {
        data = typeof data === 'object' ? data : {};
        let result = new DocRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RouteID"] = this.RouteID;
        data["UserKey"] = this.UserKey;
        data["UserKey_Inactive"] = this.UserKey_Inactive;
        data["Stage"] = this.Stage;
        data["Sequence"] = this.Sequence;
        data["GroupNo"] = this.GroupNo;
        data["FromUser"] = this.FromUser;
        data["Status"] = this.Status;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        data["RouteVia"] = this.RouteVia;
        if (Array.isArray(this.RouteViaChoices)) {
            data["RouteViaChoices"] = [];
            for (let item of this.RouteViaChoices)
                data["RouteViaChoices"].push(item.toJSON());
        }
        data["UserDocEdit"] = this.UserDocEdit;
        data["SendAlerts"] = this.SendAlerts;
        data["ReplyTo"] = this.ReplyTo;
        data["EmailFrom"] = this.EmailFrom;
        data["Note"] = this.Note;
        data["Request"] = this.Request;
        data["Response"] = this.Response;
        data["ResponseCode"] = this.ResponseCode;
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        data["WorkflowScript"] = this.WorkflowScript;
        data["Alerted"] = this.Alerted ? this.Alerted.toISOString() : <any>undefined;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Downloaded"] = this.Downloaded ? this.Downloaded.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Acted"] = this.Acted ? this.Acted.toISOString() : <any>undefined;
        data["UserName"] = this.UserName;
        data["Activity"] = this.Activity;
        data["RouteeProxy"] = this.RouteeProxy;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["PriorityOver"] = this.PriorityOver;
        data["ExpectProxy"] = this.ExpectProxy;
        data["HasContent"] = this.HasContent;
        data["IsInternal"] = this.IsInternal;
        data["RouteStepKey"] = this.RouteStepKey;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["ByUser"] = this.ByUser;
        data["TransNumber"] = this.TransNumber;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["TransStatus"] = this.TransStatus;
        data["BinType"] = this.BinType;
        data["HasBinData"] = this.HasBinData;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DocRoute {
        const json = this.toJSON();
        let result = new DocRoute();
        result.init(json);
        return result;
    }
}

/** Describes a sequenced recipient in a document route */
export interface IDocRoute {
    /** associates the row with a specific doc route */
    RouteID: string;
    /** Link to user/contact */
    UserKey: string;
    /** When true, the user is inactive */
    UserKey_Inactive: boolean;
    /** Initialized to current stage when added */
    Stage: number;
    /** Display sequence (by name withing sequence) */
    Sequence: number;
    /** Parallel Route Group ID */
    GroupNo: number;
    /** Links to the user/contact that added this route */
    FromUser: string;
    /** Status code */
    Status?: string | undefined;
    /** list of choices for Status */
    StatusChoices?: Suggestion[] | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo: boolean;
    /** Name of Person email routes are sent on-behalf-of (output only) */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route receipient  */
    Request?: string | undefined;
    /** Free form response to route receipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    RouteeProxy: string;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil: Date;
    /** When 1, no notification emails are sent */
    PriorityOver: number;
    ExpectProxy: boolean;
    HasContent: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal: boolean;
    /** associates the row with a doc route sequence */
    RouteStepKey: string;
    /** When this route was reached (estimated) */
    Reached: Date;
    /** Identifies the user that added the route  */
    ByUser: string;
    /** The transmittal control number */
    TransNumber: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** If transmital has data */
    HasBinData: boolean;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Describes a Date (start and finish) on a document */
export class DocDate implements IDocDate {
    /** Key of row */
    DocDateRowKey!: string;
    /** Key of date type */
    DocDateTypeKey!: string;
    /** Display sequence (by name within sequence) */
    Sequence!: number;
    /** Date type requests start  */
    IncludeStart!: boolean;
    /** Date type requests finish */
    IncludeFinish!: boolean;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired!: boolean;
    /** Default lead time in days */
    LeadTime!: number;
    /** When start is anticipated */
    SchedStart?: Date | undefined;
    /** When finish is anticipated */
    SchedFinish?: Date | undefined;
    /** When actually started */
    ActStart?: Date | undefined;
    /** When Actually finished */
    ActFinish?: Date | undefined;
    /** The whole number of days between ActStart and ActFinish; read only. */
    DaysBetween!: number;
    /** Free form */
    Note?: string | undefined;
    /** When true, this date is "done" */
    IsDone!: boolean;
    /** Amount, for custom use */
    csAmount!: number;
    /** for custom use */
    csValue!: number;
    /** for custom use */
    csQty!: number;
    /** for custom use */
    csNumber!: number;
    /** for custom use */
    csCheck!: boolean;
    /** for custom use */
    csFlag!: boolean;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csContactKey!: string;
    /** for custom use */
    csKey!: string;
    /** date, for custom use */
    csDate?: Date | undefined;
    /** for custom use */
    csWhen?: Date | undefined;

    constructor(data?: IDocDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocDateRowKey = _data["DocDateRowKey"];
            this.DocDateTypeKey = _data["DocDateTypeKey"];
            this.Sequence = _data["Sequence"];
            this.IncludeStart = _data["IncludeStart"];
            this.IncludeFinish = _data["IncludeFinish"];
            this.IsRequired = _data["IsRequired"];
            this.LeadTime = _data["LeadTime"];
            this.SchedStart = _data["SchedStart"] ? new Date(_data["SchedStart"].toString()) : <any>undefined;
            this.SchedFinish = _data["SchedFinish"] ? new Date(_data["SchedFinish"].toString()) : <any>undefined;
            this.ActStart = _data["ActStart"] ? new Date(_data["ActStart"].toString()) : <any>undefined;
            this.ActFinish = _data["ActFinish"] ? new Date(_data["ActFinish"].toString()) : <any>undefined;
            this.DaysBetween = _data["DaysBetween"];
            this.Note = _data["Note"];
            this.IsDone = _data["IsDone"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocDate {
        data = typeof data === 'object' ? data : {};
        let result = new DocDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocDateRowKey"] = this.DocDateRowKey;
        data["DocDateTypeKey"] = this.DocDateTypeKey;
        data["Sequence"] = this.Sequence;
        data["IncludeStart"] = this.IncludeStart;
        data["IncludeFinish"] = this.IncludeFinish;
        data["IsRequired"] = this.IsRequired;
        data["LeadTime"] = this.LeadTime;
        data["SchedStart"] = this.SchedStart ? this.SchedStart.toISOString() : <any>undefined;
        data["SchedFinish"] = this.SchedFinish ? this.SchedFinish.toISOString() : <any>undefined;
        data["ActStart"] = this.ActStart ? this.ActStart.toISOString() : <any>undefined;
        data["ActFinish"] = this.ActFinish ? this.ActFinish.toISOString() : <any>undefined;
        data["DaysBetween"] = this.DaysBetween;
        data["Note"] = this.Note;
        data["IsDone"] = this.IsDone;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocDate {
        const json = this.toJSON();
        let result = new DocDate();
        result.init(json);
        return result;
    }
}

/** Describes a Date (start and finish) on a document */
export interface IDocDate {
    /** Key of row */
    DocDateRowKey: string;
    /** Key of date type */
    DocDateTypeKey: string;
    /** Display sequence (by name within sequence) */
    Sequence: number;
    /** Date type requests start  */
    IncludeStart: boolean;
    /** Date type requests finish */
    IncludeFinish: boolean;
    /** When true, this date type is automatically added to any document to which it applies */
    IsRequired: boolean;
    /** Default lead time in days */
    LeadTime: number;
    /** When start is anticipated */
    SchedStart?: Date | undefined;
    /** When finish is anticipated */
    SchedFinish?: Date | undefined;
    /** When actually started */
    ActStart?: Date | undefined;
    /** When Actually finished */
    ActFinish?: Date | undefined;
    /** The whole number of days between ActStart and ActFinish; read only. */
    DaysBetween: number;
    /** Free form */
    Note?: string | undefined;
    /** When true, this date is "done" */
    IsDone: boolean;
    /** Amount, for custom use */
    csAmount: number;
    /** for custom use */
    csValue: number;
    /** for custom use */
    csQty: number;
    /** for custom use */
    csNumber: number;
    /** for custom use */
    csCheck: boolean;
    /** for custom use */
    csFlag: boolean;
    /** for custom use */
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    /** for custom use */
    csContactKey: string;
    /** for custom use */
    csKey: string;
    /** date, for custom use */
    csDate?: Date | undefined;
    /** for custom use */
    csWhen?: Date | undefined;
}

/** Summary of Project Process (Document) types */
export class TypeSummary implements ITypeSummary {
    /** Key for Process Type */
    DocTypeKey!: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open!: number;
    /** Number of documents closed */
    cnt_closed!: number;
    /** Number of documents overdue */
    cnt_overdue!: number;
    /** Number of documents due soon */
    cnt_DueSoon!: number;
    /** Number of days tile due */
    DaysTillDue!: number;
    /** User has permission to create  */
    CanAdd!: boolean;

    constructor(data?: ITypeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.cnt_open = _data["cnt_open"];
            this.cnt_closed = _data["cnt_closed"];
            this.cnt_overdue = _data["cnt_overdue"];
            this.cnt_DueSoon = _data["cnt_DueSoon"];
            this.DaysTillDue = _data["DaysTillDue"];
            this.CanAdd = _data["CanAdd"];
        }
    }

    static fromJS(data: any): TypeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new TypeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["cnt_open"] = this.cnt_open;
        data["cnt_closed"] = this.cnt_closed;
        data["cnt_overdue"] = this.cnt_overdue;
        data["cnt_DueSoon"] = this.cnt_DueSoon;
        data["DaysTillDue"] = this.DaysTillDue;
        data["CanAdd"] = this.CanAdd;
        return data; 
    }

    clone(): TypeSummary {
        const json = this.toJSON();
        let result = new TypeSummary();
        result.init(json);
        return result;
    }
}

/** Summary of Project Process (Document) types */
export interface ITypeSummary {
    /** Key for Process Type */
    DocTypeKey: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open: number;
    /** Number of documents closed */
    cnt_closed: number;
    /** Number of documents overdue */
    cnt_overdue: number;
    /** Number of documents due soon */
    cnt_DueSoon: number;
    /** Number of days tile due */
    DaysTillDue: number;
    /** User has permission to create  */
    CanAdd: boolean;
}

/** Process Document on a Project */
export class ProjectDocsOfType implements IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey!: string;
    /** Type of Process */
    DocTypeKey!: string;
    /** Key to Process Reference */
    DocReference!: string;
    /** Document Date (header) */
    DocDate!: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority!: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential!: boolean;
    /** Key to Contact document was "from") */
    FromUser!: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty!: string;
    /** Resolved name of Responsible Party */
    ResponsibleParty_dv?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company!: string;
    /** Resolved Company Name  of the source Contact  */
    Company_dv?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** When the document/process is due */
    Due?: Date | undefined;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** check this */
    SpecSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved Subtype description */
    Subtype_dv?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact!: number;
    /** Custome Amount */
    csAmount!: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Specification (document header) */
    Specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact!: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq!: number;
    /** Number of stages of routing  */
    MaxStage!: number;
    /** How many files are attached */
    FilesAttached!: number;

    constructor(data?: IProjectDocsOfType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.Title = _data["Title"];
            this.Priority = _data["Priority"];
            this.Confidential = _data["Confidential"];
            this.FromUser = _data["FromUser"];
            this.SortFrom = _data["SortFrom"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.ResponsibleParty_dv = _data["ResponsibleParty_dv"];
            this.Company = _data["Company"];
            this.Company_dv = _data["Company_dv"];
            this.ToUser = _data["ToUser"];
            this.SortTo = _data["SortTo"];
            this.Author = _data["Author"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Project = _data["Project"];
            this.SpecSection = _data["SpecSection"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.Subtype = _data["Subtype"];
            this.Subtype_dv = _data["Subtype_dv"];
            this.Status = _data["Status"];
            this.CostImpact = _data["CostImpact"];
            this.csAmount = _data["csAmount"];
            this.Subsegment = _data["Subsegment"];
            this.ContractType = _data["ContractType"];
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.PayItemNumber = _data["PayItemNumber"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.Specification = _data["Specification"];
            this.SourceContact = _data["SourceContact"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.MaxStage = _data["MaxStage"];
            this.FilesAttached = _data["FilesAttached"];
        }
    }

    static fromJS(data: any): ProjectDocsOfType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDocsOfType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["Title"] = this.Title;
        data["Priority"] = this.Priority;
        data["Confidential"] = this.Confidential;
        data["FromUser"] = this.FromUser;
        data["SortFrom"] = this.SortFrom;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["ResponsibleParty_dv"] = this.ResponsibleParty_dv;
        data["Company"] = this.Company;
        data["Company_dv"] = this.Company_dv;
        data["ToUser"] = this.ToUser;
        data["SortTo"] = this.SortTo;
        data["Author"] = this.Author;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Project"] = this.Project;
        data["SpecSection"] = this.SpecSection;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["Subtype"] = this.Subtype;
        data["Subtype_dv"] = this.Subtype_dv;
        data["Status"] = this.Status;
        data["CostImpact"] = this.CostImpact;
        data["csAmount"] = this.csAmount;
        data["Subsegment"] = this.Subsegment;
        data["ContractType"] = this.ContractType;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["PayItemNumber"] = this.PayItemNumber;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["Specification"] = this.Specification;
        data["SourceContact"] = this.SourceContact;
        data["CurrentSeq"] = this.CurrentSeq;
        data["MaxStage"] = this.MaxStage;
        data["FilesAttached"] = this.FilesAttached;
        return data; 
    }

    clone(): ProjectDocsOfType {
        const json = this.toJSON();
        let result = new ProjectDocsOfType();
        result.init(json);
        return result;
    }
}

/** Process Document on a Project */
export interface IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey: string;
    /** Type of Process */
    DocTypeKey: string;
    /** Key to Process Reference */
    DocReference: string;
    /** Document Date (header) */
    DocDate: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential: boolean;
    /** Key to Contact document was "from") */
    FromUser: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty: string;
    /** Resolved name of Responsible Party */
    ResponsibleParty_dv?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company: string;
    /** Resolved Company Name  of the source Contact  */
    Company_dv?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** When the document/process is due */
    Due?: Date | undefined;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** check this */
    SpecSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved Subtype description */
    Subtype_dv?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact: number;
    /** Custome Amount */
    csAmount: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Specification (document header) */
    Specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq: number;
    /** Number of stages of routing  */
    MaxStage: number;
    /** How many files are attached */
    FilesAttached: number;
}

/** Various common filters - not every filter is supported by every query */
export class QueryFilters implements IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
    /** Default is false */
    NewOnly!: boolean;
    /** Default is false */
    IncludeHidden!: boolean;
    DependsOn?: string[] | undefined;
    /** seed */
    MatchingSeed?: string | undefined;
    /** max number of results */
    ResultLimit!: number;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;

    constructor(data?: IQueryFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ProjectLike = _data["ProjectLike"];
            this.TitleLike = _data["TitleLike"];
            this.UserKey = _data["UserKey"];
            this.ForDocType = _data["ForDocType"];
            this.ProgramKey = _data["ProgramKey"];
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
            this.NewOnly = _data["NewOnly"];
            this.IncludeHidden = _data["IncludeHidden"];
            if (Array.isArray(_data["DependsOn"])) {
                this.DependsOn = [] as any;
                for (let item of _data["DependsOn"])
                    this.DependsOn!.push(item);
            }
            this.MatchingSeed = _data["MatchingSeed"];
            this.ResultLimit = _data["ResultLimit"];
            this.nvpFilters = _data["nvpFilters"];
        }
    }

    static fromJS(data: any): QueryFilters {
        data = typeof data === 'object' ? data : {};
        let result = new QueryFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectLike"] = this.ProjectLike;
        data["TitleLike"] = this.TitleLike;
        data["UserKey"] = this.UserKey;
        data["ForDocType"] = this.ForDocType;
        data["ProgramKey"] = this.ProgramKey;
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        data["NewOnly"] = this.NewOnly;
        data["IncludeHidden"] = this.IncludeHidden;
        if (Array.isArray(this.DependsOn)) {
            data["DependsOn"] = [];
            for (let item of this.DependsOn)
                data["DependsOn"].push(item);
        }
        data["MatchingSeed"] = this.MatchingSeed;
        data["ResultLimit"] = this.ResultLimit;
        data["nvpFilters"] = this.nvpFilters;
        return data; 
    }

    clone(): QueryFilters {
        const json = this.toJSON();
        let result = new QueryFilters();
        result.init(json);
        return result;
    }
}

/** Various common filters - not every filter is supported by every query */
export interface IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
    /** Default is false */
    NewOnly: boolean;
    /** Default is false */
    IncludeHidden: boolean;
    DependsOn?: string[] | undefined;
    /** seed */
    MatchingSeed?: string | undefined;
    /** max number of results */
    ResultLimit: number;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;
}

/** Returns data rows in three collections */
export class DataDifferential implements IDataDifferential {
    /** Collection of rows added (process last) */
    Add?: any[] | undefined;
    /** Collection of rows with new etags (replace) */
    Change?: any[] | undefined;
    /** Collection of keys removed (process first) */
    Remove?: string[] | undefined;

    constructor(data?: IDataDifferential) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Add"])) {
                this.Add = [] as any;
                for (let item of _data["Add"])
                    this.Add!.push(item);
            }
            if (Array.isArray(_data["Change"])) {
                this.Change = [] as any;
                for (let item of _data["Change"])
                    this.Change!.push(item);
            }
            if (Array.isArray(_data["Remove"])) {
                this.Remove = [] as any;
                for (let item of _data["Remove"])
                    this.Remove!.push(item);
            }
        }
    }

    static fromJS(data: any): DataDifferential {
        data = typeof data === 'object' ? data : {};
        let result = new DataDifferential();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.Add)) {
            data["Add"] = [];
            for (let item of this.Add)
                data["Add"].push(item);
        }
        if (Array.isArray(this.Change)) {
            data["Change"] = [];
            for (let item of this.Change)
                data["Change"].push(item);
        }
        if (Array.isArray(this.Remove)) {
            data["Remove"] = [];
            for (let item of this.Remove)
                data["Remove"].push(item);
        }
        return data; 
    }

    clone(): DataDifferential {
        const json = this.toJSON();
        let result = new DataDifferential();
        result.init(json);
        return result;
    }
}

/** Returns data rows in three collections */
export interface IDataDifferential {
    /** Collection of rows added (process last) */
    Add?: any[] | undefined;
    /** Collection of rows with new etags (replace) */
    Change?: any[] | undefined;
    /** Collection of keys removed (process first) */
    Remove?: string[] | undefined;
}

/** Key Value pairs of Keys and ETags */
export class CurrentDataSummary implements ICurrentDataSummary {
    /** Key of Row/object */
    RowKey!: string;
    /** ETag of Row/object  */
    ETag!: string;

    constructor(data?: ICurrentDataSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.ETag = _data["ETag"];
        }
    }

    static fromJS(data: any): CurrentDataSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentDataSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["ETag"] = this.ETag;
        return data; 
    }

    clone(): CurrentDataSummary {
        const json = this.toJSON();
        let result = new CurrentDataSummary();
        result.init(json);
        return result;
    }
}

/** Key Value pairs of Keys and ETags */
export interface ICurrentDataSummary {
    /** Key of Row/object */
    RowKey: string;
    /** ETag of Row/object  */
    ETag: string;
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export class CodeChoice implements ICodeChoice {
    /** Name for a set of choices */
    SetName!: string;
    /** Code */
    Code!: string;
    /** Display Value  */
    Description!: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active!: boolean;
    /** True if code is allowed for new records */
    OnAdd!: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag!: boolean;

    constructor(data?: ICodeChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.SetName = _data["SetName"];
            this.Code = _data["Code"];
            this.Description = _data["Description"];
            this.NextSet = _data["NextSet"];
            this.Active = _data["Active"];
            this.OnAdd = _data["OnAdd"];
            this.CodeFlag = _data["CodeFlag"];
        }
    }

    static fromJS(data: any): CodeChoice {
        data = typeof data === 'object' ? data : {};
        let result = new CodeChoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SetName"] = this.SetName;
        data["Code"] = this.Code;
        data["Description"] = this.Description;
        data["NextSet"] = this.NextSet;
        data["Active"] = this.Active;
        data["OnAdd"] = this.OnAdd;
        data["CodeFlag"] = this.CodeFlag;
        return data; 
    }

    clone(): CodeChoice {
        const json = this.toJSON();
        let result = new CodeChoice();
        result.init(json);
        return result;
    }
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export interface ICodeChoice {
    /** Name for a set of choices */
    SetName: string;
    /** Code */
    Code: string;
    /** Display Value  */
    Description: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active: boolean;
    /** True if code is allowed for new records */
    OnAdd: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag: boolean;
}

/** Describes an Alert Condition */
export class UserAlert implements IUserAlert {
    /** Key for Alert */
    AlertKey!: string;
    /** Key for User for whom the alert was generated */
    UserKey!: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created!: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Document about which the alert was generated */
    DocMasterKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** When action is due */
    Due!: Date;
    /** Files attached to document */
    FilesAttached!: number;
    /** Document Display Value (Typically Title) */
    DocMasterKey_dv?: string | undefined;
    /** For Email Notification Type, when was the email sent */
    Notified!: Date;
    /** When was the alert viewed */
    Viewed!: Date;
    /** When closed (from document) */
    Closed!: Date;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert!: boolean;

    constructor(data?: IUserAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AlertKey = _data["AlertKey"];
            this.UserKey = _data["UserKey"];
            this.Status = _data["Status"];
            this.NotificationType = _data["NotificationType"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.Description = _data["Description"];
            this.AlertText = _data["AlertText"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.Project = _data["Project"];
            this.Source = _data["Source"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.FilesAttached = _data["FilesAttached"];
            this.DocMasterKey_dv = _data["DocMasterKey_dv"];
            this.Notified = _data["Notified"] ? new Date(_data["Notified"].toString()) : <any>undefined;
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Project_dv = _data["Project_dv"];
            this.SourceKey = _data["SourceKey"];
            this.Info1 = _data["Info1"];
            this.Info2 = _data["Info2"];
            this.MsgType = _data["MsgType"];
            this.MsgKey = _data["MsgKey"];
            this.MsgSuffix = _data["MsgSuffix"];
            this.SIVAlert = _data["SIVAlert"];
        }
    }

    static fromJS(data: any): UserAlert {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AlertKey"] = this.AlertKey;
        data["UserKey"] = this.UserKey;
        data["Status"] = this.Status;
        data["NotificationType"] = this.NotificationType;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["Description"] = this.Description;
        data["AlertText"] = this.AlertText;
        data["DocMasterKey"] = this.DocMasterKey;
        data["Project"] = this.Project;
        data["Source"] = this.Source;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["FilesAttached"] = this.FilesAttached;
        data["DocMasterKey_dv"] = this.DocMasterKey_dv;
        data["Notified"] = this.Notified ? this.Notified.toISOString() : <any>undefined;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Project_dv"] = this.Project_dv;
        data["SourceKey"] = this.SourceKey;
        data["Info1"] = this.Info1;
        data["Info2"] = this.Info2;
        data["MsgType"] = this.MsgType;
        data["MsgKey"] = this.MsgKey;
        data["MsgSuffix"] = this.MsgSuffix;
        data["SIVAlert"] = this.SIVAlert;
        return data; 
    }

    clone(): UserAlert {
        const json = this.toJSON();
        let result = new UserAlert();
        result.init(json);
        return result;
    }
}

/** Describes an Alert Condition */
export interface IUserAlert {
    /** Key for Alert */
    AlertKey: string;
    /** Key for User for whom the alert was generated */
    UserKey: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Document about which the alert was generated */
    DocMasterKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** When action is due */
    Due: Date;
    /** Files attached to document */
    FilesAttached: number;
    /** Document Display Value (Typically Title) */
    DocMasterKey_dv?: string | undefined;
    /** For Email Notification Type, when was the email sent */
    Notified: Date;
    /** When was the alert viewed */
    Viewed: Date;
    /** When closed (from document) */
    Closed: Date;
    /** Project Display Value */
    Project_dv?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert: boolean;
}

/** Attributes describing a member of a project team */
export class ProjectTeamMember implements IProjectTeamMember {
    /** Primary Key */
    UserProjectKey!: string;
    /** Key of Team Member in contact table */
    UserKey!: string;
    /** Login name of the team member  (see UserName below) */
    UserKey_dv?: string | undefined;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserKey_IsInactive!: boolean;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility!: string;
    /** Role Name (see Responsibility) */
    Responsibility_dv?: string | undefined;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Phone   */
    Phone?: string | undefined;
    /** Cell/Mobile Phone   */
    Cell?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Familiar Name (Nick for Nicholas, Liz for Elizabeth)  */
    FamiliarName?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting?: Date | undefined;
    /** When the team member left (or was replaced) */
    Ending?: Date | undefined;
    /** When TRUE,  shown by default */
    TeamList!: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic!: boolean;
    /** When TRUE, this team member is active */
    Active!: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic!: boolean;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IProjectTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserProjectKey = _data["UserProjectKey"];
            this.UserKey = _data["UserKey"];
            this.UserKey_dv = _data["UserKey_dv"];
            this.UserKey_IsInactive = _data["UserKey_IsInactive"];
            this.Responsibility = _data["Responsibility"];
            this.Responsibility_dv = _data["Responsibility_dv"];
            this.UserName = _data["UserName"];
            this.Company = _data["Company"];
            this.email = _data["email"];
            this.UsePhone = _data["UsePhone"];
            this.Phone = _data["Phone"];
            this.Cell = _data["Cell"];
            this.ContactProject = _data["ContactProject"];
            this.FamiliarName = _data["FamiliarName"];
            this.RoleDescription = _data["RoleDescription"];
            this.LikenessURL = _data["LikenessURL"];
            this.WebURL = _data["WebURL"];
            this.Starting = _data["Starting"] ? new Date(_data["Starting"].toString()) : <any>undefined;
            this.Ending = _data["Ending"] ? new Date(_data["Ending"].toString()) : <any>undefined;
            this.TeamList = _data["TeamList"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.UserNotPublic = _data["UserNotPublic"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTeamMember {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserProjectKey"] = this.UserProjectKey;
        data["UserKey"] = this.UserKey;
        data["UserKey_dv"] = this.UserKey_dv;
        data["UserKey_IsInactive"] = this.UserKey_IsInactive;
        data["Responsibility"] = this.Responsibility;
        data["Responsibility_dv"] = this.Responsibility_dv;
        data["UserName"] = this.UserName;
        data["Company"] = this.Company;
        data["email"] = this.email;
        data["UsePhone"] = this.UsePhone;
        data["Phone"] = this.Phone;
        data["Cell"] = this.Cell;
        data["ContactProject"] = this.ContactProject;
        data["FamiliarName"] = this.FamiliarName;
        data["RoleDescription"] = this.RoleDescription;
        data["LikenessURL"] = this.LikenessURL;
        data["WebURL"] = this.WebURL;
        data["Starting"] = this.Starting ? this.Starting.toISOString() : <any>undefined;
        data["Ending"] = this.Ending ? this.Ending.toISOString() : <any>undefined;
        data["TeamList"] = this.TeamList;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["UserNotPublic"] = this.UserNotPublic;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectTeamMember {
        const json = this.toJSON();
        let result = new ProjectTeamMember();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface IProjectTeamMember {
    /** Primary Key */
    UserProjectKey: string;
    /** Key of Team Member in contact table */
    UserKey: string;
    /** Login name of the team member  (see UserName below) */
    UserKey_dv?: string | undefined;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserKey_IsInactive: boolean;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility: string;
    /** Role Name (see Responsibility) */
    Responsibility_dv?: string | undefined;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Phone   */
    Phone?: string | undefined;
    /** Cell/Mobile Phone   */
    Cell?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Familiar Name (Nick for Nicholas, Liz for Elizabeth)  */
    FamiliarName?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting?: Date | undefined;
    /** When the team member left (or was replaced) */
    Ending?: Date | undefined;
    /** When TRUE,  shown by default */
    TeamList: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic: boolean;
    /** When TRUE, this team member is active */
    Active: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic: boolean;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Legacy Site Authentication */
export class SiteLogin implements ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed!: boolean;

    constructor(data?: ISiteLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UID = _data["UID"];
            this.PW = _data["PW"];
            this.IsHashed = _data["IsHashed"];
        }
    }

    static fromJS(data: any): SiteLogin {
        data = typeof data === 'object' ? data : {};
        let result = new SiteLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UID"] = this.UID;
        data["PW"] = this.PW;
        data["IsHashed"] = this.IsHashed;
        return data; 
    }

    clone(): SiteLogin {
        const json = this.toJSON();
        let result = new SiteLogin();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed: boolean;
}

/** Attributes describing the currently authenticated user */
export class CurrentUser implements ICurrentUser {
    /** User Key */
    UserKey!: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    PWMustChange!: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset!: number;
    /** Password Aging is enabled for this user */
    PWAging!: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration!: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut!: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun!: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser!: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin!: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey!: string;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** This data is locked in memory */
    IsDSProtected!: boolean;

    constructor(data?: ICurrentUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserLoginName = _data["UserLoginName"];
            this.FullName = _data["FullName"];
            this.email = _data["email"];
            this.PWMustChange = _data["PWMustChange"];
            this.UserTimeZone = _data["UserTimeZone"];
            this.TZOffset = _data["TZOffset"];
            this.PWAging = _data["PWAging"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.IsLockedOut = _data["IsLockedOut"];
            this.PWExpires = _data["PWExpires"] ? new Date(_data["PWExpires"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.LockoutReason = _data["LockoutReason"];
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SolomonUser = _data["SolomonUser"];
            this.IsFirstLogin = _data["IsFirstLogin"];
            this.MasterSession = _data["MasterSession"];
            this.UserSessionKey = _data["UserSessionKey"];
            this.PictureURL = _data["PictureURL"];
            this.PDSKey = _data["PDSKey"];
            this.IsDSProtected = _data["IsDSProtected"];
        }
    }

    static fromJS(data: any): CurrentUser {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserLoginName"] = this.UserLoginName;
        data["FullName"] = this.FullName;
        data["email"] = this.email;
        data["PWMustChange"] = this.PWMustChange;
        data["UserTimeZone"] = this.UserTimeZone;
        data["TZOffset"] = this.TZOffset;
        data["PWAging"] = this.PWAging;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["IsLockedOut"] = this.IsLockedOut;
        data["PWExpires"] = this.PWExpires ? this.PWExpires.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["LockoutReason"] = this.LockoutReason;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SolomonUser"] = this.SolomonUser;
        data["IsFirstLogin"] = this.IsFirstLogin;
        data["MasterSession"] = this.MasterSession;
        data["UserSessionKey"] = this.UserSessionKey;
        data["PictureURL"] = this.PictureURL;
        data["PDSKey"] = this.PDSKey;
        data["IsDSProtected"] = this.IsDSProtected;
        return data; 
    }

    clone(): CurrentUser {
        const json = this.toJSON();
        let result = new CurrentUser();
        result.init(json);
        return result;
    }
}

/** Attributes describing the currently authenticated user */
export interface ICurrentUser {
    /** User Key */
    UserKey: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    PWMustChange: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset: number;
    /** Password Aging is enabled for this user */
    PWAging: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey: string;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** This data is locked in memory */
    IsDSProtected: boolean;
}

export class PasswordConfiguredOptions implements IPasswordConfiguredOptions {
    PWRegex?: string | undefined;
    StrongPWHint?: string | undefined;

    constructor(data?: IPasswordConfiguredOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PWRegex = _data["PWRegex"];
            this.StrongPWHint = _data["StrongPWHint"];
        }
    }

    static fromJS(data: any): PasswordConfiguredOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordConfiguredOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PWRegex"] = this.PWRegex;
        data["StrongPWHint"] = this.StrongPWHint;
        return data; 
    }

    clone(): PasswordConfiguredOptions {
        const json = this.toJSON();
        let result = new PasswordConfiguredOptions();
        result.init(json);
        return result;
    }
}

export interface IPasswordConfiguredOptions {
    PWRegex?: string | undefined;
    StrongPWHint?: string | undefined;
}

/** Describes permission being demanded and the context */
export class PermissionContext implements IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule!: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction!: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey!: string;
    /** Document Type */
    DocTypeKey!: string;
    /** Doc Reference (seldom used) */
    DocReference!: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded!: PermissionFlags;

    constructor(data?: IPermissionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.Project = _data["Project"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.PermissionNeeded = _data["PermissionNeeded"];
        }
    }

    static fromJS(data: any): PermissionContext {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["Project"] = this.Project;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["PermissionNeeded"] = this.PermissionNeeded;
        return data; 
    }

    clone(): PermissionContext {
        const json = this.toJSON();
        let result = new PermissionContext();
        result.init(json);
        return result;
    }
}

/** Describes permission being demanded and the context */
export interface IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey: string;
    /** Document Type */
    DocTypeKey: string;
    /** Doc Reference (seldom used) */
    DocReference: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded: PermissionFlags;
}

/** Summary information about a contact */
export class ContactSummary implements IContactSummary {
    /** Link to user/contact */
    UserKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser!: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags!: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active!: boolean;
    /** When true, there are no references to this contact */
    OkToDelete!: boolean;
    /** When true, this contact came from an external source */
    IsXTS!: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn!: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut!: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary!: boolean;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.SortName = _data["SortName"];
            this.Email = _data["Email"];
            this.UsePhone = _data["UsePhone"];
            this.Fax = _data["Fax"];
            this.sfUser = _data["sfUser"];
            this.ContactType = _data["ContactType"];
            this.ContactFlags = _data["ContactFlags"];
            this.ExternalID = _data["ExternalID"];
            this.Company = _data["Company"];
            this.CSIList = _data["CSIList"];
            this.Active = _data["Active"];
            this.OkToDelete = _data["OkToDelete"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.IsPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["SortName"] = this.SortName;
        data["Email"] = this.Email;
        data["UsePhone"] = this.UsePhone;
        data["Fax"] = this.Fax;
        data["sfUser"] = this.sfUser;
        data["ContactType"] = this.ContactType;
        data["ContactFlags"] = this.ContactFlags;
        data["ExternalID"] = this.ExternalID;
        data["Company"] = this.Company;
        data["CSIList"] = this.CSIList;
        data["Active"] = this.Active;
        data["OkToDelete"] = this.OkToDelete;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["IsPrimary"] = this.IsPrimary;
        return data; 
    }

    clone(): ContactSummary {
        const json = this.toJSON();
        let result = new ContactSummary();
        result.init(json);
        return result;
    }
}

/** Summary information about a contact */
export interface IContactSummary {
    /** Link to user/contact */
    UserKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active: boolean;
    /** When true, there are no references to this contact */
    OkToDelete: boolean;
    /** When true, this contact came from an external source */
    IsXTS: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary: boolean;
}

/** Various filters for contact search */
export class ContactFilters implements IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users!: boolean;
    /** When true, result is limited to  */
    Customers!: boolean;
    /** When true, result is limited to  */
    Employee!: boolean;
    /** When true, result is limited to  */
    Public!: boolean;
    /** When true, result is limited to primary company contacts  */
    Company!: boolean;
    /** When true, result is limited to  */
    Vendors!: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState!: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;

    constructor(data?: IContactFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NameLike = _data["NameLike"];
            this.EmailLike = _data["EmailLike"];
            this.CompanyLike = _data["CompanyLike"];
            this.LocationLike = _data["LocationLike"];
            this.IDLike = _data["IDLike"];
            this.CSIListLike = _data["CSIListLike"];
            this.PhoneLike = _data["PhoneLike"];
            this.Users = _data["Users"];
            this.Customers = _data["Customers"];
            this.Employee = _data["Employee"];
            this.Public = _data["Public"];
            this.Company = _data["Company"];
            this.Vendors = _data["Vendors"];
            this.ContactState = _data["ContactState"];
            this.RoleKey = _data["RoleKey"];
            this.UserKey = _data["UserKey"];
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactFilters {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NameLike"] = this.NameLike;
        data["EmailLike"] = this.EmailLike;
        data["CompanyLike"] = this.CompanyLike;
        data["LocationLike"] = this.LocationLike;
        data["IDLike"] = this.IDLike;
        data["CSIListLike"] = this.CSIListLike;
        data["PhoneLike"] = this.PhoneLike;
        data["Users"] = this.Users;
        data["Customers"] = this.Customers;
        data["Employee"] = this.Employee;
        data["Public"] = this.Public;
        data["Company"] = this.Company;
        data["Vendors"] = this.Vendors;
        data["ContactState"] = this.ContactState;
        data["RoleKey"] = this.RoleKey;
        data["UserKey"] = this.UserKey;
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ContactFilters {
        const json = this.toJSON();
        let result = new ContactFilters();
        result.init(json);
        return result;
    }
}

/** Various filters for contact search */
export interface IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users: boolean;
    /** When true, result is limited to  */
    Customers: boolean;
    /** When true, result is limited to  */
    Employee: boolean;
    /** When true, result is limited to  */
    Public: boolean;
    /** When true, result is limited to primary company contacts  */
    Company: boolean;
    /** When true, result is limited to  */
    Vendors: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
}

/** Describes a contact */
export class Contact implements IContact {
    /** Key for this user/contact */
    UserKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone!: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility!: string;
    /** Key to primary company */
    ContactCompanyKey!: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr!: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects!: boolean;
    /** When True, can log in to dashboard */
    sfUser!: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic!: boolean;
    /** When false, this row is ignored and ineffective */
    Active!: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser!: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration!: boolean;
    /** When TRUE, user must change password */
    PWMustChange!: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging!: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel!: number;
    /** Checksum of all externally syched data */
    SynchCheck!: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun!: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created!: Date;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.FederatedIdentityInfo = _data["FederatedIdentityInfo"];
            this.SortName = _data["SortName"];
            this.FamiliarName = _data["FamiliarName"];
            this.Salutation = _data["Salutation"];
            this.Title = _data["Title"];
            this.Role = _data["Role"];
            this.EMail = _data["EMail"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.cell = _data["cell"];
            this.pager = _data["pager"];
            this.Company = _data["Company"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.Country = _data["Country"];
            this.County = _data["County"];
            this.TimeZone = _data["TimeZone"];
            this.IMService = _data["IMService"];
            this.IMHandle = _data["IMHandle"];
            this.WebURL = _data["WebURL"];
            this.VendorID = _data["VendorID"];
            this.EmployeeID = _data["EmployeeID"];
            this.ContactType = _data["ContactType"];
            this.RouteVia = _data["RouteVia"];
            this.ShowPhone = _data["ShowPhone"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.DefaultResponsibility = _data["DefaultResponsibility"];
            this.ContactCompanyKey = _data["ContactCompanyKey"];
            this.Signature = _data["Signature"];
            this.Likeness = _data["Likeness"];
            this.UseCompanyAddr = _data["UseCompanyAddr"];
            this.ShowNewProjects = _data["ShowNewProjects"];
            this.sfUser = _data["sfUser"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.SolomonUser = _data["SolomonUser"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.PWMustChange = _data["PWMustChange"];
            this.PWAging = _data["PWAging"];
            this.DivisionID = _data["DivisionID"];
            this.LockoutReason = _data["LockoutReason"];
            this.OrgLevel = _data["OrgLevel"];
            this.SynchCheck = _data["SynchCheck"];
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.LastLogin = _data["LastLogin"] ? new Date(_data["LastLogin"].toString()) : <any>undefined;
            this.LastPWChange = _data["LastPWChange"] ? new Date(_data["LastPWChange"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["FederatedIdentityInfo"] = this.FederatedIdentityInfo;
        data["SortName"] = this.SortName;
        data["FamiliarName"] = this.FamiliarName;
        data["Salutation"] = this.Salutation;
        data["Title"] = this.Title;
        data["Role"] = this.Role;
        data["EMail"] = this.EMail;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["cell"] = this.cell;
        data["pager"] = this.pager;
        data["Company"] = this.Company;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["Country"] = this.Country;
        data["County"] = this.County;
        data["TimeZone"] = this.TimeZone;
        data["IMService"] = this.IMService;
        data["IMHandle"] = this.IMHandle;
        data["WebURL"] = this.WebURL;
        data["VendorID"] = this.VendorID;
        data["EmployeeID"] = this.EmployeeID;
        data["ContactType"] = this.ContactType;
        data["RouteVia"] = this.RouteVia;
        data["ShowPhone"] = this.ShowPhone;
        data["RouteeProxy"] = this.RouteeProxy;
        data["DefaultResponsibility"] = this.DefaultResponsibility;
        data["ContactCompanyKey"] = this.ContactCompanyKey;
        data["Signature"] = this.Signature;
        data["Likeness"] = this.Likeness;
        data["UseCompanyAddr"] = this.UseCompanyAddr;
        data["ShowNewProjects"] = this.ShowNewProjects;
        data["sfUser"] = this.sfUser;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["SolomonUser"] = this.SolomonUser;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["PWMustChange"] = this.PWMustChange;
        data["PWAging"] = this.PWAging;
        data["DivisionID"] = this.DivisionID;
        data["LockoutReason"] = this.LockoutReason;
        data["OrgLevel"] = this.OrgLevel;
        data["SynchCheck"] = this.SynchCheck;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["LastLogin"] = this.LastLogin ? this.LastLogin.toISOString() : <any>undefined;
        data["LastPWChange"] = this.LastPWChange ? this.LastPWChange.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

/** Describes a contact */
export interface IContact {
    /** Key for this user/contact */
    UserKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility: string;
    /** Key to primary company */
    ContactCompanyKey: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects: boolean;
    /** When True, can log in to dashboard */
    sfUser: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic: boolean;
    /** When false, this row is ignored and ineffective */
    Active: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration: boolean;
    /** When TRUE, user must change password */
    PWMustChange: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel: number;
    /** Checksum of all externally syched data */
    SynchCheck: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created: Date;
}

/** A document currently routed to a specific user */
export class UserActionItem implements IUserActionItem {
    /** Key for the document */
    DocMasterKey!: string;
    /** key for the route on the document */
    RouteID!: string;
    /** key for the type of document */
    DocTypeKey!: string;
    /** Resolved Name of the document/process type */
    DocType?: string | undefined;
    /** Same as DocType */
    DocTypeKey_dv?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Title */
    Title?: string | undefined;
    /** Same as Title */
    DocMasterKey_dv?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser!: string;
    /** Key for Primary contact on this document */
    PrimaryContact!: string;
    /** Priority (1=high) */
    Priority!: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this route was reaced */
    Reached!: Date;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Display value for Primary Contact  */
    PrimaryContact_dv?: string | undefined;
    /** Current Route Sequence */
    Sequence!: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease!: boolean;
    /** When True, is recent  */
    IsRecent!: boolean;
    /** How many files are attached */
    FilesAttached!: number;
    /** Due Date */
    Due?: Date | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Route Instructions */
    Note?: string | undefined;
    /** Project Name */
    Project_Name?: string | undefined;

    constructor(data?: IUserActionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.RouteID = _data["RouteID"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.DocTypeKey_dv = _data["DocTypeKey_dv"];
            this.Project = _data["Project"];
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Title = _data["Title"];
            this.DocMasterKey_dv = _data["DocMasterKey_dv"];
            this.FromUser = _data["FromUser"];
            this.PrimaryContact = _data["PrimaryContact"];
            this.Priority = _data["Priority"];
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.StatusText = _data["StatusText"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.PrimaryContact_dv = _data["PrimaryContact_dv"];
            this.Sequence = _data["Sequence"];
            this.OkToRelease = _data["OkToRelease"];
            this.IsRecent = _data["IsRecent"];
            this.FilesAttached = _data["FilesAttached"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Note = _data["Note"];
            this.Project_Name = _data["Project_Name"];
        }
    }

    static fromJS(data: any): UserActionItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["RouteID"] = this.RouteID;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["DocTypeKey_dv"] = this.DocTypeKey_dv;
        data["Project"] = this.Project;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Title"] = this.Title;
        data["DocMasterKey_dv"] = this.DocMasterKey_dv;
        data["FromUser"] = this.FromUser;
        data["PrimaryContact"] = this.PrimaryContact;
        data["Priority"] = this.Priority;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["StatusText"] = this.StatusText;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["PrimaryContact_dv"] = this.PrimaryContact_dv;
        data["Sequence"] = this.Sequence;
        data["OkToRelease"] = this.OkToRelease;
        data["IsRecent"] = this.IsRecent;
        data["FilesAttached"] = this.FilesAttached;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Note"] = this.Note;
        data["Project_Name"] = this.Project_Name;
        return data; 
    }

    clone(): UserActionItem {
        const json = this.toJSON();
        let result = new UserActionItem();
        result.init(json);
        return result;
    }
}

/** A document currently routed to a specific user */
export interface IUserActionItem {
    /** Key for the document */
    DocMasterKey: string;
    /** key for the route on the document */
    RouteID: string;
    /** key for the type of document */
    DocTypeKey: string;
    /** Resolved Name of the document/process type */
    DocType?: string | undefined;
    /** Same as DocType */
    DocTypeKey_dv?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Title */
    Title?: string | undefined;
    /** Same as Title */
    DocMasterKey_dv?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser: string;
    /** Key for Primary contact on this document */
    PrimaryContact: string;
    /** Priority (1=high) */
    Priority: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this route was reaced */
    Reached: Date;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Display value for Primary Contact  */
    PrimaryContact_dv?: string | undefined;
    /** Current Route Sequence */
    Sequence: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease: boolean;
    /** When True, is recent  */
    IsRecent: boolean;
    /** How many files are attached */
    FilesAttached: number;
    /** Due Date */
    Due?: Date | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Route Instructions */
    Note?: string | undefined;
    /** Project Name */
    Project_Name?: string | undefined;
}

export class RouteActionInfo implements IRouteActionInfo {
    DocMasterKey!: string;
    UserName?: string | undefined;
    Title?: string | undefined;
    DocNo?: string | undefined;
    Type?: string | undefined;
    Project?: string | undefined;
    Status?: string | undefined;
    Company?: string | undefined;
    Priority!: number;
    Sequence!: number;
    Due?: string | undefined;
    Viewed?: string | undefined;
    Alerted?: string | undefined;
    Downloaded?: string | undefined;
    FromActed?: string | undefined;
    CreatorActed?: string | undefined;
    OkToRelease!: boolean;
    ShowRouteResponseCode!: boolean;
    ShowRouteResponseArea!: boolean;
    HardCopyCount!: number;
    OkToReleaseCount!: number;
    ReleaseMatchCount!: number;
    ResponseCode?: string | undefined;
    Note?: string | undefined;
    Response?: string | undefined;
    Instructions?: string | undefined;
    FromWho?: string | undefined;
    CreatedBy?: string | undefined;
    NextWho?: string | undefined;
    AccessSummary?: string | undefined;
    DocAccessHistoryReportURL?: string | undefined;
    LastSaved?: string | undefined;
    ExclusiveTo?: string | undefined;
    DocTypeKey!: string;
    StatusChoices?: SelectCodeNode[] | undefined;
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    MatchingDocs?: SelectCodeNode[] | undefined;
    EligibleDocs?: SelectCodeNode[] | undefined;

    constructor(data?: IRouteActionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.UserName = _data["UserName"];
            this.Title = _data["Title"];
            this.DocNo = _data["DocNo"];
            this.Type = _data["Type"];
            this.Project = _data["Project"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.Priority = _data["Priority"];
            this.Sequence = _data["Sequence"];
            this.Due = _data["Due"];
            this.Viewed = _data["Viewed"];
            this.Alerted = _data["Alerted"];
            this.Downloaded = _data["Downloaded"];
            this.FromActed = _data["FromActed"];
            this.CreatorActed = _data["CreatorActed"];
            this.OkToRelease = _data["OkToRelease"];
            this.ShowRouteResponseCode = _data["ShowRouteResponseCode"];
            this.ShowRouteResponseArea = _data["ShowRouteResponseArea"];
            this.HardCopyCount = _data["HardCopyCount"];
            this.OkToReleaseCount = _data["OkToReleaseCount"];
            this.ReleaseMatchCount = _data["ReleaseMatchCount"];
            this.ResponseCode = _data["ResponseCode"];
            this.Note = _data["Note"];
            this.Response = _data["Response"];
            this.Instructions = _data["Instructions"];
            this.FromWho = _data["FromWho"];
            this.CreatedBy = _data["CreatedBy"];
            this.NextWho = _data["NextWho"];
            this.AccessSummary = _data["AccessSummary"];
            this.DocAccessHistoryReportURL = _data["DocAccessHistoryReportURL"];
            this.LastSaved = _data["LastSaved"];
            this.ExclusiveTo = _data["ExclusiveTo"];
            this.DocTypeKey = _data["DocTypeKey"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["MatchingDocs"])) {
                this.MatchingDocs = [] as any;
                for (let item of _data["MatchingDocs"])
                    this.MatchingDocs!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["EligibleDocs"])) {
                this.EligibleDocs = [] as any;
                for (let item of _data["EligibleDocs"])
                    this.EligibleDocs!.push(SelectCodeNode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["UserName"] = this.UserName;
        data["Title"] = this.Title;
        data["DocNo"] = this.DocNo;
        data["Type"] = this.Type;
        data["Project"] = this.Project;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["Priority"] = this.Priority;
        data["Sequence"] = this.Sequence;
        data["Due"] = this.Due;
        data["Viewed"] = this.Viewed;
        data["Alerted"] = this.Alerted;
        data["Downloaded"] = this.Downloaded;
        data["FromActed"] = this.FromActed;
        data["CreatorActed"] = this.CreatorActed;
        data["OkToRelease"] = this.OkToRelease;
        data["ShowRouteResponseCode"] = this.ShowRouteResponseCode;
        data["ShowRouteResponseArea"] = this.ShowRouteResponseArea;
        data["HardCopyCount"] = this.HardCopyCount;
        data["OkToReleaseCount"] = this.OkToReleaseCount;
        data["ReleaseMatchCount"] = this.ReleaseMatchCount;
        data["ResponseCode"] = this.ResponseCode;
        data["Note"] = this.Note;
        data["Response"] = this.Response;
        data["Instructions"] = this.Instructions;
        data["FromWho"] = this.FromWho;
        data["CreatedBy"] = this.CreatedBy;
        data["NextWho"] = this.NextWho;
        data["AccessSummary"] = this.AccessSummary;
        data["DocAccessHistoryReportURL"] = this.DocAccessHistoryReportURL;
        data["LastSaved"] = this.LastSaved;
        data["ExclusiveTo"] = this.ExclusiveTo;
        data["DocTypeKey"] = this.DocTypeKey;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.MatchingDocs)) {
            data["MatchingDocs"] = [];
            for (let item of this.MatchingDocs)
                data["MatchingDocs"].push(item.toJSON());
        }
        if (Array.isArray(this.EligibleDocs)) {
            data["EligibleDocs"] = [];
            for (let item of this.EligibleDocs)
                data["EligibleDocs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RouteActionInfo {
        const json = this.toJSON();
        let result = new RouteActionInfo();
        result.init(json);
        return result;
    }
}

export interface IRouteActionInfo {
    DocMasterKey: string;
    UserName?: string | undefined;
    Title?: string | undefined;
    DocNo?: string | undefined;
    Type?: string | undefined;
    Project?: string | undefined;
    Status?: string | undefined;
    Company?: string | undefined;
    Priority: number;
    Sequence: number;
    Due?: string | undefined;
    Viewed?: string | undefined;
    Alerted?: string | undefined;
    Downloaded?: string | undefined;
    FromActed?: string | undefined;
    CreatorActed?: string | undefined;
    OkToRelease: boolean;
    ShowRouteResponseCode: boolean;
    ShowRouteResponseArea: boolean;
    HardCopyCount: number;
    OkToReleaseCount: number;
    ReleaseMatchCount: number;
    ResponseCode?: string | undefined;
    Note?: string | undefined;
    Response?: string | undefined;
    Instructions?: string | undefined;
    FromWho?: string | undefined;
    CreatedBy?: string | undefined;
    NextWho?: string | undefined;
    AccessSummary?: string | undefined;
    DocAccessHistoryReportURL?: string | undefined;
    LastSaved?: string | undefined;
    ExclusiveTo?: string | undefined;
    DocTypeKey: string;
    StatusChoices?: SelectCodeNode[] | undefined;
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    MatchingDocs?: SelectCodeNode[] | undefined;
    EligibleDocs?: SelectCodeNode[] | undefined;
}

export class SelectCodeNode implements ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectCodeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectCodeNode {
        data = typeof data === 'object' ? data : {};
        let result = new SelectCodeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectCodeNode {
        const json = this.toJSON();
        let result = new SelectCodeNode();
        result.init(json);
        return result;
    }
}

export interface ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;
}

/** Data to apply to the route being patched */
export class RouteActionData implements IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;

    constructor(data?: IRouteActionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NewStatus = _data["NewStatus"];
            this.ResponseCode = _data["ResponseCode"];
            this.ResponseText = _data["ResponseText"];
        }
    }

    static fromJS(data: any): RouteActionData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewStatus"] = this.NewStatus;
        data["ResponseCode"] = this.ResponseCode;
        data["ResponseText"] = this.ResponseText;
        return data; 
    }

    clone(): RouteActionData {
        const json = this.toJSON();
        let result = new RouteActionData();
        result.init(json);
        return result;
    }
}

/** Data to apply to the route being patched */
export interface IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;
}

/** Primary Summary */
export class ProjectSummary implements IProjectSummary {
    /** Project ID */
    Project!: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude!: number;
    /** Geo longitude from Project Setup Tab */
    longitude!: number;
    /** Start Date from Project Setup Dates tab */
    StartDate!: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate!: Date;
    /** Key for this user on project team */
    UserProjectKey!: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact!: string;
    /** Key for Image */
    ImageKey!: string;
    /** TRUE if this project is on the user list */
    UserList!: boolean;

    constructor(data?: IProjectSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Description = _data["Description"];
            this.StatusText = _data["StatusText"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.StartDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
            this.FinishDate = _data["FinishDate"] ? new Date(_data["FinishDate"].toString()) : <any>undefined;
            this.UserProjectKey = _data["UserProjectKey"];
            this.SourceContact = _data["SourceContact"];
            this.ImageKey = _data["ImageKey"];
            this.UserList = _data["UserList"];
        }
    }

    static fromJS(data: any): ProjectSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Description"] = this.Description;
        data["StatusText"] = this.StatusText;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["StartDate"] = this.StartDate ? this.StartDate.toISOString() : <any>undefined;
        data["FinishDate"] = this.FinishDate ? this.FinishDate.toISOString() : <any>undefined;
        data["UserProjectKey"] = this.UserProjectKey;
        data["SourceContact"] = this.SourceContact;
        data["ImageKey"] = this.ImageKey;
        data["UserList"] = this.UserList;
        return data; 
    }

    clone(): ProjectSummary {
        const json = this.toJSON();
        let result = new ProjectSummary();
        result.init(json);
        return result;
    }
}

/** Primary Summary */
export interface IProjectSummary {
    /** Project ID */
    Project: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude: number;
    /** Geo longitude from Project Setup Tab */
    longitude: number;
    /** Start Date from Project Setup Dates tab */
    StartDate: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate: Date;
    /** Key for this user on project team */
    UserProjectKey: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact: string;
    /** Key for Image */
    ImageKey: string;
    /** TRUE if this project is on the user list */
    UserList: boolean;
}

/** Primary Site Weather Now */
export class ProjKPIFact implements IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative!: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;

    constructor(data?: IProjKPIFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Column = _data["Column"];
            this.Label = _data["Label"];
            this.Value = _data["Value"];
            this.Action = _data["Action"];
            this.DForm = _data["DForm"];
            this.TForm = _data["TForm"];
            this.Negative = _data["Negative"];
            this.ItemName = _data["ItemName"];
        }
    }

    static fromJS(data: any): ProjKPIFact {
        data = typeof data === 'object' ? data : {};
        let result = new ProjKPIFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Column"] = this.Column;
        data["Label"] = this.Label;
        data["Value"] = this.Value;
        data["Action"] = this.Action;
        data["DForm"] = this.DForm;
        data["TForm"] = this.TForm;
        data["Negative"] = this.Negative;
        data["ItemName"] = this.ItemName;
        return data; 
    }

    clone(): ProjKPIFact {
        const json = this.toJSON();
        let result = new ProjKPIFact();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;
}

/** General abstract information about a BFA document */
export class BFAAbstract implements IBFAAbstract {
    /** Project ID */
    Project!: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** PA, BU, FC */
    BFAMode!: string;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Default for projected (Y/N)  */
    ProjectedDefault?: string | undefined;
    /** Default for forecast threshold */
    ForecastThreshold!: number;
    /** Default Cost Code Description */
    DefaultWBCodeDescription?: string | undefined;
    /** Count of Documents Matching this BFA mode */
    DocumentCount!: number;
    /** Count of Approved Documents matching this BFA mode */
    ApprovedCount!: number;
    /** UpdateMask */
    UpdateMask!: number;
    /** UpdateFlag (L if UpdateMask has bits 1 and 2; U otherwise) */
    UpdateFlag!: string;
    /** key of latest document matching this BFA mode */
    LatestDocumentKey!: string;
    /** Contract Value */
    ContractValue!: number;
    /** Revenue */
    Revenue!: number;
    /** Original Expense Budget Amount */
    OriginalExpenseBudget!: number;
    /** EAC budget amount */
    EACExpenseBudget!: number;

    constructor(data?: IBFAAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.BFAMode = _data["BFAMode"];
            this.SubtypeDescription = _data["SubtypeDescription"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.ProjectIDMask = _data["ProjectIDMask"];
            this.WBCodeMask = _data["WBCodeMask"];
            this.ProjectSegmentSeparator = _data["ProjectSegmentSeparator"];
            this.WBCodeSegmentSeparator = _data["WBCodeSegmentSeparator"];
            this.ProjectedDefault = _data["ProjectedDefault"];
            this.ForecastThreshold = _data["ForecastThreshold"];
            this.DefaultWBCodeDescription = _data["DefaultWBCodeDescription"];
            this.DocumentCount = _data["DocumentCount"];
            this.ApprovedCount = _data["ApprovedCount"];
            this.UpdateMask = _data["UpdateMask"];
            this.UpdateFlag = _data["UpdateFlag"];
            this.LatestDocumentKey = _data["LatestDocumentKey"];
            this.ContractValue = _data["ContractValue"];
            this.Revenue = _data["Revenue"];
            this.OriginalExpenseBudget = _data["OriginalExpenseBudget"];
            this.EACExpenseBudget = _data["EACExpenseBudget"];
        }
    }

    static fromJS(data: any): BFAAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new BFAAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["BFAMode"] = this.BFAMode;
        data["SubtypeDescription"] = this.SubtypeDescription;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["ProjectIDMask"] = this.ProjectIDMask;
        data["WBCodeMask"] = this.WBCodeMask;
        data["ProjectSegmentSeparator"] = this.ProjectSegmentSeparator;
        data["WBCodeSegmentSeparator"] = this.WBCodeSegmentSeparator;
        data["ProjectedDefault"] = this.ProjectedDefault;
        data["ForecastThreshold"] = this.ForecastThreshold;
        data["DefaultWBCodeDescription"] = this.DefaultWBCodeDescription;
        data["DocumentCount"] = this.DocumentCount;
        data["ApprovedCount"] = this.ApprovedCount;
        data["UpdateMask"] = this.UpdateMask;
        data["UpdateFlag"] = this.UpdateFlag;
        data["LatestDocumentKey"] = this.LatestDocumentKey;
        data["ContractValue"] = this.ContractValue;
        data["Revenue"] = this.Revenue;
        data["OriginalExpenseBudget"] = this.OriginalExpenseBudget;
        data["EACExpenseBudget"] = this.EACExpenseBudget;
        return data; 
    }

    clone(): BFAAbstract {
        const json = this.toJSON();
        let result = new BFAAbstract();
        result.init(json);
        return result;
    }
}

/** General abstract information about a BFA document */
export interface IBFAAbstract {
    /** Project ID */
    Project: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** PA, BU, FC */
    BFAMode: string;
    /** Subtype description */
    SubtypeDescription?: string | undefined;
    /** Full name of current user  DescribeValue("sfUser") */
    UserName?: string | undefined;
    /** Full UserLogin of current user    */
    UserLogin?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "PROJECT") */
    ProjectIDMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeyMask", "TASK") */
    WBCodeMask?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "PROJECT") */
    ProjectSegmentSeparator?: string | undefined;
    /** Flex Key mask for projects DescribeValue("FlexKeySeparator", "TASK") */
    WBCodeSegmentSeparator?: string | undefined;
    /** Default for projected (Y/N)  */
    ProjectedDefault?: string | undefined;
    /** Default for forecast threshold */
    ForecastThreshold: number;
    /** Default Cost Code Description */
    DefaultWBCodeDescription?: string | undefined;
    /** Count of Documents Matching this BFA mode */
    DocumentCount: number;
    /** Count of Approved Documents matching this BFA mode */
    ApprovedCount: number;
    /** UpdateMask */
    UpdateMask: number;
    /** UpdateFlag (L if UpdateMask has bits 1 and 2; U otherwise) */
    UpdateFlag: string;
    /** key of latest document matching this BFA mode */
    LatestDocumentKey: string;
    /** Contract Value */
    ContractValue: number;
    /** Revenue */
    Revenue: number;
    /** Original Expense Budget Amount */
    OriginalExpenseBudget: number;
    /** EAC budget amount */
    EACExpenseBudget: number;
}

/** Readonly description of an cost transaction posted to a project */
export class FileAccessHistory implements IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID!: number;
    /** When this access transaction occurred */
    Accessed!: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache!: boolean;
    /** User Key  for this transaction  */
    UserKey!: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;

    constructor(data?: IFileAccessHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserName = _data["UserName"];
            this.FileName = _data["FileName"];
            this.RevID = _data["RevID"];
            this.Accessed = _data["Accessed"] ? new Date(_data["Accessed"].toString()) : <any>undefined;
            this.AccessType = _data["AccessType"];
            this.WithDocument = _data["WithDocument"];
            this.AccessInfo = _data["AccessInfo"];
            this.UsedCache = _data["UsedCache"];
            this.UserKey = _data["UserKey"];
            this.DocMasterKey = _data["DocMasterKey"];
        }
    }

    static fromJS(data: any): FileAccessHistory {
        data = typeof data === 'object' ? data : {};
        let result = new FileAccessHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.UserName;
        data["FileName"] = this.FileName;
        data["RevID"] = this.RevID;
        data["Accessed"] = this.Accessed ? this.Accessed.toISOString() : <any>undefined;
        data["AccessType"] = this.AccessType;
        data["WithDocument"] = this.WithDocument;
        data["AccessInfo"] = this.AccessInfo;
        data["UsedCache"] = this.UsedCache;
        data["UserKey"] = this.UserKey;
        data["DocMasterKey"] = this.DocMasterKey;
        return data; 
    }

    clone(): FileAccessHistory {
        const json = this.toJSON();
        let result = new FileAccessHistory();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID: number;
    /** When this access transaction occurred */
    Accessed: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache: boolean;
    /** User Key  for this transaction  */
    UserKey: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;
}

/** Information about file versions */
export class FileVersion implements IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey!: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID!: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged!: Date;
    /** When Approved */
    Approved!: Date;
    /** User that approved this */
    ApprovedBy!: string;
    /** Links to a user/contact  */
    FromUser!: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize!: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion!: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;

    constructor(data?: IFileVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.FileVerKey = _data["FileVerKey"];
            this.RevID = _data["RevID"];
            this.DataHash = _data["DataHash"];
            this.SourceRevision = _data["SourceRevision"];
            this.Cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.Approved = _data["Approved"] ? new Date(_data["Approved"].toString()) : <any>undefined;
            this.ApprovedBy = _data["ApprovedBy"];
            this.FromUser = _data["FromUser"];
            this.TxtData = _data["TxtData"];
            this.BinSize = _data["BinSize"];
            this.IsCurrentApprovedVersion = _data["IsCurrentApprovedVersion"];
            this.NoCanDelete = _data["NoCanDelete"];
        }
    }

    static fromJS(data: any): FileVersion {
        data = typeof data === 'object' ? data : {};
        let result = new FileVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileVerKey"] = this.FileVerKey;
        data["RevID"] = this.RevID;
        data["DataHash"] = this.DataHash;
        data["SourceRevision"] = this.SourceRevision;
        data["Cataloged"] = this.Cataloged ? this.Cataloged.toISOString() : <any>undefined;
        data["Approved"] = this.Approved ? this.Approved.toISOString() : <any>undefined;
        data["ApprovedBy"] = this.ApprovedBy;
        data["FromUser"] = this.FromUser;
        data["TxtData"] = this.TxtData;
        data["BinSize"] = this.BinSize;
        data["IsCurrentApprovedVersion"] = this.IsCurrentApprovedVersion;
        data["NoCanDelete"] = this.NoCanDelete;
        return data; 
    }

    clone(): FileVersion {
        const json = this.toJSON();
        let result = new FileVersion();
        result.init(json);
        return result;
    }
}

/** Information about file versions */
export interface IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged: Date;
    /** When Approved */
    Approved: Date;
    /** User that approved this */
    ApprovedBy: string;
    /** Links to a user/contact  */
    FromUser: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;
}

/** Describes a Part, including the fields available to this user */
export class UIDisplayPart implements IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explaination or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI!: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI!: boolean;

    constructor(data?: IUIDisplayPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartName = _data["PartName"];
            this.DisplayName = _data["DisplayName"];
            this.Description = _data["Description"];
            this.GetAPI = _data["GetAPI"];
            this.SortHint = _data["SortHint"];
            this.PartType = _data["PartType"];
            if (Array.isArray(_data["UIItems"])) {
                this.UIItems = [] as any;
                for (let item of _data["UIItems"])
                    this.UIItems!.push(UIDisplayConfig.fromJS(item));
            }
            if (Array.isArray(_data["UIFilters"])) {
                this.UIFilters = [] as any;
                for (let item of _data["UIFilters"])
                    this.UIFilters!.push(UIDisplayFilter.fromJS(item));
            }
            this.ViaUI = _data["ViaUI"];
            this.wbxUI = _data["wbxUI"];
        }
    }

    static fromJS(data: any): UIDisplayPart {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartName"] = this.PartName;
        data["DisplayName"] = this.DisplayName;
        data["Description"] = this.Description;
        data["GetAPI"] = this.GetAPI;
        data["SortHint"] = this.SortHint;
        data["PartType"] = this.PartType;
        if (Array.isArray(this.UIItems)) {
            data["UIItems"] = [];
            for (let item of this.UIItems)
                data["UIItems"].push(item.toJSON());
        }
        if (Array.isArray(this.UIFilters)) {
            data["UIFilters"] = [];
            for (let item of this.UIFilters)
                data["UIFilters"].push(item.toJSON());
        }
        data["ViaUI"] = this.ViaUI;
        data["wbxUI"] = this.wbxUI;
        return data; 
    }

    clone(): UIDisplayPart {
        const json = this.toJSON();
        let result = new UIDisplayPart();
        result.init(json);
        return result;
    }
}

/** Describes a Part, including the fields available to this user */
export interface IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explaination or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI: boolean;
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export class UIDisplayConfig implements IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey!: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo!: number;
    /** Max characters, for character types, this is from database size */
    MaxChars!: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore!: number;
    /** For controling tab order */
    SeqData!: number;
    /** When TRUE, UI will be read only */
    IsReadOnly!: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible!: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault!: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML!: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** When set, display an info-pop style add on along side this ui elment.  Content comes from the specified peer data field */
    ShowInfoPop?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width!: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;

    constructor(data?: IUIDisplayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartConfigKey = _data["PartConfigKey"];
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.Label = _data["Label"];
            this.LookupName = _data["LookupName"];
            this.DisplayFormat = _data["DisplayFormat"];
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        (<any>this.OtherProperties)![key] = _data["OtherProperties"][key];
                }
            }
            this.ClickAction = _data["ClickAction"];
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.MaxChars = _data["MaxChars"];
            this.RequiredBefore = _data["RequiredBefore"];
            this.SeqData = _data["SeqData"];
            this.IsReadOnly = _data["IsReadOnly"];
            this.Visible = _data["Visible"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.HTML = _data["HTML"];
            this.Overlay = _data["Overlay"];
            this.ShowInfoPop = _data["ShowInfoPop"];
            this.ShownWhen = _data["ShownWhen"];
            this.ValidateAgainst = _data["ValidateAgainst"];
            this.ValidateTextAgainst = _data["ValidateTextAgainst"];
            this.ValidationMax = _data["ValidationMax"];
            this.ValidationMin = _data["ValidationMin"];
            this.Width = _data["Width"];
            this.WidthCSS = _data["WidthCSS"];
            this.UIType = _data["UIType"];
        }
    }

    static fromJS(data: any): UIDisplayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.PartConfigKey;
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["Label"] = this.Label;
        data["LookupName"] = this.LookupName;
        data["DisplayFormat"] = this.DisplayFormat;
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    (<any>data["OtherProperties"])[key] = this.OtherProperties[key];
            }
        }
        data["ClickAction"] = this.ClickAction;
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["MaxChars"] = this.MaxChars;
        data["RequiredBefore"] = this.RequiredBefore;
        data["SeqData"] = this.SeqData;
        data["IsReadOnly"] = this.IsReadOnly;
        data["Visible"] = this.Visible;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["HTML"] = this.HTML;
        data["Overlay"] = this.Overlay;
        data["ShowInfoPop"] = this.ShowInfoPop;
        data["ShownWhen"] = this.ShownWhen;
        data["ValidateAgainst"] = this.ValidateAgainst;
        data["ValidateTextAgainst"] = this.ValidateTextAgainst;
        data["ValidationMax"] = this.ValidationMax;
        data["ValidationMin"] = this.ValidationMin;
        data["Width"] = this.Width;
        data["WidthCSS"] = this.WidthCSS;
        data["UIType"] = this.UIType;
        return data; 
    }

    clone(): UIDisplayConfig {
        const json = this.toJSON();
        let result = new UIDisplayConfig();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export interface IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo: number;
    /** Max characters, for character types, this is from database size */
    MaxChars: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore: number;
    /** For controling tab order */
    SeqData: number;
    /** When TRUE, UI will be read only */
    IsReadOnly: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** When set, display an info-pop style add on along side this ui elment.  Content comes from the specified peer data field */
    ShowInfoPop?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export class UIDisplayFilter implements IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey!: string;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo!: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible!: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault!: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;

    constructor(data?: IUIDisplayFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartConfigKey = _data["PartConfigKey"];
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.Label = _data["Label"];
            this.LookupName = _data["LookupName"];
            this.DisplayFormat = _data["DisplayFormat"];
            if (_data["AuxData"]) {
                this.AuxData = {} as any;
                for (let key in _data["AuxData"]) {
                    if (_data["AuxData"].hasOwnProperty(key))
                        (<any>this.AuxData)![key] = _data["AuxData"][key];
                }
            }
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.DefaultValue = _data["DefaultValue"];
            this.Visible = _data["Visible"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.Overlay = _data["Overlay"];
        }
    }

    static fromJS(data: any): UIDisplayFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.PartConfigKey;
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["Label"] = this.Label;
        data["LookupName"] = this.LookupName;
        data["DisplayFormat"] = this.DisplayFormat;
        if (this.AuxData) {
            data["AuxData"] = {};
            for (let key in this.AuxData) {
                if (this.AuxData.hasOwnProperty(key))
                    (<any>data["AuxData"])[key] = this.AuxData[key];
            }
        }
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["DefaultValue"] = this.DefaultValue;
        data["Visible"] = this.Visible;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["Overlay"] = this.Overlay;
        return data; 
    }

    clone(): UIDisplayFilter {
        const json = this.toJSON();
        let result = new UIDisplayFilter();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export interface IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey: string;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
