/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as jQuery from 'jquery';

export class ActionItemsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns action items for specified User
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserActionItemsAll(forUserKey: string) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getUserActionItemsAllWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsAllWithCallbacks(forUserKey: string, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItemsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItemsAll(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns action items that match filters ProjectLike, TitleLike, ForDocType, FromDate, ThruDate, NewOnly
     */
    getMatchingUserActionItems(usingFilters: QueryFilters) {
        return new Promise<UserActionItem[] | null>((resolve, reject) => {
            this.getMatchingUserActionItemsWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingUserActionItemsWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: UserActionItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/matching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingUserActionItems(xhr: any): UserActionItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserActionItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     */
    getUserActionItems(userID: string, routeID: string) {
        return new Promise<RouteActionInfo | null>((resolve, reject) => {
            this.getUserActionItemsWithCallbacks(userID, routeID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserActionItemsWithCallbacks(userID: string, routeID: string, onSuccess?: (result: RouteActionInfo | null) => void, onFail?: (exception: string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserActionItems(xhr: any): RouteActionInfo | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 500) {
            const _responseText = xhr.responseText;
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result500);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("Requested route not found", status, _responseText, _headers, result404);
        } else if (status === 503) {
            const _responseText = xhr.responseText;
            let result503: any = null;
            let resultData503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result503 = resultData503 !== undefined ? resultData503 : <any>null;
            return throwException("Try again after reauthentication", status, _responseText, _headers, result503);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RouteActionInfo.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Updates an action item for the specified User
     * @param userID User Key or 1 for self
     * @param routeID Route ID (guid)
     * @param actionData action is patch data
     * @param actionMode (optional) Mode is id,match,every
     */
    patchUserActionItems(userID: string, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchUserActionItemsWithCallbacks(userID, routeID, actionData, actionMode, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchUserActionItemsWithCallbacks(userID: string, routeID: string, actionData: RouteActionData, actionMode: string | null | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/ActionItems/{userID}/{routeID}?";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        if (routeID === undefined || routeID === null)
            throw new Error("The parameter 'routeID' must be defined.");
        url_ = url_.replace("{routeID}", encodeURIComponent("" + routeID));
        if (actionMode !== undefined && actionMode !== null)
            url_ += "actionMode=" + encodeURIComponent("" + actionMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchUserActionItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchUserActionItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchUserActionItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchUserActionItems(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class CatalogClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a history of access to the specified ID
     * @param iD Catalog File Key
     */
    getCatalogAccessHistory(iD: string) {
        return new Promise<FileAccessHistory[] | null>((resolve, reject) => {
            this.getCatalogAccessHistoryWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogAccessHistoryWithCallbacks(iD: string, onSuccess?: (result: FileAccessHistory[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/AccessHistory";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogAccessHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogAccessHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogAccessHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogAccessHistory(xhr: any): FileAccessHistory[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileAccessHistory.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns a list of versions for the specified ID
     * @param iD Catalog File Key
     */
    getCatalogVersions(iD: string) {
        return new Promise<FileVersion[] | null>((resolve, reject) => {
            this.getCatalogVersionsWithCallbacks(iD, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCatalogVersionsWithCallbacks(iD: string, onSuccess?: (result: FileVersion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/catalog/{ID}/versions";
        if (iD === undefined || iD === null)
            throw new Error("The parameter 'iD' must be defined.");
        url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCatalogVersionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCatalogVersionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCatalogVersions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCatalogVersions(xhr: any): FileVersion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileVersion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class DocumentToolsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    docDetailStateTable() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.docDetailStateTableWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private docDetailStateTableWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/DocumentTools";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDocDetailStateTableWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDocDetailStateTableWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDocDetailStateTableWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDocDetailStateTable(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDocDetailStateTable(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the ATC Workflow log for the current document session
     * @param id Document Key
     */
    getDocWorkflowLog(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocWorkflowLogWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocWorkflowLogWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/workflow/log/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocWorkflowLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocWorkflowLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocWorkflowLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocWorkflowLog(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the Document Session Key
     * @param id Document Key
     */
    getDocSession(id: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDocSessionWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocSessionWithCallbacks(id: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocSession(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Given the specified session exists for the current user, associates the Document and Session Key
     * @param id Document Key
     * @param sessionID session id
     */
    patchDocSession(id: string, sessionID: string) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchDocSessionWithCallbacks(id, sessionID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchDocSessionWithCallbacks(id: string, sessionID: string, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/session/{id}/{sessionID}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchDocSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchDocSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchDocSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchDocSession(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocHeader(id: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeaderWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeaderWithCallbacks(id: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeaderWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeaderWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document revision, including a Document Session Key
     * @param id Document Key
     * @param revKey Revision Key
     */
    getDocHeader2(id: string, revKey: string) {
        return new Promise<DocMasterDetail | null>((resolve, reject) => {
            this.getDocHeader2WithCallbacks(id, revKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocHeader2WithCallbacks(id: string, revKey: string, onSuccess?: (result: DocMasterDetail | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/{revKey}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revKey === undefined || revKey === null)
            throw new Error("The parameter 'revKey' must be defined.");
        url_ = url_.replace("{revKey}", encodeURIComponent("" + revKey));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocHeader2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocHeader2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocHeader2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocHeader2(xhr: any): DocMasterDetail | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocMasterDetail.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the header of the specified document, including a Document Session Key
     * @param id Document Key
     */
    getDocItems(id: string) {
        return new Promise<DocItem[] | null>((resolve, reject) => {
            this.getDocItemsWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocItemsWithCallbacks(id: string, onSuccess?: (result: DocItem[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Items";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocItemsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocItemsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocItems(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocItems(xhr: any): DocItem[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocItem.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the route on the specified document
     * @param id Document Key
     */
    getDocRoute(id: string) {
        return new Promise<DocRoute[] | null>((resolve, reject) => {
            this.getDocRouteWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDocRouteWithCallbacks(id: string, onSuccess?: (result: DocRoute[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Document/{id}/Route";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDocRouteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDocRouteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDocRoute(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDocRoute(xhr: any): DocRoute[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocRoute.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AccountClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Authenticates a session and generates a FormsAuthenticationTicket and cookie
     */
    postLogin(credentials: SiteLogin) {
        return new Promise<string | null>((resolve, reject) => {
            this.postLoginWithCallbacks(credentials, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postLoginWithCallbacks(credentials: SiteLogin, onSuccess?: (result: string | null) => void, onFail?: (exception: string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLoginWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostLoginWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostLogin(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns general information about the Authenticed user
     */
    getUserData() {
        return new Promise<CurrentUser | null>((resolve, reject) => {
            this.getUserDataWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserDataWithCallbacks(onSuccess?: (result: CurrentUser | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserData(xhr: any): CurrentUser | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUser.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns authorization flags for specified demand if they match or exceed the request
     * @param demand Demand Context
     */
    getAccess(demand: PermissionContext) {
        return new Promise<PermissionFlags>((resolve, reject) => {
            this.getAccessWithCallbacks(demand, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getAccessWithCallbacks(demand: PermissionContext, onSuccess?: (result: PermissionFlags) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/Authorized";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(demand);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAccessWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetAccessWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetAccess(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetAccess(xhr: any): PermissionFlags | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    acquireTabList() {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.acquireTabListWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private acquireTabListWithCallbacks(onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/Account";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processAcquireTabListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAcquireTabListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processAcquireTabListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processAcquireTabList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processAcquireTabList(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class Client {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    returns_information_about_password_composition() {
        return new Promise<PasswordConfiguredOptions | null>((resolve, reject) => {
            this.returns_information_about_password_compositionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private returns_information_about_password_compositionWithCallbacks(onSuccess?: (result: PasswordConfiguredOptions | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Account/PasswordOptions";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processReturns_information_about_password_compositionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processReturns_information_about_password_compositionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processReturns_information_about_password_compositionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processReturns_information_about_password_composition(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processReturns_information_about_password_composition(xhr: any): PasswordConfiguredOptions | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PasswordConfiguredOptions.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectTeamClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns members of the specified project team
     * @param projectID Full Project ID
     * @param includeHidden True to include hidden projects
     */
    getProjectTeamList(projectID: string, includeHidden: boolean) {
        return new Promise<ProjectTeamMember[] | null>((resolve, reject) => {
            this.getProjectTeamListWithCallbacks(projectID, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectTeamListWithCallbacks(projectID: string, includeHidden: boolean, onSuccess?: (result: ProjectTeamMember[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Team?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectTeamListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectTeamListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectTeamList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectTeamList(xhr: any): ProjectTeamMember[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTeamMember.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectDocListClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a summary of document processes on a project
     * @param projectID Full Project ID
     */
    getProjectDocSummary(projectID: string) {
        return new Promise<TypeSummary[] | null>((resolve, reject) => {
            this.getProjectDocSummaryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocSummaryWithCallbacks(projectID: string, onSuccess?: (result: TypeSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/TypeSummary";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocSummaryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocSummaryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocSummary(xhr: any): TypeSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match the requested document type
     * @param projectID Full Project ID
     * @param forDocType Doc Type Key
     */
    getProjectDocList(projectID: string, forDocType: string) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.getProjectDocListWithCallbacks(projectID, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDocListWithCallbacks(projectID: string, forDocType: string, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined and cannot be null.");
        else
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns documents on a project that match filters <b>INCOMPLETE</b>
     */
    matchingProjectDocList(projectID: string, usingFilters: QueryFilters) {
        return new Promise<ProjectDocsOfType[] | null>((resolve, reject) => {
            this.matchingProjectDocListWithCallbacks(projectID, usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingProjectDocListWithCallbacks(projectID: string, usingFilters: QueryFilters, onSuccess?: (result: ProjectDocsOfType[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Docs";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingProjectDocListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingProjectDocListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingProjectDocList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingProjectDocList(xhr: any): ProjectDocsOfType[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDocsOfType.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns projects that match User and hidden filter
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     * @param includeHidden True to include hidden projects in the result
     */
    getList(forUserKey: string, includeHidden: boolean) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getListWithCallbacks(forUserKey, includeHidden, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getListWithCallbacks(forUserKey: string, includeHidden: boolean, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        if (includeHidden === undefined || includeHidden === null)
            throw new Error("The parameter 'includeHidden' must be defined and cannot be null.");
        else
            url_ += "includeHidden=" + encodeURIComponent("" + includeHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that match User, Program, hidden filter
     */
    getMatchingList(usingFilters: QueryFilters) {
        return new Promise<ProjectSummary[] | null>((resolve, reject) => {
            this.getMatchingListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getMatchingListWithCallbacks(usingFilters: QueryFilters, onSuccess?: (result: ProjectSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMatchingListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetMatchingListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetMatchingList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetMatchingList(xhr: any): ProjectSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class LookupClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResultAll(lookupName: string, dataContext: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultAllWithCallbacks(lookupName, dataContext, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultAllWithCallbacks(lookupName: string, dataContext: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResultAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResultAll(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResultWithCallbacks(lookupName, dataContext, depends1, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResultWithCallbacks(lookupName: string, dataContext: string, depends1: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResultWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResultWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult2(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult2WithCallbacks(lookupName, dataContext, depends1, depends2, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult2(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult3(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult3WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult3WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult3WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult3WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult3(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult3(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of matches for a specified lookup and context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param filterValues Optional nvp list of filter values
     */
    getLookupResult4(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getLookupResult4WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, filterValues, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupResult4WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, filterValues: QueryFilters, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/matches/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterValues);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupResult4WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupResult4WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupResult4WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupResult4(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupResult4(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestionsAll(lookupName: string, dataContext: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsAllWithCallbacks(lookupName, dataContext, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsAllWithCallbacks(lookupName: string, dataContext: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsAllWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsAllWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestionsAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestionsAll(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions(lookupName: string, dataContext: string, depends1: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestionsWithCallbacks(lookupName, dataContext, depends1, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestionsWithCallbacks(lookupName: string, dataContext: string, depends1: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions2(lookupName: string, dataContext: string, depends1: string, depends2: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions2WithCallbacks(lookupName, dataContext, depends1, depends2, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions2WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions2WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions2WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions2(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions2(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions3(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions3WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions3WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions3WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions3WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions3WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions3(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions3(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of suggestions for a specified context
     * @param lookupName Name of Lookup
     * @param dataContext Context for Suggestions, use 1 for default
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     * @param term (optional) Optional Partial match term to fitler suggestions
     * @param limit (optional) Optional Limit to result count; default is 20; use -1 for all
     */
    getSuggestions4(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term: string | null | undefined, limit: number | undefined) {
        return new Promise<Suggestion[] | null>((resolve, reject) => {
            this.getSuggestions4WithCallbacks(lookupName, dataContext, depends1, depends2, depends3, depends4, term, limit, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSuggestions4WithCallbacks(lookupName: string, dataContext: string, depends1: string, depends2: string, depends3: string, depends4: string, term: string | null | undefined, limit: number | undefined, onSuccess?: (result: Suggestion[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/suggestions/{lookupName}/{dataContext}/{depends1}/{depends2}/{depends3}/{depends4}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSuggestions4WithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSuggestions4WithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSuggestions4WithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSuggestions4(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSuggestions4(xhr: any): Suggestion[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Suggestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns viewable/printable value
     * @param displayName Name of Display Rule
     * @param dataContext Context for Suggestions, use 1 for default
     * @param dataValue Value to be described
     * @param depends1 Optional context for Suggestions
     * @param depends2 Optional context for Suggestions
     * @param depends3 Optional context for Suggestions
     * @param depends4 Optional context for Suggestions
     */
    getDisplayValue(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getDisplayValueWithCallbacks(displayName, dataContext, dataValue, depends1, depends2, depends3, depends4, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getDisplayValueWithCallbacks(displayName: string, dataContext: string, dataValue: string, depends1: string, depends2: string, depends3: string, depends4: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/viewable/{displayName}/{dataContext}/{dataValue}/{depends1}/{depends2}/{depends3}/{depends4}";
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (dataContext === undefined || dataContext === null)
            throw new Error("The parameter 'dataContext' must be defined.");
        url_ = url_.replace("{dataContext}", encodeURIComponent("" + dataContext));
        if (dataValue === undefined || dataValue === null)
            throw new Error("The parameter 'dataValue' must be defined.");
        url_ = url_.replace("{dataValue}", encodeURIComponent("" + dataValue));
        if (depends1 === undefined || depends1 === null)
            throw new Error("The parameter 'depends1' must be defined.");
        url_ = url_.replace("{depends1}", encodeURIComponent("" + depends1));
        if (depends2 === undefined || depends2 === null)
            throw new Error("The parameter 'depends2' must be defined.");
        url_ = url_.replace("{depends2}", encodeURIComponent("" + depends2));
        if (depends3 === undefined || depends3 === null)
            throw new Error("The parameter 'depends3' must be defined.");
        url_ = url_.replace("{depends3}", encodeURIComponent("" + depends3));
        if (depends4 === undefined || depends4 === null)
            throw new Error("The parameter 'depends4' must be defined.");
        url_ = url_.replace("{depends4}", encodeURIComponent("" + depends4));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetDisplayValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetDisplayValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetDisplayValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetDisplayValue(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of choices for a specified context
     * @param setName Name of Code Set
     * @param forDocType Document / Process Context for choices, use 1 for default
     */
    getCodeChoices(setName: string, forDocType: string) {
        return new Promise<CodeChoice[] | null>((resolve, reject) => {
            this.getCodeChoicesWithCallbacks(setName, forDocType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getCodeChoicesWithCallbacks(setName: string, forDocType: string, onSuccess?: (result: CodeChoice[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/choices/{setName}/{forDocType}";
        if (setName === undefined || setName === null)
            throw new Error("The parameter 'setName' must be defined.");
        url_ = url_.replace("{setName}", encodeURIComponent("" + setName));
        if (forDocType === undefined || forDocType === null)
            throw new Error("The parameter 'forDocType' must be defined.");
        url_ = url_.replace("{forDocType}", encodeURIComponent("" + forDocType));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetCodeChoicesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetCodeChoicesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetCodeChoices(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetCodeChoices(xhr: any): CodeChoice[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeChoice.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UICFGClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param partName Part Name
     * @param forDocType (optional) optional document type (guid format)
     * @param forContext (optional) optional context (subtype, container, etc)
     */
    getLiveDisplay(partName: string, forDocType: string | null | undefined, forContext: string | null | undefined) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLiveDisplayWithCallbacks(partName, forDocType, forContext, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLiveDisplayWithCallbacks(partName: string, forDocType: string | null | undefined, forContext: string | null | undefined, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/live/{partName}?";
        if (partName === undefined || partName === null)
            throw new Error("The parameter 'partName' must be defined.");
        url_ = url_.replace("{partName}", encodeURIComponent("" + partName));
        if (forDocType !== undefined && forDocType !== null)
            url_ += "forDocType=" + encodeURIComponent("" + forDocType) + "&";
        if (forContext !== undefined && forContext !== null)
            url_ += "forContext=" + encodeURIComponent("" + forContext) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLiveDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLiveDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLiveDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLiveDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns Live UI CFG data for this user for the requested part
     * @param lookupName Part Name
     */
    getLookupDisplay(lookupName: string) {
        return new Promise<UIDisplayPart | null>((resolve, reject) => {
            this.getLookupDisplayWithCallbacks(lookupName, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getLookupDisplayWithCallbacks(lookupName: string, onSuccess?: (result: UIDisplayPart | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/uicfg/lookup/{lookupName}";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetLookupDisplayWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetLookupDisplayWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetLookupDisplay(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetLookupDisplay(xhr: any): UIDisplayPart | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UIDisplayPart.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectKPIClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of KPI facts for the specified project
     * @param projectID Full Project ID
     */
    getProjectKPIFacts(projectID: string) {
        return new Promise<ProjKPIFact[] | null>((resolve, reject) => {
            this.getProjectKPIFactsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectKPIFactsWithCallbacks(projectID: string, onSuccess?: (result: ProjKPIFact[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/KPI";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectKPIFactsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectKPIFactsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectKPIFacts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectKPIFacts(xhr: any): ProjKPIFact[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjKPIFact.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ContactClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns contacts that match filters
     * @param usingFilters Search Criteria
     */
    matchingContactList(usingFilters: ContactFilters) {
        return new Promise<ContactSummary[] | null>((resolve, reject) => {
            this.matchingContactListWithCallbacks(usingFilters, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private matchingContactListWithCallbacks(usingFilters: ContactFilters, onSuccess?: (result: ContactSummary[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usingFilters);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processMatchingContactListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processMatchingContactListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processMatchingContactList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processMatchingContactList(xhr: any): ContactSummary[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns the contact
     * @param id Contact Key
     */
    getContact(id: string) {
        return new Promise<Contact | null>((resolve, reject) => {
            this.getContactWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getContactWithCallbacks(id: string, onSuccess?: (result: Contact | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetContactWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetContactWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetContact(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetContact(xhr: any): Contact | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class AlertsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns alert items for a specified user
     * @param forUserKey User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    getUserAlertList(forUserKey: string) {
        return new Promise<UserAlert[] | null>((resolve, reject) => {
            this.getUserAlertListWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getUserAlertListWithCallbacks(forUserKey: string, onSuccess?: (result: UserAlert[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts?";
        if (forUserKey === undefined || forUserKey === null)
            throw new Error("The parameter 'forUserKey' must be defined and cannot be null.");
        else
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserAlertListWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetUserAlertListWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetUserAlertList(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetUserAlertList(xhr: any): UserAlert[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAlert.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Creates and stores an alert
     * @param theAlert Model with new alert. Specify AlertText, Description.  UserKey, DocMasterKey, Project, Source, SourceKey and Info1 are optional;
     */
    createAlert(theAlert: UserAlert) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.createAlertWithCallbacks(theAlert, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private createAlertWithCallbacks(theAlert: UserAlert, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(theAlert);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processCreateAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processCreateAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processCreateAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processCreateAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes all alert item for the specified user
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAllAlerts(forUserKey: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAllAlertsWithCallbacks(forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAllAlertsWithCallbacks(forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/all?";
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAllAlertsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAllAlertsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAllAlerts(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAllAlerts(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Removes a specific alert item for the specified user
     * @param id Alert Key
     * @param forUserKey (optional) User Key (for proxy) or 00000000-0000-0000-0000-000000000000 for self
     */
    deleteAlert(id: string, forUserKey: string | undefined) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.deleteAlertWithCallbacks(id, forUserKey, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private deleteAlertWithCallbacks(id: string, forUserKey: string | undefined, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string | string | string | string | string | string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Alerts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forUserKey === null)
            throw new Error("The parameter 'forUserKey' cannot be null.");
        else if (forUserKey !== undefined)
            url_ += "forUserKey=" + encodeURIComponent("" + forUserKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "delete",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteAlertWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processDeleteAlertWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processDeleteAlert(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processDeleteAlert(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 401) {
            const _responseText = xhr.responseText;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("unusable credentials", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = xhr.responseText;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("not allowed now", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = xhr.responseText;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("internal failure", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = xhr.responseText;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 !== undefined ? resultData404 : <any>null;
            return throwException("key not found", status, _responseText, _headers, result404);
        } else if (status === 406) {
            const _responseText = xhr.responseText;
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = resultData406 !== undefined ? resultData406 : <any>null;
            return throwException("key required", status, _responseText, _headers, result406);
        } else if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class SessionClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns list of permissions for a project
     * @param projectID Project ID
     */
    getProjectPermits(projectID: string) {
        return new Promise<UCPermitSet | null>((resolve, reject) => {
            this.getProjectPermitsWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitsWithCallbacks(projectID: string, onSuccess?: (result: UCPermitSet | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/project/{projectID}";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermits(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermits(xhr: any): UCPermitSet | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UCPermitSet.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of permissions by Module | Function
     * @param eTag (optional) Returns nothing if eTag matches supplied eTab
     */
    getProjectPermitNameMap(eTag: string | null | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectPermitNameMapWithCallbacks(eTag, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectPermitNameMapWithCallbacks(eTag: string | null | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/permits/map?";
        if (eTag !== undefined && eTag !== null)
            url_ += "eTag=" + encodeURIComponent("" + eTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectPermitNameMapWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectPermitNameMapWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectPermitNameMap(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectPermitNameMap(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns WCC Session data
     */
    getWCC() {
        return new Promise<{ [key: string]: any; } | null>((resolve, reject) => {
            this.getWCCWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getWCCWithCallbacks(onSuccess?: (result: { [key: string]: any; } | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/who";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWCCWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetWCCWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetWCC(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetWCC(xhr: any): { [key: string]: any; } | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns list of open tabs
     * @param forTabType (optional) optional tab type (project,other, otheruser,blank for all)
     */
    getSessionTabs(forTabType: string | null | undefined) {
        return new Promise<TabStripDetails[] | null>((resolve, reject) => {
            this.getSessionTabsWithCallbacks(forTabType, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getSessionTabsWithCallbacks(forTabType: string | null | undefined, onSuccess?: (result: TabStripDetails[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/tabs?";
        if (forTabType !== undefined && forTabType !== null)
            url_ += "forTabType=" + encodeURIComponent("" + forTabType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSessionTabsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetSessionTabsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetSessionTabs(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetSessionTabs(xhr: any): TabStripDetails[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TabStripDetails.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Logs the posted data
     * @param logData Information to be logged
     */
    postToWebAppLog(logData: APIData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.postToWebAppLogWithCallbacks(logData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private postToWebAppLogWithCallbacks(logData: APIData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostToWebAppLogWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPostToWebAppLogWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPostToWebAppLog(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPostToWebAppLog(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Patches the value in the indicated resource
     * @param tableName table
     * @param fieldName field
     * @param changeData Change information
     */
    patchFieldValue(tableName: string, fieldName: string, changeData: PDSData) {
        return new Promise<HttpStatusCode>((resolve, reject) => {
            this.patchFieldValueWithCallbacks(tableName, fieldName, changeData, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private patchFieldValueWithCallbacks(tableName: string, fieldName: string, changeData: PDSData, onSuccess?: (result: HttpStatusCode) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/value/{tableName}/{fieldName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeData);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "patch",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchFieldValueWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processPatchFieldValueWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processPatchFieldValue(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processPatchFieldValue(xhr: any): HttpStatusCode | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Ends this session
     */
    getEndOfSession() {
        return new Promise<boolean>((resolve, reject) => {
            this.getEndOfSessionWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getEndOfSessionWithCallbacks(onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/session/Logout";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetEndOfSessionWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetEndOfSessionWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetEndOfSession(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetEndOfSession(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class ProjectToolsClient {
    baseUrl: string;
    beforeSend: any = undefined;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://stany2017/SFPMS";
    }

    /**
     * Returns a summary overview of the specified project
     * @param projectID Full Project ID
     */
    getProjectDetail(projectID: string) {
        return new Promise<ProjectAbstract | null>((resolve, reject) => {
            this.getProjectDetailWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectDetailWithCallbacks(projectID: string, onSuccess?: (result: ProjectAbstract | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Abstract";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectDetailWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectDetailWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectDetail(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectDetail(xhr: any): ProjectAbstract | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectAbstract.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns projects that link to the specified project
     * @param projectID Full Project ID
     */
    getProjectLinks(projectID: string) {
        return new Promise<ProjectLink[] | null>((resolve, reject) => {
            this.getProjectLinksWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectLinksWithCallbacks(projectID: string, onSuccess?: (result: ProjectLink[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Links";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectLinksWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectLinksWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectLinks(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectLinks(xhr: any): ProjectLink[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectLink.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCost(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined) {
        return new Promise<{ [key: string]: any; }[] | null>((resolve, reject) => {
            this.getProjectCostWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: { [key: string]: any; }[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Costs?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCost(xhr: any): { [key: string]: any; }[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns project costs summarized by Account and or Task
     * @param projectID Full Project ID
     * @param summaryByAccount (optional) Summarize by Account Catagory
     * @param summaryByTask (optional) Summarize by WB Task
     * @param showUnits (optional) Show Units instead of dollars
     * @param showThousands (optional) Return amounts in Thousands
     */
    getProjectCostFooters(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined) {
        return new Promise<any | null>((resolve, reject) => {
            this.getProjectCostFootersWithCallbacks(projectID, summaryByAccount, summaryByTask, showUnits, showThousands, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostFootersWithCallbacks(projectID: string, summaryByAccount: boolean | undefined, summaryByTask: boolean | undefined, showUnits: boolean | undefined, showThousands: boolean | undefined, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/CostSummary?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (summaryByAccount === null)
            throw new Error("The parameter 'summaryByAccount' cannot be null.");
        else if (summaryByAccount !== undefined)
            url_ += "summaryByAccount=" + encodeURIComponent("" + summaryByAccount) + "&";
        if (summaryByTask === null)
            throw new Error("The parameter 'summaryByTask' cannot be null.");
        else if (summaryByTask !== undefined)
            url_ += "summaryByTask=" + encodeURIComponent("" + summaryByTask) + "&";
        if (showUnits === null)
            throw new Error("The parameter 'showUnits' cannot be null.");
        else if (showUnits !== undefined)
            url_ += "showUnits=" + encodeURIComponent("" + showUnits) + "&";
        if (showThousands === null)
            throw new Error("The parameter 'showThousands' cannot be null.");
        else if (showThousands !== undefined)
            url_ += "showThousands=" + encodeURIComponent("" + showThousands) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostFootersWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostFootersWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostFooters(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostFooters(xhr: any): any | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns recent weather reading at the specified project site
     * @param projectID Full Project ID
     */
    getProjectWeatherReading(projectID: string) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.getProjectWeatherReadingWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherReadingWithCallbacks(projectID: string, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherReading";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherReadingWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherReadingWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherReading(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherReading(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    weatherDataWorker(thisProjectDetail: ProjectAbstract) {
        return new Promise<ProjectWeatherNow | null>((resolve, reject) => {
            this.weatherDataWorkerWithCallbacks(thisProjectDetail, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private weatherDataWorkerWithCallbacks(thisProjectDetail: ProjectAbstract, onSuccess?: (result: ProjectWeatherNow | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/ProjectTools";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(thisProjectDetail);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processWeatherDataWorkerWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processWeatherDataWorkerWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processWeatherDataWorkerWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processWeatherDataWorker(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processWeatherDataWorker(xhr: any): ProjectWeatherNow | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectWeatherNow.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns history of weather readings at the specified project site INCOMPLETE
     * @param projectID Full Project ID
     */
    getProjectWeatherHistory(projectID: string) {
        return new Promise<WeatherAtLocation[] | null>((resolve, reject) => {
            this.getProjectWeatherHistoryWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectWeatherHistoryWithCallbacks(projectID: string, onSuccess?: (result: WeatherAtLocation[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/WeatherHistory";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectWeatherHistoryWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectWeatherHistoryWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectWeatherHistory(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectWeatherHistory(xhr: any): WeatherAtLocation[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAtLocation.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns current note for the specified project
     * @param projectID Full Project ID
     */
    getProjectNote(projectID: string) {
        return new Promise<string | null>((resolve, reject) => {
            this.getProjectNoteWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNoteWithCallbacks(projectID: string, onSuccess?: (result: string | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNote(xhr: any): string | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Sets project note INCOMPLETE!!!
     * @param projectID Full Project ID
     */
    newProjectNote(projectID: string, newNote: string) {
        return new Promise<boolean>((resolve, reject) => {
            this.newProjectNoteWithCallbacks(projectID, newNote, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private newProjectNoteWithCallbacks(projectID: string, newNote: string, onSuccess?: (result: boolean) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Note";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newNote);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "put",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processNewProjectNoteWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processNewProjectNoteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processNewProjectNote(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processNewProjectNote(xhr: any): boolean | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns all notes for the specified project
     * @param projectID Full Project ID
     */
    getProjectNotes(projectID: string) {
        return new Promise<Comment[] | null>((resolve, reject) => {
            this.getProjectNotesWithCallbacks(projectID, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectNotesWithCallbacks(projectID: string, onSuccess?: (result: Comment[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/Notes";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectNotesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectNotesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectNotes(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectNotes(xhr: any): Comment[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    /**
     * Returns transactions that detail costs on the project
     * @param projectID Full Project ID
     * @param forWBS (optional) Cost Code Like
     * @param forAccount (optional) Account Catagory
     * @param forAccountType (optional) Account Catagory Type (RV,EX,%)
     * @param forAccountClass (optional) Account Catagory Class (L,LB,M,O,P)
     * @param forPeriod (optional) Fiscal Period
     * @param fromDate (optional) From Date
     * @param thruDate (optional) Thru Date
     * @param refDMK (optional) Reference Document
     * @param refVendor (optional) Reference Vendor ID (or Contact Key)
     */
    getProjectCostTransactions(projectID: string, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined) {
        return new Promise<ProjectTranDetail[] | null>((resolve, reject) => {
            this.getProjectCostTransactionsWithCallbacks(projectID, forWBS, forAccount, forAccountType, forAccountClass, forPeriod, fromDate, thruDate, refDMK, refVendor, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }

    private getProjectCostTransactionsWithCallbacks(projectID: string, forWBS: string | null | undefined, forAccount: string | null | undefined, forAccountType: string | null | undefined, forAccountClass: string | null | undefined, forPeriod: string | null | undefined, fromDate: string | null | undefined, thruDate: string | null | undefined, refDMK: string | null | undefined, refVendor: string | null | undefined, onSuccess?: (result: ProjectTranDetail[] | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Project/{projectID}/cost/transactions?";
        if (projectID === undefined || projectID === null)
            throw new Error("The parameter 'projectID' must be defined.");
        url_ = url_.replace("{projectID}", encodeURIComponent("" + projectID));
        if (forWBS !== undefined && forWBS !== null)
            url_ += "forWBS=" + encodeURIComponent("" + forWBS) + "&";
        if (forAccount !== undefined && forAccount !== null)
            url_ += "forAccount=" + encodeURIComponent("" + forAccount) + "&";
        if (forAccountType !== undefined && forAccountType !== null)
            url_ += "forAccountType=" + encodeURIComponent("" + forAccountType) + "&";
        if (forAccountClass !== undefined && forAccountClass !== null)
            url_ += "forAccountClass=" + encodeURIComponent("" + forAccountClass) + "&";
        if (forPeriod !== undefined && forPeriod !== null)
            url_ += "forPeriod=" + encodeURIComponent("" + forPeriod) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (thruDate !== undefined && thruDate !== null)
            url_ += "thruDate=" + encodeURIComponent("" + thruDate) + "&";
        if (refDMK !== undefined && refDMK !== null)
            url_ += "refDMK=" + encodeURIComponent("" + refDMK) + "&";
        if (refVendor !== undefined && refVendor !== null)
            url_ += "refVendor=" + encodeURIComponent("" + refVendor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetProjectCostTransactionsWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetProjectCostTransactionsWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGetProjectCostTransactions(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGetProjectCostTransactions(xhr: any): ProjectTranDetail[] | null | null {
        const status = xhr.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTranDetail.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

/** A document currently routed to a specific user */
export class UserActionItem implements IUserActionItem {
    /** Key for the document */
    DocMasterKey!: string;
    /** key for the route on the document */
    RouteID!: string;
    /** key for the type of document */
    DocTypeKey!: string;
    /** Resolved Name of the document/process type */
    DocType?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Due Date */
    Due?: Date | undefined;
    /** Title */
    Title?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser!: string;
    /** Key for Primary contact on this document */
    PrimaryContact!: string;
    /** Priority (1=high) */
    Priority!: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Date this route was reaced */
    Reached!: Date;
    /** Route Instructions */
    Note?: string | undefined;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Current Route Sequence */
    Sequence!: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease!: boolean;
    /** When True, is recent  */
    IsRecent!: boolean;
    /** How many files are attached */
    FilesAttached!: number;

    constructor(data?: IUserActionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.RouteID = _data["RouteID"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.Project = _data["Project"];
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Title = _data["Title"];
            this.FromUser = _data["FromUser"];
            this.PrimaryContact = _data["PrimaryContact"];
            this.Priority = _data["Priority"];
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.Note = _data["Note"];
            this.StatusText = _data["StatusText"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.Sequence = _data["Sequence"];
            this.OkToRelease = _data["OkToRelease"];
            this.IsRecent = _data["IsRecent"];
            this.FilesAttached = _data["FilesAttached"];
        }
    }

    static fromJS(data: any): UserActionItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["RouteID"] = this.RouteID;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["Project"] = this.Project;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Title"] = this.Title;
        data["FromUser"] = this.FromUser;
        data["PrimaryContact"] = this.PrimaryContact;
        data["Priority"] = this.Priority;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["Note"] = this.Note;
        data["StatusText"] = this.StatusText;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["Sequence"] = this.Sequence;
        data["OkToRelease"] = this.OkToRelease;
        data["IsRecent"] = this.IsRecent;
        data["FilesAttached"] = this.FilesAttached;
        return data; 
    }

    clone(): UserActionItem {
        const json = this.toJSON();
        let result = new UserActionItem();
        result.init(json);
        return result;
    }
}

/** A document currently routed to a specific user */
export interface IUserActionItem {
    /** Key for the document */
    DocMasterKey: string;
    /** key for the route on the document */
    RouteID: string;
    /** key for the type of document */
    DocTypeKey: string;
    /** Resolved Name of the document/process type */
    DocType?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Document Number */
    DocNo?: string | undefined;
    /** Document Batch (seldom used) */
    DocBatchNo?: string | undefined;
    /** Due Date */
    Due?: Date | undefined;
    /** Title */
    Title?: string | undefined;
    /** Key for Contact this document is "from" */
    FromUser: string;
    /** Key for Primary contact on this document */
    PrimaryContact: string;
    /** Priority (1=high) */
    Priority: number;
    /** Date this route was viewed */
    Viewed?: Date | undefined;
    /** Date this document was closed (or null) */
    Closed?: Date | undefined;
    /** Date this route was reaced */
    Reached: Date;
    /** Route Instructions */
    Note?: string | undefined;
    /** Resolved Status of document */
    StatusText?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Company Name */
    Company?: string | undefined;
    /** Current Route Sequence */
    Sequence: number;
    /** When TRUE, it is OK to release this document without opening it */
    OkToRelease: boolean;
    /** When True, is recent  */
    IsRecent: boolean;
    /** How many files are attached */
    FilesAttached: number;
}

/** Various common filters - not every filter is supported by every query */
export class QueryFilters implements IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
    /** Default is false */
    NewOnly!: boolean;
    /** Default is false */
    IncludeHidden!: boolean;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;

    constructor(data?: IQueryFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ProjectLike = _data["ProjectLike"];
            this.TitleLike = _data["TitleLike"];
            this.UserKey = _data["UserKey"];
            this.ForDocType = _data["ForDocType"];
            this.ProgramKey = _data["ProgramKey"];
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
            this.NewOnly = _data["NewOnly"];
            this.IncludeHidden = _data["IncludeHidden"];
            this.nvpFilters = _data["nvpFilters"];
        }
    }

    static fromJS(data: any): QueryFilters {
        data = typeof data === 'object' ? data : {};
        let result = new QueryFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectLike"] = this.ProjectLike;
        data["TitleLike"] = this.TitleLike;
        data["UserKey"] = this.UserKey;
        data["ForDocType"] = this.ForDocType;
        data["ProgramKey"] = this.ProgramKey;
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        data["NewOnly"] = this.NewOnly;
        data["IncludeHidden"] = this.IncludeHidden;
        data["nvpFilters"] = this.nvpFilters;
        return data; 
    }

    clone(): QueryFilters {
        const json = this.toJSON();
        let result = new QueryFilters();
        result.init(json);
        return result;
    }
}

/** Various common filters - not every filter is supported by every query */
export interface IQueryFilters {
    /** Project Mask (eg GC%) */
    ProjectLike?: string | undefined;
    /** Applies to common text (title, description, etc) */
    TitleLike?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Key must match an existing document type
00000000-0000-0000-0000-000000000000   */
    ForDocType?: string | undefined;
    /** Key for Program or empty key */
    ProgramKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
    /** Default is false */
    NewOnly: boolean;
    /** Default is false */
    IncludeHidden: boolean;
    /** Name Value Pair filter values (semicolon separated) */
    nvpFilters?: string | undefined;
}

export class RouteActionInfo implements IRouteActionInfo {
    DocMasterKey!: string;
    UserName?: string | undefined;
    Title?: string | undefined;
    DocNo?: string | undefined;
    Type?: string | undefined;
    Project?: string | undefined;
    Status?: string | undefined;
    Company?: string | undefined;
    Priority!: number;
    Sequence!: number;
    Due?: string | undefined;
    Viewed?: string | undefined;
    Alerted?: string | undefined;
    Downloaded?: string | undefined;
    FromActed?: string | undefined;
    CreatorActed?: string | undefined;
    OkToRelease!: boolean;
    ShowRouteResponseCode!: boolean;
    ShowRouteResponseArea!: boolean;
    HardCopyCount!: number;
    OkToReleaseCount!: number;
    ReleaseMatchCount!: number;
    ResponseCode?: string | undefined;
    Note?: string | undefined;
    Response?: string | undefined;
    Instructions?: string | undefined;
    FromWho?: string | undefined;
    CreatedBy?: string | undefined;
    NextWho?: string | undefined;
    AccessSummary?: string | undefined;
    DocAccessHistoryReportURL?: string | undefined;
    LastSaved?: string | undefined;
    ExclusiveTo?: string | undefined;
    DocTypeKey!: string;
    StatusChoices?: SelectCodeNode[] | undefined;
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    MatchingDocs?: SelectCodeNode[] | undefined;
    EligibleDocs?: SelectCodeNode[] | undefined;

    constructor(data?: IRouteActionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.UserName = _data["UserName"];
            this.Title = _data["Title"];
            this.DocNo = _data["DocNo"];
            this.Type = _data["Type"];
            this.Project = _data["Project"];
            this.Status = _data["Status"];
            this.Company = _data["Company"];
            this.Priority = _data["Priority"];
            this.Sequence = _data["Sequence"];
            this.Due = _data["Due"];
            this.Viewed = _data["Viewed"];
            this.Alerted = _data["Alerted"];
            this.Downloaded = _data["Downloaded"];
            this.FromActed = _data["FromActed"];
            this.CreatorActed = _data["CreatorActed"];
            this.OkToRelease = _data["OkToRelease"];
            this.ShowRouteResponseCode = _data["ShowRouteResponseCode"];
            this.ShowRouteResponseArea = _data["ShowRouteResponseArea"];
            this.HardCopyCount = _data["HardCopyCount"];
            this.OkToReleaseCount = _data["OkToReleaseCount"];
            this.ReleaseMatchCount = _data["ReleaseMatchCount"];
            this.ResponseCode = _data["ResponseCode"];
            this.Note = _data["Note"];
            this.Response = _data["Response"];
            this.Instructions = _data["Instructions"];
            this.FromWho = _data["FromWho"];
            this.CreatedBy = _data["CreatedBy"];
            this.NextWho = _data["NextWho"];
            this.AccessSummary = _data["AccessSummary"];
            this.DocAccessHistoryReportURL = _data["DocAccessHistoryReportURL"];
            this.LastSaved = _data["LastSaved"];
            this.ExclusiveTo = _data["ExclusiveTo"];
            this.DocTypeKey = _data["DocTypeKey"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["MatchingDocs"])) {
                this.MatchingDocs = [] as any;
                for (let item of _data["MatchingDocs"])
                    this.MatchingDocs!.push(SelectCodeNode.fromJS(item));
            }
            if (Array.isArray(_data["EligibleDocs"])) {
                this.EligibleDocs = [] as any;
                for (let item of _data["EligibleDocs"])
                    this.EligibleDocs!.push(SelectCodeNode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["UserName"] = this.UserName;
        data["Title"] = this.Title;
        data["DocNo"] = this.DocNo;
        data["Type"] = this.Type;
        data["Project"] = this.Project;
        data["Status"] = this.Status;
        data["Company"] = this.Company;
        data["Priority"] = this.Priority;
        data["Sequence"] = this.Sequence;
        data["Due"] = this.Due;
        data["Viewed"] = this.Viewed;
        data["Alerted"] = this.Alerted;
        data["Downloaded"] = this.Downloaded;
        data["FromActed"] = this.FromActed;
        data["CreatorActed"] = this.CreatorActed;
        data["OkToRelease"] = this.OkToRelease;
        data["ShowRouteResponseCode"] = this.ShowRouteResponseCode;
        data["ShowRouteResponseArea"] = this.ShowRouteResponseArea;
        data["HardCopyCount"] = this.HardCopyCount;
        data["OkToReleaseCount"] = this.OkToReleaseCount;
        data["ReleaseMatchCount"] = this.ReleaseMatchCount;
        data["ResponseCode"] = this.ResponseCode;
        data["Note"] = this.Note;
        data["Response"] = this.Response;
        data["Instructions"] = this.Instructions;
        data["FromWho"] = this.FromWho;
        data["CreatedBy"] = this.CreatedBy;
        data["NextWho"] = this.NextWho;
        data["AccessSummary"] = this.AccessSummary;
        data["DocAccessHistoryReportURL"] = this.DocAccessHistoryReportURL;
        data["LastSaved"] = this.LastSaved;
        data["ExclusiveTo"] = this.ExclusiveTo;
        data["DocTypeKey"] = this.DocTypeKey;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.MatchingDocs)) {
            data["MatchingDocs"] = [];
            for (let item of this.MatchingDocs)
                data["MatchingDocs"].push(item.toJSON());
        }
        if (Array.isArray(this.EligibleDocs)) {
            data["EligibleDocs"] = [];
            for (let item of this.EligibleDocs)
                data["EligibleDocs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RouteActionInfo {
        const json = this.toJSON();
        let result = new RouteActionInfo();
        result.init(json);
        return result;
    }
}

export interface IRouteActionInfo {
    DocMasterKey: string;
    UserName?: string | undefined;
    Title?: string | undefined;
    DocNo?: string | undefined;
    Type?: string | undefined;
    Project?: string | undefined;
    Status?: string | undefined;
    Company?: string | undefined;
    Priority: number;
    Sequence: number;
    Due?: string | undefined;
    Viewed?: string | undefined;
    Alerted?: string | undefined;
    Downloaded?: string | undefined;
    FromActed?: string | undefined;
    CreatorActed?: string | undefined;
    OkToRelease: boolean;
    ShowRouteResponseCode: boolean;
    ShowRouteResponseArea: boolean;
    HardCopyCount: number;
    OkToReleaseCount: number;
    ReleaseMatchCount: number;
    ResponseCode?: string | undefined;
    Note?: string | undefined;
    Response?: string | undefined;
    Instructions?: string | undefined;
    FromWho?: string | undefined;
    CreatedBy?: string | undefined;
    NextWho?: string | undefined;
    AccessSummary?: string | undefined;
    DocAccessHistoryReportURL?: string | undefined;
    LastSaved?: string | undefined;
    ExclusiveTo?: string | undefined;
    DocTypeKey: string;
    StatusChoices?: SelectCodeNode[] | undefined;
    ResponseCodeChoices?: SelectCodeNode[] | undefined;
    MatchingDocs?: SelectCodeNode[] | undefined;
    EligibleDocs?: SelectCodeNode[] | undefined;
}

export class SelectCodeNode implements ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectCodeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectCodeNode {
        data = typeof data === 'object' ? data : {};
        let result = new SelectCodeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectCodeNode {
        const json = this.toJSON();
        let result = new SelectCodeNode();
        result.init(json);
        return result;
    }
}

export interface ISelectCodeNode {
    key?: string | undefined;
    value?: string | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UpgradeRequired = 426,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
}

/** Data to apply to the route being patched */
export class RouteActionData implements IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;

    constructor(data?: IRouteActionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NewStatus = _data["NewStatus"];
            this.ResponseCode = _data["ResponseCode"];
            this.ResponseText = _data["ResponseText"];
        }
    }

    static fromJS(data: any): RouteActionData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteActionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewStatus"] = this.NewStatus;
        data["ResponseCode"] = this.ResponseCode;
        data["ResponseText"] = this.ResponseText;
        return data; 
    }

    clone(): RouteActionData {
        const json = this.toJSON();
        let result = new RouteActionData();
        result.init(json);
        return result;
    }
}

/** Data to apply to the route being patched */
export interface IRouteActionData {
    /** New Status Code (A for approved, B for Back, etc) */
    NewStatus?: string | undefined;
    /** Response Code */
    ResponseCode?: string | undefined;
    /** Freeform text for response note */
    ResponseText?: string | undefined;
}

/** Readonly description of an cost transaction posted to a project */
export class FileAccessHistory implements IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID!: number;
    /** When this access transaction occurred */
    Accessed!: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache!: boolean;
    /** User Key  for this transaction  */
    UserKey!: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;

    constructor(data?: IFileAccessHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserName = _data["UserName"];
            this.FileName = _data["FileName"];
            this.RevID = _data["RevID"];
            this.Accessed = _data["Accessed"] ? new Date(_data["Accessed"].toString()) : <any>undefined;
            this.AccessType = _data["AccessType"];
            this.WithDocument = _data["WithDocument"];
            this.AccessInfo = _data["AccessInfo"];
            this.UsedCache = _data["UsedCache"];
            this.UserKey = _data["UserKey"];
            this.DocMasterKey = _data["DocMasterKey"];
        }
    }

    static fromJS(data: any): FileAccessHistory {
        data = typeof data === 'object' ? data : {};
        let result = new FileAccessHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.UserName;
        data["FileName"] = this.FileName;
        data["RevID"] = this.RevID;
        data["Accessed"] = this.Accessed ? this.Accessed.toISOString() : <any>undefined;
        data["AccessType"] = this.AccessType;
        data["WithDocument"] = this.WithDocument;
        data["AccessInfo"] = this.AccessInfo;
        data["UsedCache"] = this.UsedCache;
        data["UserKey"] = this.UserKey;
        data["DocMasterKey"] = this.DocMasterKey;
        return data; 
    }

    clone(): FileAccessHistory {
        const json = this.toJSON();
        let result = new FileAccessHistory();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IFileAccessHistory {
    /** User Name   */
    UserName?: string | undefined;
    /** File Name   */
    FileName?: string | undefined;
    /** File Revision number (starts with 1) */
    RevID: number;
    /** When this access transaction occurred */
    Accessed: Date;
    /** Type of Access */
    AccessType?: string | undefined;
    /** The Long Title of the document in whose context the access took place */
    WithDocument?: string | undefined;
    /** Additional information about access  */
    AccessInfo?: string | undefined;
    /** Was the file in cache */
    UsedCache: boolean;
    /** User Key  for this transaction  */
    UserKey: string;
    /** Document Key  for this transaction  */
    DocMasterKey?: string | undefined;
}

/** Information about file versions */
export class FileVersion implements IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey!: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID!: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged!: Date;
    /** When Approved */
    Approved!: Date;
    /** User that approved this */
    ApprovedBy!: string;
    /** Links to a user/contact  */
    FromUser!: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize!: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion!: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;

    constructor(data?: IFileVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.FileVerKey = _data["FileVerKey"];
            this.RevID = _data["RevID"];
            this.DataHash = _data["DataHash"];
            this.SourceRevision = _data["SourceRevision"];
            this.Cataloged = _data["Cataloged"] ? new Date(_data["Cataloged"].toString()) : <any>undefined;
            this.Approved = _data["Approved"] ? new Date(_data["Approved"].toString()) : <any>undefined;
            this.ApprovedBy = _data["ApprovedBy"];
            this.FromUser = _data["FromUser"];
            this.TxtData = _data["TxtData"];
            this.BinSize = _data["BinSize"];
            this.IsCurrentApprovedVersion = _data["IsCurrentApprovedVersion"];
            this.NoCanDelete = _data["NoCanDelete"];
        }
    }

    static fromJS(data: any): FileVersion {
        data = typeof data === 'object' ? data : {};
        let result = new FileVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileVerKey"] = this.FileVerKey;
        data["RevID"] = this.RevID;
        data["DataHash"] = this.DataHash;
        data["SourceRevision"] = this.SourceRevision;
        data["Cataloged"] = this.Cataloged ? this.Cataloged.toISOString() : <any>undefined;
        data["Approved"] = this.Approved ? this.Approved.toISOString() : <any>undefined;
        data["ApprovedBy"] = this.ApprovedBy;
        data["FromUser"] = this.FromUser;
        data["TxtData"] = this.TxtData;
        data["BinSize"] = this.BinSize;
        data["IsCurrentApprovedVersion"] = this.IsCurrentApprovedVersion;
        data["NoCanDelete"] = this.NoCanDelete;
        return data; 
    }

    clone(): FileVersion {
        const json = this.toJSON();
        let result = new FileVersion();
        result.init(json);
        return result;
    }
}

/** Information about file versions */
export interface IFileVersion {
    /** Link to xsfFileVersionInfo */
    FileVerKey: string;
    /** -2:Doc Folder; -4:Item Folder; with -1: delete */
    RevID: number;
    /** MD5 hash, combined with length and used for duplicate detection */
    DataHash?: string | undefined;
    /** External reference */
    SourceRevision?: string | undefined;
    /** When stored */
    Cataloged: Date;
    /** When Approved */
    Approved: Date;
    /** User that approved this */
    ApprovedBy: string;
    /** Links to a user/contact  */
    FromUser: string;
    /** text from binary (for index/search) */
    TxtData?: string | undefined;
    /** Size of file binary data in bytes  */
    BinSize: number;
    /** True on the file version that is the newest one with approved not empty  */
    IsCurrentApprovedVersion: boolean;
    /** When not empty, reason this version cannot be removed */
    NoCanDelete?: string | undefined;
}

/** Document Header informat for a process */
export class DocMasterDetail implements IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey!: string;
    /** References a Document Process Type */
    DocTypeKey!: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference!: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate!: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority!: number;
    /** Number to send */
    NumToSend!: number;
    /** Number to forward  */
    NumToForward!: number;
    /** numeric probability. valid values 0 to 100 */
    Probability!: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled!: boolean;
    /** When true, access is strictly restricted */
    Confidential!: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit!: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final!: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag!: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due!: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed!: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff!: Date;
    /** For example, invoice date of pay request */
    SourceDate!: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey!: string;
    /** key to global reference */
    UniReferenceKey!: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty!: string;
    /** link to contact/user; the source  */
    SourceContact!: string;
    /** Validated in Contact Table */
    OwnerApprover!: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy!: string;
    /** Predefined route last resolved */
    LastRouteKey!: string;
    /** Status code */
    Status?: string | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area!: number;
    /** Numeric duration - units implied by SOP */
    Duration!: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask!: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags!: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser!: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage!: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo!: number;
    /** Readonly Links to document revision */
    DocRevKey!: string;
    /** Readonly key for document session */
    DocSessionKey!: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq!: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS!: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn!: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut!: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey!: string;
    /** Key to user currently editing  */
    EditUser!: string;
    /** summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;

    constructor(data?: IDocMasterDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.Title = _data["Title"];
            this.Source = _data["Source"];
            this.Priority = _data["Priority"];
            this.NumToSend = _data["NumToSend"];
            this.NumToForward = _data["NumToForward"];
            this.Probability = _data["Probability"];
            this.AutoTitled = _data["AutoTitled"];
            this.Confidential = _data["Confidential"];
            this.DocEdit = _data["DocEdit"];
            this.Final = _data["Final"];
            this.DocFlag = _data["DocFlag"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.SourceContact = _data["SourceContact"];
            this.OwnerApprover = _data["OwnerApprover"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.LastRouteKey = _data["LastRouteKey"];
            this.Status = _data["Status"];
            this.Subtype = _data["Subtype"];
            this.ContractType = _data["ContractType"];
            this.Reason = _data["Reason"];
            this.Area = _data["Area"];
            this.Duration = _data["Duration"];
            this.UpdateMask = _data["UpdateMask"];
            this.RouteFlags = _data["RouteFlags"];
            this.Location = _data["Location"];
            this.PayItemNumber = _data["PayItemNumber"];
            this.DivisionID = _data["DivisionID"];
            this.Project = _data["Project"];
            this.ProjEntity = _data["ProjEntity"];
            this.Specification = _data["Specification"];
            this.BudgetRevFlag = _data["BudgetRevFlag"];
            this.SOVItemNumber = _data["SOVItemNumber"];
            this.Section = _data["Section"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.FromUser = _data["FromUser"];
            this.MaxStage = _data["MaxStage"];
            this.MaxRevNo = _data["MaxRevNo"];
            this.DocRevKey = _data["DocRevKey"];
            this.DocSessionKey = _data["DocSessionKey"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.ProjectSubtype = _data["ProjectSubtype"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.TDKeyMapKey = _data["TDKeyMapKey"];
            this.EditUser = _data["EditUser"];
            this.ComplianceInfo = _data["ComplianceInfo"];
        }
    }

    static fromJS(data: any): DocMasterDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DocMasterDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["Title"] = this.Title;
        data["Source"] = this.Source;
        data["Priority"] = this.Priority;
        data["NumToSend"] = this.NumToSend;
        data["NumToForward"] = this.NumToForward;
        data["Probability"] = this.Probability;
        data["AutoTitled"] = this.AutoTitled;
        data["Confidential"] = this.Confidential;
        data["DocEdit"] = this.DocEdit;
        data["Final"] = this.Final;
        data["DocFlag"] = this.DocFlag;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["SourceContact"] = this.SourceContact;
        data["OwnerApprover"] = this.OwnerApprover;
        data["LastStatusBy"] = this.LastStatusBy;
        data["LastRouteKey"] = this.LastRouteKey;
        data["Status"] = this.Status;
        data["Subtype"] = this.Subtype;
        data["ContractType"] = this.ContractType;
        data["Reason"] = this.Reason;
        data["Area"] = this.Area;
        data["Duration"] = this.Duration;
        data["UpdateMask"] = this.UpdateMask;
        data["RouteFlags"] = this.RouteFlags;
        data["Location"] = this.Location;
        data["PayItemNumber"] = this.PayItemNumber;
        data["DivisionID"] = this.DivisionID;
        data["Project"] = this.Project;
        data["ProjEntity"] = this.ProjEntity;
        data["Specification"] = this.Specification;
        data["BudgetRevFlag"] = this.BudgetRevFlag;
        data["SOVItemNumber"] = this.SOVItemNumber;
        data["Section"] = this.Section;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["FromUser"] = this.FromUser;
        data["MaxStage"] = this.MaxStage;
        data["MaxRevNo"] = this.MaxRevNo;
        data["DocRevKey"] = this.DocRevKey;
        data["DocSessionKey"] = this.DocSessionKey;
        data["CurrentSeq"] = this.CurrentSeq;
        data["ProjectSubtype"] = this.ProjectSubtype;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["TDKeyMapKey"] = this.TDKeyMapKey;
        data["EditUser"] = this.EditUser;
        data["ComplianceInfo"] = this.ComplianceInfo;
        return data; 
    }

    clone(): DocMasterDetail {
        const json = this.toJSON();
        let result = new DocMasterDetail();
        result.init(json);
        return result;
    }
}

/** Document Header informat for a process */
export interface IDocMasterDetail {
    /** Identifies a Document */
    DocMasterKey: string;
    /** References a Document Process Type */
    DocTypeKey: string;
    /** When specified, Limits this rule to documents with matching Reference. */
    DocReference: string;
    /** Updatable; see also xsfDocRevision.Created */
    DocDate: Date;
    /** References base document, based upon DocType */
    DocNo?: string | undefined;
    /** External reference number; text indexed */
    SourceDocNo?: string | undefined;
    /** free form, reference to external number */
    ExternalDocNo?: string | undefined;
    /** With DocNo, references base document */
    DocBatchNo?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Code Reference */
    Source?: string | undefined;
    /** 1 is highest, increasing value decreases priority */
    Priority: number;
    /** Number to send */
    NumToSend: number;
    /** Number to forward  */
    NumToForward: number;
    /** numeric probability. valid values 0 to 100 */
    Probability: number;
    /** When TRUE, Spitfire can replace the title automatically */
    AutoTitled: boolean;
    /** When true, access is strictly restricted */
    Confidential: boolean;
    /** When TRUE, those with permission can edit the document */
    DocEdit: boolean;
    /** when true, something is final (often used for final payment, etc) */
    Final: boolean;
    /** Used on Vendor Maintenance documents */
    DocFlag: boolean;
    /** Date (and sometimes Time) by which action is required */
    Due: Date;
    /** When NULL, this document is open;?? date is set when document status is set to a status enumerated in the DocStatusIsClosed rule */
    Closed: Date;
    /** Own Signature Date or Manager's Approved Date */
    Signoff: Date;
    /** For example, invoice date of pay request */
    SourceDate: Date;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey: string;
    /** key to global reference */
    UniReferenceKey: string;
    /** Key for contact consisdered the Responsible Party.  Often used for "Ball In Court".  Can be used as a filter */
    ResponsibleParty: string;
    /** link to contact/user; the source  */
    SourceContact: string;
    /** Validated in Contact Table */
    OwnerApprover: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy: string;
    /** Predefined route last resolved */
    LastRouteKey: string;
    /** Status code */
    Status?: string | undefined;
    /** Code (see doc type subcode maintenance) */
    Subtype?: string | undefined;
    /** FP/TM etc as site defined in xsfDocTypeSubcodes */
    ContractType?: string | undefined;
    /** xsfDocTypeSubcodes - user-defined; Formerly RejectCode */
    Reason?: string | undefined;
    /** Numeric area - units implied by SOP */
    Area: number;
    /** Numeric duration - units implied by SOP */
    Duration: number;
    /** Bit Mask:Orig/Bid(1); EAC(2); FAC(4) */
    UpdateMask: number;
    /** 0=off;1=retry;2=refreshing; see kba */
    RouteFlags: number;
    /** free form  */
    Location?: string | undefined;
    /** External payment authorization number */
    PayItemNumber?: string | undefined;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Budget Revision Copy of Budget Revision ID */
    BudgetRevFlag?: string | undefined;
    /** ERP systems: weak link to pjbillcn.itemnbr */
    SOVItemNumber?: string | undefined;
    /** freeform */
    Section?: string | undefined;
    /** Reference to related subcontract  */
    SubContract?: string | undefined;
    /** If pay control is being enforced  */
    PayControl?: string | undefined;
    /** Links to a user/contact  */
    FromUser: string;
    /** read only indicator of the number of stages currently in the route */
    MaxStage: number;
    /** read only indicator of the number of revisions currently in the document */
    MaxRevNo: number;
    /** Readonly Links to document revision */
    DocRevKey: string;
    /** Readonly key for document session */
    DocSessionKey: string;
    /** Current Route sequence (null if past end of route) */
    CurrentSeq: number;
    /** References Subtype on Project Setup */
    ProjectSubtype?: string | undefined;
    /** when true, XTS applies */
    IsXTS: boolean;
    /** when true, XTS inbound updates are disabled */
    XTSBlockIn: boolean;
    /** when true, XTS pushes are disabled */
    XTSBlockOut: boolean;
    /** when XTS, mapping key */
    TDKeyMapKey: string;
    /** Key to user currently editing  */
    EditUser: string;
    /** summary of compliance state - if type has compliance enabled */
    ComplianceInfo?: string | undefined;
}

/** Describes an DocItem Condition */
export class DocItem implements IDocItem {
    /** Key of this item */
    DocItemKey!: string;
    /** Readonly Number of task entries for this item; often 1 */
    TaskCount!: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount!: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty!: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey!: string;
    /** Weak Link to another item */
    LinkedItemKey!: string;
    /** Key to global reference  */
    UniReferenceKey!: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy!: string;
    /** Key Reference user/contact */
    Approver!: string;
    /** References user/contact */
    Author!: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage!: number;
    /** Money - Completed Work Retention */
    CWRetention!: number;
    /** Money - Stored Material Retention */
    SMRetention!: number;
    /** Original Estimate (of cost) */
    OriginalEstimate!: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote!: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity!: number;
    /** when true, is billable/included */
    Billable!: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey!: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey!: string;
    /** Reference to user/contact */
    ItemFromUser!: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated!: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc!: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared!: boolean;
    /** Hmm */
    ResponsibleNow!: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;

    constructor(data?: IDocItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocItemKey = _data["DocItemKey"];
            this.TaskCount = _data["TaskCount"];
            this.CommentCount = _data["CommentCount"];
            this.ItemRevisionMap = _data["ItemRevisionMap"] ? DocItemMap.fromJS(_data["ItemRevisionMap"]) : <any>undefined;
            if (Array.isArray(_data["DocItemTask"])) {
                this.DocItemTask = [] as any;
                for (let item of _data["DocItemTask"])
                    this.DocItemTask!.push(DocItemTask.fromJS(item));
            }
            this.RelatedLineDetails = _data["RelatedLineDetails"] ? RelatedItemDetail.fromJS(_data["RelatedLineDetails"]) : <any>undefined;
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.LinkedDocKey = _data["LinkedDocKey"];
            this.LinkedItemKey = _data["LinkedItemKey"];
            this.UniReferenceKey = _data["UniReferenceKey"];
            this.LastStatusBy = _data["LastStatusBy"];
            this.Approver = _data["Approver"];
            this.Author = _data["Author"];
            this.Description = _data["Description"];
            this.DrawingNumber = _data["DrawingNumber"];
            this.RevisionNumber = _data["RevisionNumber"];
            this.Paragraph = _data["Paragraph"];
            this.Specification = _data["Specification"];
            this.ItemStatus = _data["ItemStatus"];
            this.ItemSource = _data["ItemSource"];
            this.ItemType = _data["ItemType"];
            this.ItemSubtype = _data["ItemSubtype"];
            this.Drawings = _data["Drawings"];
            this.Samples = _data["Samples"];
            this.ProductData = _data["ProductData"];
            this.TestReport = _data["TestReport"];
            this.MixDesign = _data["MixDesign"];
            this.Schedule = _data["Schedule"];
            this.FieldMockup = _data["FieldMockup"];
            this.Guarantee = _data["Guarantee"];
            this.Certification = _data["Certification"];
            this.Evaluation = _data["Evaluation"];
            this.Shop = _data["Shop"];
            this.SourceItemNumber = _data["SourceItemNumber"];
            this.SourceInitialNumber = _data["SourceInitialNumber"];
            this.ArchitectInitialNumber = _data["ArchitectInitialNumber"];
            this.ArchitectItemNumber = _data["ArchitectItemNumber"];
            this.SOVLineNumber = _data["SOVLineNumber"];
            this.Manufacturer = _data["Manufacturer"];
            this.Supplier = _data["Supplier"];
            this.RevenueEntity = _data["RevenueEntity"];
            this.Stage = _data["Stage"];
            this.CWRetention = _data["CWRetention"];
            this.SMRetention = _data["SMRetention"];
            this.OriginalEstimate = _data["OriginalEstimate"];
            this.OriginalQuote = _data["OriginalQuote"];
            this.ItemQuantity = _data["ItemQuantity"];
            this.Billable = _data["Billable"];
            this.Started = _data["Started"] ? new Date(_data["Started"].toString()) : <any>undefined;
            this.Submitted = _data["Submitted"] ? new Date(_data["Submitted"].toString()) : <any>undefined;
            this.Requested = _data["Requested"] ? new Date(_data["Requested"].toString()) : <any>undefined;
            this.Received = _data["Received"] ? new Date(_data["Received"].toString()) : <any>undefined;
            this.Reviewed = _data["Reviewed"] ? new Date(_data["Reviewed"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Completed = _data["Completed"] ? new Date(_data["Completed"].toString()) : <any>undefined;
            this.ItemRevKey = _data["ItemRevKey"];
            this.ItemFolderKey = _data["ItemFolderKey"];
            this.ItemFromUser = _data["ItemFromUser"];
            this.DocItemNumber = _data["DocItemNumber"];
            this.ItemCreated = _data["ItemCreated"] ? new Date(_data["ItemCreated"].toString()) : <any>undefined;
            this.IsRegisterDoc = _data["IsRegisterDoc"];
            this.ItemRegisterNumber = _data["ItemRegisterNumber"];
            this.ItemIsShared = _data["ItemIsShared"];
            this.ResponsibleNow = _data["ResponsibleNow"];
            this.ResponsibleCommon = _data["ResponsibleCommon"];
        }
    }

    static fromJS(data: any): DocItem {
        data = typeof data === 'object' ? data : {};
        let result = new DocItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocItemKey"] = this.DocItemKey;
        data["TaskCount"] = this.TaskCount;
        data["CommentCount"] = this.CommentCount;
        data["ItemRevisionMap"] = this.ItemRevisionMap ? this.ItemRevisionMap.toJSON() : <any>undefined;
        if (Array.isArray(this.DocItemTask)) {
            data["DocItemTask"] = [];
            for (let item of this.DocItemTask)
                data["DocItemTask"].push(item.toJSON());
        }
        data["RelatedLineDetails"] = this.RelatedLineDetails ? this.RelatedLineDetails.toJSON() : <any>undefined;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["LinkedDocKey"] = this.LinkedDocKey;
        data["LinkedItemKey"] = this.LinkedItemKey;
        data["UniReferenceKey"] = this.UniReferenceKey;
        data["LastStatusBy"] = this.LastStatusBy;
        data["Approver"] = this.Approver;
        data["Author"] = this.Author;
        data["Description"] = this.Description;
        data["DrawingNumber"] = this.DrawingNumber;
        data["RevisionNumber"] = this.RevisionNumber;
        data["Paragraph"] = this.Paragraph;
        data["Specification"] = this.Specification;
        data["ItemStatus"] = this.ItemStatus;
        data["ItemSource"] = this.ItemSource;
        data["ItemType"] = this.ItemType;
        data["ItemSubtype"] = this.ItemSubtype;
        data["Drawings"] = this.Drawings;
        data["Samples"] = this.Samples;
        data["ProductData"] = this.ProductData;
        data["TestReport"] = this.TestReport;
        data["MixDesign"] = this.MixDesign;
        data["Schedule"] = this.Schedule;
        data["FieldMockup"] = this.FieldMockup;
        data["Guarantee"] = this.Guarantee;
        data["Certification"] = this.Certification;
        data["Evaluation"] = this.Evaluation;
        data["Shop"] = this.Shop;
        data["SourceItemNumber"] = this.SourceItemNumber;
        data["SourceInitialNumber"] = this.SourceInitialNumber;
        data["ArchitectInitialNumber"] = this.ArchitectInitialNumber;
        data["ArchitectItemNumber"] = this.ArchitectItemNumber;
        data["SOVLineNumber"] = this.SOVLineNumber;
        data["Manufacturer"] = this.Manufacturer;
        data["Supplier"] = this.Supplier;
        data["RevenueEntity"] = this.RevenueEntity;
        data["Stage"] = this.Stage;
        data["CWRetention"] = this.CWRetention;
        data["SMRetention"] = this.SMRetention;
        data["OriginalEstimate"] = this.OriginalEstimate;
        data["OriginalQuote"] = this.OriginalQuote;
        data["ItemQuantity"] = this.ItemQuantity;
        data["Billable"] = this.Billable;
        data["Started"] = this.Started ? this.Started.toISOString() : <any>undefined;
        data["Submitted"] = this.Submitted ? this.Submitted.toISOString() : <any>undefined;
        data["Requested"] = this.Requested ? this.Requested.toISOString() : <any>undefined;
        data["Received"] = this.Received ? this.Received.toISOString() : <any>undefined;
        data["Reviewed"] = this.Reviewed ? this.Reviewed.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Completed"] = this.Completed ? this.Completed.toISOString() : <any>undefined;
        data["ItemRevKey"] = this.ItemRevKey;
        data["ItemFolderKey"] = this.ItemFolderKey;
        data["ItemFromUser"] = this.ItemFromUser;
        data["DocItemNumber"] = this.DocItemNumber;
        data["ItemCreated"] = this.ItemCreated ? this.ItemCreated.toISOString() : <any>undefined;
        data["IsRegisterDoc"] = this.IsRegisterDoc;
        data["ItemRegisterNumber"] = this.ItemRegisterNumber;
        data["ItemIsShared"] = this.ItemIsShared;
        data["ResponsibleNow"] = this.ResponsibleNow;
        data["ResponsibleCommon"] = this.ResponsibleCommon;
        return data; 
    }

    clone(): DocItem {
        const json = this.toJSON();
        let result = new DocItem();
        result.init(json);
        return result;
    }
}

/** Describes an DocItem Condition */
export interface IDocItem {
    /** Key of this item */
    DocItemKey: string;
    /** Readonly Number of task entries for this item; often 1 */
    TaskCount: number;
    /** Readonly Number of comment entries for this item; often zero */
    CommentCount: number;
    /** Parent revision to which this item belongs */
    ItemRevisionMap?: DocItemMap | undefined;
    /** collection of financial details for this item, often 1-1  */
    DocItemTask?: DocItemTask[] | undefined;
    /** collection of financial details for this item from related family of documents (often commitment), often zero, max 1 */
    RelatedLineDetails?: RelatedItemDetail | undefined;
    /** Key for contact consisdered the Responsible Party.  Filterable.  Contacts with matching company name gets increased access to item */
    ResponsibleParty: string;
    /** Weak link to another Spitfire Document. */
    LinkedDocKey: string;
    /** Weak Link to another item */
    LinkedItemKey: string;
    /** Key to global reference  */
    UniReferenceKey: string;
    /** References user/contact; Set by data layer when related status changes */
    LastStatusBy: string;
    /** Key Reference user/contact */
    Approver: string;
    /** References user/contact */
    Author: string;
    /** Free form explaination or generic description (!!!) */
    Description?: string | undefined;
    /** Assigned  */
    DrawingNumber?: string | undefined;
    /** Auto-increment revision number */
    RevisionNumber?: string | undefined;
    /** Reference to contract paragraph */
    Paragraph?: string | undefined;
    /** External reference to Contract. */
    Specification?: string | undefined;
    /** Validated against xsfDocTypeSubcodes.?? Checked against rule DocItemStatusIsClosed. */
    ItemStatus?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSource?: string | undefined;
    /** References code set ItemType */
    ItemType?: string | undefined;
    /** Code defined in DocType specific list */
    ItemSubtype?: string | undefined;
    /** References code set ItemSubType (can cascade choices from ItemType above) */
    Drawings?: string | undefined;
    /** Code defined in DocType specific list */
    Samples?: string | undefined;
    /** Code defined in DocType specific list */
    ProductData?: string | undefined;
    /** Code defined in DocType specific list */
    TestReport?: string | undefined;
    /** Code defined in DocType specific list */
    MixDesign?: string | undefined;
    /** Code defined in DocType specific list */
    Schedule?: string | undefined;
    /** Code defined in DocType specific list */
    FieldMockup?: string | undefined;
    /** Code defined in DocType specific list */
    Guarantee?: string | undefined;
    /** Code defined in DocType specific list */
    Certification?: string | undefined;
    /** Code defined in DocType specific list */
    Evaluation?: string | undefined;
    /** Code defined in DocType specific list */
    Shop?: string | undefined;
    /** External reference number of this item. */
    SourceItemNumber?: string | undefined;
    /** External reference initial number of this item. */
    SourceInitialNumber?: string | undefined;
    /** Architec Number (initial) */
    ArchitectInitialNumber?: string | undefined;
    /** Architec Number (revised) */
    ArchitectItemNumber?: string | undefined;
    /** weak link to SOV Line */
    SOVLineNumber?: string | undefined;
    /** Free form */
    Manufacturer?: string | undefined;
    /** Free form */
    Supplier?: string | undefined;
    /** Cost Code to which revenue is posted. */
    RevenueEntity?: string | undefined;
    /** Initialized to current stage when added */
    Stage: number;
    /** Money - Completed Work Retention */
    CWRetention: number;
    /** Money - Stored Material Retention */
    SMRetention: number;
    /** Original Estimate (of cost) */
    OriginalEstimate: number;
    /** Original Quote (of revenue, to customer) */
    OriginalQuote: number;
    /** Quantity - see UOM in item task extension */
    ItemQuantity: number;
    /** when true, is billable/included */
    Billable: boolean;
    /** Date Started */
    Started?: Date | undefined;
    /** Date Ssubmitted */
    Submitted?: Date | undefined;
    /** Date Requested */
    Requested?: Date | undefined;
    /** Only editable if type has AllowProof set true */
    Received?: Date | undefined;
    /** Set by the data layer each time ItemStatus changes */
    Reviewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Date Completed */
    Completed?: Date | undefined;
    /** reference to Revision that includes this item */
    ItemRevKey: string;
    /** Key to container for this item; seldom used */
    ItemFolderKey: string;
    /** Reference to user/contact */
    ItemFromUser: string;
    /** Echoes Item number for convienience; see Item Revision */
    DocItemNumber?: string | undefined;
    /** When Created  */
    ItemCreated: Date;
    /** Read Only: when true, this item is a copy from a register */
    IsRegisterDoc: boolean;
    /** When from register, this is the number of the item from the register */
    ItemRegisterNumber?: string | undefined;
    /** Hmm */
    ItemIsShared: boolean;
    /** Hmm */
    ResponsibleNow: string;
    /** Hmm */
    ResponsibleCommon?: string | undefined;
}

/** Describes an DocRevItem Condition */
export class DocItemMap implements IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey!: string;
    /** Links to item */
    DocItemKey!: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey!: string;
    /** Links to a user/contact  */
    FromUser!: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;

    constructor(data?: IDocItemMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocRevItemKey = _data["DocRevItemKey"];
            this.DocItemKey = _data["DocItemKey"];
            this.ContainerKey = _data["ContainerKey"];
            this.FromUser = _data["FromUser"];
            this.ItemNumber = _data["ItemNumber"];
            this.ItemSeq = _data["ItemSeq"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocItemMap {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocRevItemKey"] = this.DocRevItemKey;
        data["DocItemKey"] = this.DocItemKey;
        data["ContainerKey"] = this.ContainerKey;
        data["FromUser"] = this.FromUser;
        data["ItemNumber"] = this.ItemNumber;
        data["ItemSeq"] = this.ItemSeq;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DocItemMap {
        const json = this.toJSON();
        let result = new DocItemMap();
        result.init(json);
        return result;
    }
}

/** Describes an DocRevItem Condition */
export interface IDocItemMap {
    /** When DocRevItemKey = DocItemKey, this is the doc revision that created the item */
    DocRevItemKey: string;
    /** Links to item */
    DocItemKey: string;
    /** Indicates the "folder" where the resource resides */
    ContainerKey: string;
    /** Links to a user/contact  */
    FromUser: string;
    /** Numeric Identifier  */
    ItemNumber?: string | undefined;
    /** Display Sequence (can be overriden by UI CFG) */
    ItemSeq: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
}

/** Describes an DocItemTask Condition */
export class DocItemTask implements IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey!: string;
    LinkedLineKey!: string;
    /** Weak link to RFQ */
    LinkedRFQKey!: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey!: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent!: number;
    /** pjcosubd.change_units */
    Quantity!: number;
    /** Calculated, but editable */
    RevenueAmount!: number;
    Rate!: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount!: number;
    /** Material part of RevenueAmount */
    StoredAmount!: number;
    /** Labor part of RevenueAmount */
    WorkAmount!: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount!: number;
    SMRetentionAmount!: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork!: number;
    /** Total material value on SOV */
    SOVMaterials!: number;
    MarkupRate!: number;
    /** Amount, for custom use */
    csAmount!: number;
    csValue!: number;
    csQty!: number;
    csNumber!: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl!: boolean;
    /** for custom use */
    csCheck!: boolean;
    csFlag!: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey!: string;
    csKey!: string;
    /** date, for custom use */
    csDate!: Date;
    csWhen!: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    LinkedEstimate!: number;
    LinkedQuote!: number;
    LinkedExpense!: number;
    LinkedLines!: number;
    LinkedContact!: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;

    constructor(data?: IDocItemTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ItemTaskKey = _data["ItemTaskKey"];
            this.LinkedLineKey = _data["LinkedLineKey"];
            this.LinkedRFQKey = _data["LinkedRFQKey"];
            this.LinkedCCCKey = _data["LinkedCCCKey"];
            this.ProjEntity = _data["ProjEntity"];
            this.AccountCategory = _data["AccountCategory"];
            this.Subcontract = _data["Subcontract"];
            this.SubChangeOrder = _data["SubChangeOrder"];
            this.CostType = _data["CostType"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.UOM = _data["UOM"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.Vendor = _data["Vendor"];
            this.ProjectReference = _data["ProjectReference"];
            this.ItemPercent = _data["ItemPercent"];
            this.Quantity = _data["Quantity"];
            this.RevenueAmount = _data["RevenueAmount"];
            this.Rate = _data["Rate"];
            this.ExpenseAmount = _data["ExpenseAmount"];
            this.StoredAmount = _data["StoredAmount"];
            this.WorkAmount = _data["WorkAmount"];
            this.RetentionAmount = _data["RetentionAmount"];
            this.SMRetentionAmount = _data["SMRetentionAmount"];
            this.SOVWork = _data["SOVWork"];
            this.SOVMaterials = _data["SOVMaterials"];
            this.MarkupRate = _data["MarkupRate"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.MarkupControl = _data["MarkupControl"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.Note = _data["Note"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.LinkedEstimate = _data["LinkedEstimate"];
            this.LinkedQuote = _data["LinkedQuote"];
            this.LinkedExpense = _data["LinkedExpense"];
            this.LinkedLines = _data["LinkedLines"];
            this.LinkedContact = _data["LinkedContact"];
            this.LinkedRFQSC = _data["LinkedRFQSC"];
            this.LinkedStatus = _data["LinkedStatus"];
        }
    }

    static fromJS(data: any): DocItemTask {
        data = typeof data === 'object' ? data : {};
        let result = new DocItemTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemTaskKey"] = this.ItemTaskKey;
        data["LinkedLineKey"] = this.LinkedLineKey;
        data["LinkedRFQKey"] = this.LinkedRFQKey;
        data["LinkedCCCKey"] = this.LinkedCCCKey;
        data["ProjEntity"] = this.ProjEntity;
        data["AccountCategory"] = this.AccountCategory;
        data["Subcontract"] = this.Subcontract;
        data["SubChangeOrder"] = this.SubChangeOrder;
        data["CostType"] = this.CostType;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["UOM"] = this.UOM;
        data["RetentionMethod"] = this.RetentionMethod;
        data["Vendor"] = this.Vendor;
        data["ProjectReference"] = this.ProjectReference;
        data["ItemPercent"] = this.ItemPercent;
        data["Quantity"] = this.Quantity;
        data["RevenueAmount"] = this.RevenueAmount;
        data["Rate"] = this.Rate;
        data["ExpenseAmount"] = this.ExpenseAmount;
        data["StoredAmount"] = this.StoredAmount;
        data["WorkAmount"] = this.WorkAmount;
        data["RetentionAmount"] = this.RetentionAmount;
        data["SMRetentionAmount"] = this.SMRetentionAmount;
        data["SOVWork"] = this.SOVWork;
        data["SOVMaterials"] = this.SOVMaterials;
        data["MarkupRate"] = this.MarkupRate;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["MarkupControl"] = this.MarkupControl;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["Note"] = this.Note;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["LinkedEstimate"] = this.LinkedEstimate;
        data["LinkedQuote"] = this.LinkedQuote;
        data["LinkedExpense"] = this.LinkedExpense;
        data["LinkedLines"] = this.LinkedLines;
        data["LinkedContact"] = this.LinkedContact;
        data["LinkedRFQSC"] = this.LinkedRFQSC;
        data["LinkedStatus"] = this.LinkedStatus;
        return data; 
    }

    clone(): DocItemTask {
        const json = this.toJSON();
        let result = new DocItemTask();
        result.init(json);
        return result;
    }
}

/** Describes an DocItemTask Condition */
export interface IDocItemTask {
    /** When ItemTaskKey = DocItemKey, this is the primary (or single) extention to the corresponding item */
    ItemTaskKey: string;
    LinkedLineKey: string;
    /** Weak link to RFQ */
    LinkedRFQKey: string;
    /** Links this line to its commitment cost changes (a CCO or Commitment document) */
    LinkedCCCKey: string;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** Subcontract Change Order system assigned - Unique by Subcontract */
    SubChangeOrder?: string | undefined;
    /** Via xsfCodeList, set TaskCostType - Self Perform, SCO, etc */
    CostType?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Weak link to Solomon Vendor; Primarily used for splitting SPR payments amounts */
    Vendor?: string | undefined;
    /** Used for documents that distribute across projects */
    ProjectReference?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent: number;
    /** pjcosubd.change_units */
    Quantity: number;
    /** Calculated, but editable */
    RevenueAmount: number;
    Rate: number;
    /** defaults to Amount, but is editable */
    ExpenseAmount: number;
    /** Material part of RevenueAmount */
    StoredAmount: number;
    /** Labor part of RevenueAmount */
    WorkAmount: number;
    /** Amount of total that goes to retention; Note that only the primary vendor on a subcontract has retention */
    RetentionAmount: number;
    SMRetentionAmount: number;
    /** 62 SOVMaterials 54 Total labor value on SOV; */
    SOVWork: number;
    /** Total material value on SOV */
    SOVMaterials: number;
    MarkupRate: number;
    /** Amount, for custom use */
    csAmount: number;
    csValue: number;
    csQty: number;
    csNumber: number;
    /** When true, auto markup calculation for RevenueAmount is suppressed */
    MarkupControl: boolean;
    /** for custom use */
    csCheck: boolean;
    csFlag: boolean;
    /** Free form */
    Note?: string | undefined;
    csNote?: string | undefined;
    /** Custom Code */
    csCode?: string | undefined;
    /** String for custom use */
    csString016?: string | undefined;
    /** String for custom use */
    csString030?: string | undefined;
    /** String for custom use */
    csString040?: string | undefined;
    /** String for custom use */
    csString050?: string | undefined;
    /** String for custom use */
    csString060?: string | undefined;
    /** String for custom use */
    csString080?: string | undefined;
    /** String for custom use */
    csString100?: string | undefined;
    /** String for custom use */
    csString120?: string | undefined;
    /** String for custom use */
    csString240?: string | undefined;
    csContactKey: string;
    csKey: string;
    /** date, for custom use */
    csDate: Date;
    csWhen: Date;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    LinkedEstimate: number;
    LinkedQuote: number;
    LinkedExpense: number;
    LinkedLines: number;
    LinkedContact: string;
    LinkedRFQSC?: string | undefined;
    LinkedStatus?: string | undefined;
}

/** Describes an SPRLineDetails Condition */
export class RelatedItemDetail implements IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey!: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity!: number;
    /** Approved Retention  */
    ApprovedRetention!: number;
    /** Change Order Approved  */
    ApprovedAmount!: number;
    /** Change Order Approved  */
    ApprovedExpense!: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits!: number;
    /** not yet approved */
    PendingChangeRetention!: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount!: number;
    /** not yet approved */
    PendingChangeExpense!: number;
    /** Paid Units */
    VoucheredUnits!: number;
    /** Paid Amount */
    VoucheredAmount!: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount!: number;
    /** Amount Earned but held as retention */
    VoucheredRetention!: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention!: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity!: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention!: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount!: number;
    /** Units received */
    ReceivedUnits!: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits!: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount!: number;
    /** Units on line, includes change orders */
    ContractUnits!: number;
    /** Percent */
    TotalPercentRequest!: number;
    /** Units */
    TotalUnitsCompleted!: number;
    /** Amount */
    TotalAmountCompleted!: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount!: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent!: number;
    Rate!: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap!: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;

    constructor(data?: IRelatedItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.Subcontract = _data["Subcontract"];
            this.SCDocItemKey = _data["SCDocItemKey"];
            this.ApprovedQuantity = _data["ApprovedQuantity"];
            this.ApprovedRetention = _data["ApprovedRetention"];
            this.ApprovedAmount = _data["ApprovedAmount"];
            this.ApprovedExpense = _data["ApprovedExpense"];
            this.PendingChangeUnits = _data["PendingChangeUnits"];
            this.PendingChangeRetention = _data["PendingChangeRetention"];
            this.PendingChangeAmount = _data["PendingChangeAmount"];
            this.PendingChangeExpense = _data["PendingChangeExpense"];
            this.VoucheredUnits = _data["VoucheredUnits"];
            this.VoucheredAmount = _data["VoucheredAmount"];
            this.VoucheredSMAmount = _data["VoucheredSMAmount"];
            this.VoucheredRetention = _data["VoucheredRetention"];
            this.VoucheredSMRetention = _data["VoucheredSMRetention"];
            this.PRInProgressQuantity = _data["PRInProgressQuantity"];
            this.PRInProgressRetention = _data["PRInProgressRetention"];
            this.PRInProgressAmount = _data["PRInProgressAmount"];
            this.ReceivedUnits = _data["ReceivedUnits"];
            this.ReceiptInProgressUnits = _data["ReceiptInProgressUnits"];
            this.ContractAmount = _data["ContractAmount"];
            this.ContractUnits = _data["ContractUnits"];
            this.TotalPercentRequest = _data["TotalPercentRequest"];
            this.TotalUnitsCompleted = _data["TotalUnitsCompleted"];
            this.TotalAmountCompleted = _data["TotalAmountCompleted"];
            this.TotalPriorAmount = _data["TotalPriorAmount"];
            this.ProjEntity = _data["ProjEntity"];
            this.GLAcct = _data["GLAcct"];
            this.GLSub = _data["GLSub"];
            this.LaborClass = _data["LaborClass"];
            this.AccountCategory = _data["AccountCategory"];
            this.RetentionMethod = _data["RetentionMethod"];
            this.ItemPercent = _data["ItemPercent"];
            this.Rate = _data["Rate"];
            this.LineDesc = _data["LineDesc"];
            this.Cap = _data["Cap"];
            this.UOM = _data["UOM"];
        }
    }

    static fromJS(data: any): RelatedItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["Subcontract"] = this.Subcontract;
        data["SCDocItemKey"] = this.SCDocItemKey;
        data["ApprovedQuantity"] = this.ApprovedQuantity;
        data["ApprovedRetention"] = this.ApprovedRetention;
        data["ApprovedAmount"] = this.ApprovedAmount;
        data["ApprovedExpense"] = this.ApprovedExpense;
        data["PendingChangeUnits"] = this.PendingChangeUnits;
        data["PendingChangeRetention"] = this.PendingChangeRetention;
        data["PendingChangeAmount"] = this.PendingChangeAmount;
        data["PendingChangeExpense"] = this.PendingChangeExpense;
        data["VoucheredUnits"] = this.VoucheredUnits;
        data["VoucheredAmount"] = this.VoucheredAmount;
        data["VoucheredSMAmount"] = this.VoucheredSMAmount;
        data["VoucheredRetention"] = this.VoucheredRetention;
        data["VoucheredSMRetention"] = this.VoucheredSMRetention;
        data["PRInProgressQuantity"] = this.PRInProgressQuantity;
        data["PRInProgressRetention"] = this.PRInProgressRetention;
        data["PRInProgressAmount"] = this.PRInProgressAmount;
        data["ReceivedUnits"] = this.ReceivedUnits;
        data["ReceiptInProgressUnits"] = this.ReceiptInProgressUnits;
        data["ContractAmount"] = this.ContractAmount;
        data["ContractUnits"] = this.ContractUnits;
        data["TotalPercentRequest"] = this.TotalPercentRequest;
        data["TotalUnitsCompleted"] = this.TotalUnitsCompleted;
        data["TotalAmountCompleted"] = this.TotalAmountCompleted;
        data["TotalPriorAmount"] = this.TotalPriorAmount;
        data["ProjEntity"] = this.ProjEntity;
        data["GLAcct"] = this.GLAcct;
        data["GLSub"] = this.GLSub;
        data["LaborClass"] = this.LaborClass;
        data["AccountCategory"] = this.AccountCategory;
        data["RetentionMethod"] = this.RetentionMethod;
        data["ItemPercent"] = this.ItemPercent;
        data["Rate"] = this.Rate;
        data["LineDesc"] = this.LineDesc;
        data["Cap"] = this.Cap;
        data["UOM"] = this.UOM;
        return data; 
    }

    clone(): RelatedItemDetail {
        const json = this.toJSON();
        let result = new RelatedItemDetail();
        result.init(json);
        return result;
    }
}

/** Describes an SPRLineDetails Condition */
export interface IRelatedItemDetail {
    /** ID of Project (suitable for use as a key) */
    Project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** key of corresponding item on the subcontract document */
    SCDocItemKey: string;
    /** Approved (Paid) Quantity */
    ApprovedQuantity: number;
    /** Approved Retention  */
    ApprovedRetention: number;
    /** Change Order Approved  */
    ApprovedAmount: number;
    /** Change Order Approved  */
    ApprovedExpense: number;
    /** Change Order Units not yet approved */
    PendingChangeUnits: number;
    /** not yet approved */
    PendingChangeRetention: number;
    /** Change Order amount, not yet approved */
    PendingChangeAmount: number;
    /** not yet approved */
    PendingChangeExpense: number;
    /** Paid Units */
    VoucheredUnits: number;
    /** Paid Amount */
    VoucheredAmount: number;
    /** Paid Stored Material amount */
    VoucheredSMAmount: number;
    /** Amount Earned but held as retention */
    VoucheredRetention: number;
    /** Amount Earned but held as retention for stored materials */
    VoucheredSMRetention: number;
    /** Payment request units not yet approved */
    PRInProgressQuantity: number;
    /** Payment retention  not yet approved */
    PRInProgressRetention: number;
    /** Payment amount  not yet approved */
    PRInProgressAmount: number;
    /** Units received */
    ReceivedUnits: number;
    /** Units tentatively received  not yet approved */
    ReceiptInProgressUnits: number;
    /** Amount of line (includes approved changes orders) */
    ContractAmount: number;
    /** Units on line, includes change orders */
    ContractUnits: number;
    /** Percent */
    TotalPercentRequest: number;
    /** Units */
    TotalUnitsCompleted: number;
    /** Amount */
    TotalAmountCompleted: number;
    /** Previous amount (documents of same time with lesser document number) */
    TotalPriorAmount: number;
    /** WB Task Code  */
    ProjEntity?: string | undefined;
    /** Weak link to accounting GL Account */
    GLAcct?: string | undefined;
    /** Weak link to Accounting GL Subaccount */
    GLSub?: string | undefined;
    /** Code of Labor Class  */
    LaborClass?: string | undefined;
    /** Work Breakdown Account (Labor, Materials, Equipment, etc) */
    AccountCategory?: string | undefined;
    /** None or % of Total(TL) */
    RetentionMethod?: string | undefined;
    /** Used for Retention Percent if RetentionMethod is TL */
    ItemPercent: number;
    Rate: number;
    /** calculated */
    LineDesc?: string | undefined;
    /** When true, this line will have amount enforced as a max */
    Cap: boolean;
    /** Code for Unit of Measure (from Code List, set UOM) */
    UOM?: string | undefined;
}

/** Describes a sequenced recipient in a document route */
export class DocRoute implements IDocRoute {
    /** associates the row with a specific doc route */
    RouteID!: string;
    /** Link to user/contact */
    UserKey!: string;
    /** Initialized to current stage when added */
    Stage!: number;
    /** Display sequence (by name withing sequence) */
    Sequence!: number;
    /** Parallel Route Group ID */
    GroupNo!: number;
    /** Links to the user/contact that added this route */
    FromUser!: string;
    /** Status code */
    Status?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit!: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts!: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo!: boolean;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    RouteeProxy!: string;
    /** When 1, no notification emails are sent */
    PriorityOver!: number;
    ExpectProxy!: boolean;
    HasContent!: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal!: boolean;
    /** When true, the user is inactive */
    UserKey_Inactive!: boolean;
    /** When this route was reached (estimated) */
    Reached!: Date;
    /** If transmital has data */
    HasBinData!: boolean;
    /** list of choices for RouteVia */
    StatusChoices?: Suggestion[] | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Name of Person email routes are sent on-behalf-of */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route receipient  */
    Request?: string | undefined;
    /** Free form response to route receipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil!: Date;
    /** associates the row with a doc route sequence */
    RouteStepKey!: string;
    /** Identifies the user */
    ByUser!: string;
    /** The transmittal control number */
    TransNumber!: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created!: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;

    constructor(data?: IDocRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RouteID = _data["RouteID"];
            this.UserKey = _data["UserKey"];
            this.Stage = _data["Stage"];
            this.Sequence = _data["Sequence"];
            this.GroupNo = _data["GroupNo"];
            this.FromUser = _data["FromUser"];
            this.Status = _data["Status"];
            this.RouteVia = _data["RouteVia"];
            this.UserDocEdit = _data["UserDocEdit"];
            this.SendAlerts = _data["SendAlerts"];
            this.ReplyTo = _data["ReplyTo"];
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.UserName = _data["UserName"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.PriorityOver = _data["PriorityOver"];
            this.ExpectProxy = _data["ExpectProxy"];
            this.HasContent = _data["HasContent"];
            this.IsInternal = _data["IsInternal"];
            this.UserKey_Inactive = _data["UserKey_Inactive"];
            this.Reached = _data["Reached"] ? new Date(_data["Reached"].toString()) : <any>undefined;
            this.HasBinData = _data["HasBinData"];
            if (Array.isArray(_data["StatusChoices"])) {
                this.StatusChoices = [] as any;
                for (let item of _data["StatusChoices"])
                    this.StatusChoices!.push(Suggestion.fromJS(item));
            }
            if (Array.isArray(_data["RouteViaChoices"])) {
                this.RouteViaChoices = [] as any;
                for (let item of _data["RouteViaChoices"])
                    this.RouteViaChoices!.push(Suggestion.fromJS(item));
            }
            this.EmailFrom = _data["EmailFrom"];
            this.Note = _data["Note"];
            this.Request = _data["Request"];
            this.Response = _data["Response"];
            this.ResponseCode = _data["ResponseCode"];
            if (Array.isArray(_data["ResponseCodeChoices"])) {
                this.ResponseCodeChoices = [] as any;
                for (let item of _data["ResponseCodeChoices"])
                    this.ResponseCodeChoices!.push(Suggestion.fromJS(item));
            }
            this.WorkflowScript = _data["WorkflowScript"];
            this.Alerted = _data["Alerted"] ? new Date(_data["Alerted"].toString()) : <any>undefined;
            this.Downloaded = _data["Downloaded"] ? new Date(_data["Downloaded"].toString()) : <any>undefined;
            this.Acted = _data["Acted"] ? new Date(_data["Acted"].toString()) : <any>undefined;
            this.Activity = _data["Activity"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.RouteStepKey = _data["RouteStepKey"];
            this.ByUser = _data["ByUser"];
            this.TransNumber = _data["TransNumber"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.TransStatus = _data["TransStatus"];
            this.BinType = _data["BinType"];
            if (Array.isArray(_data["MenuCommands"])) {
                this.MenuCommands = [] as any;
                for (let item of _data["MenuCommands"])
                    this.MenuCommands!.push(MenuAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocRoute {
        data = typeof data === 'object' ? data : {};
        let result = new DocRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RouteID"] = this.RouteID;
        data["UserKey"] = this.UserKey;
        data["Stage"] = this.Stage;
        data["Sequence"] = this.Sequence;
        data["GroupNo"] = this.GroupNo;
        data["FromUser"] = this.FromUser;
        data["Status"] = this.Status;
        data["RouteVia"] = this.RouteVia;
        data["UserDocEdit"] = this.UserDocEdit;
        data["SendAlerts"] = this.SendAlerts;
        data["ReplyTo"] = this.ReplyTo;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["UserName"] = this.UserName;
        data["RouteeProxy"] = this.RouteeProxy;
        data["PriorityOver"] = this.PriorityOver;
        data["ExpectProxy"] = this.ExpectProxy;
        data["HasContent"] = this.HasContent;
        data["IsInternal"] = this.IsInternal;
        data["UserKey_Inactive"] = this.UserKey_Inactive;
        data["Reached"] = this.Reached ? this.Reached.toISOString() : <any>undefined;
        data["HasBinData"] = this.HasBinData;
        if (Array.isArray(this.StatusChoices)) {
            data["StatusChoices"] = [];
            for (let item of this.StatusChoices)
                data["StatusChoices"].push(item.toJSON());
        }
        if (Array.isArray(this.RouteViaChoices)) {
            data["RouteViaChoices"] = [];
            for (let item of this.RouteViaChoices)
                data["RouteViaChoices"].push(item.toJSON());
        }
        data["EmailFrom"] = this.EmailFrom;
        data["Note"] = this.Note;
        data["Request"] = this.Request;
        data["Response"] = this.Response;
        data["ResponseCode"] = this.ResponseCode;
        if (Array.isArray(this.ResponseCodeChoices)) {
            data["ResponseCodeChoices"] = [];
            for (let item of this.ResponseCodeChoices)
                data["ResponseCodeChoices"].push(item.toJSON());
        }
        data["WorkflowScript"] = this.WorkflowScript;
        data["Alerted"] = this.Alerted ? this.Alerted.toISOString() : <any>undefined;
        data["Downloaded"] = this.Downloaded ? this.Downloaded.toISOString() : <any>undefined;
        data["Acted"] = this.Acted ? this.Acted.toISOString() : <any>undefined;
        data["Activity"] = this.Activity;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["RouteStepKey"] = this.RouteStepKey;
        data["ByUser"] = this.ByUser;
        data["TransNumber"] = this.TransNumber;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["TransStatus"] = this.TransStatus;
        data["BinType"] = this.BinType;
        if (Array.isArray(this.MenuCommands)) {
            data["MenuCommands"] = [];
            for (let item of this.MenuCommands)
                data["MenuCommands"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DocRoute {
        const json = this.toJSON();
        let result = new DocRoute();
        result.init(json);
        return result;
    }
}

/** Describes a sequenced recipient in a document route */
export interface IDocRoute {
    /** associates the row with a specific doc route */
    RouteID: string;
    /** Link to user/contact */
    UserKey: string;
    /** Initialized to current stage when added */
    Stage: number;
    /** Display sequence (by name withing sequence) */
    Sequence: number;
    /** Parallel Route Group ID */
    GroupNo: number;
    /** Links to the user/contact that added this route */
    FromUser: string;
    /** Status code */
    Status?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** Controls edits to base document (AKA IsCollaborator) */
    UserDocEdit: boolean;
    /** This routee wants watchdog alerts about this document */
    SendAlerts: boolean;
    /** When true, email based routing after this sequence is sent on behalf of this routee so that they will receive replies (see EmailFrom) */
    ReplyTo: boolean;
    /** Set when first viewed */
    Viewed?: Date | undefined;
    /** Date (and sometimes Time) by which action is required */
    Due?: Date | undefined;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    RouteeProxy: string;
    /** When 1, no notification emails are sent */
    PriorityOver: number;
    ExpectProxy: boolean;
    HasContent: boolean;
    /** True when this user has CSTM | InternalStaff */
    IsInternal: boolean;
    /** When true, the user is inactive */
    UserKey_Inactive: boolean;
    /** When this route was reached (estimated) */
    Reached: Date;
    /** If transmital has data */
    HasBinData: boolean;
    /** list of choices for RouteVia */
    StatusChoices?: Suggestion[] | undefined;
    /** list of choices for RouteVia */
    RouteViaChoices?: Suggestion[] | undefined;
    /** Name of Person email routes are sent on-behalf-of */
    EmailFrom?: string | undefined;
    /** Free form */
    Note?: string | undefined;
    /** Free form instruction to route receipient  */
    Request?: string | undefined;
    /** Free form response to route receipient */
    Response?: string | undefined;
    /** Code defined in DocType specific list */
    ResponseCode?: string | undefined;
    /** list of choices for ResponseCode */
    ResponseCodeChoices?: Suggestion[] | undefined;
    /** Workflow directives */
    WorkflowScript?: string | undefined;
    /** Set when email notification is sent */
    Alerted?: Date | undefined;
    /** When Downloaded (included in activity) */
    Downloaded?: Date | undefined;
    /** Set by the data layer when Status changes */
    Acted?: Date | undefined;
    /** Summary of activity on the doc, suitable for display.  Includes Acted, Downloaded, Viewed */
    Activity?: string | undefined;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil: Date;
    /** associates the row with a doc route sequence */
    RouteStepKey: string;
    /** Identifies the user */
    ByUser: string;
    /** The transmittal control number */
    TransNumber: number;
    /** Typically when entity was first recorded; some users may be able to override for some entities */
    Created: Date;
    /** not currently used */
    TransStatus?: string | undefined;
    /** Type of binary data (DOCX, PDF, etc) */
    BinType?: string | undefined;
    /** Collection of commands for this row */
    MenuCommands?: MenuAction[] | undefined;
}

/** Attributes describing a member of a project team */
export class Suggestion implements ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;

    constructor(data?: ISuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Suggestion {
        data = typeof data === 'object' ? data : {};
        let result = new Suggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): Suggestion {
        const json = this.toJSON();
        let result = new Suggestion();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface ISuggestion {
    /** Key (empty if not applicable) */
    key?: string | undefined;
    /** display  */
    label?: string | undefined;
    /** value (if key is specified, this is the display value and key is the data value) */
    value?: string | undefined;
}

/** Describes a Menu or Action */
export class MenuAction implements IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string | undefined;
    /** optional arguement */
    CommandArgument?: string | undefined;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** True if enabled */
    Enabled!: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits!: number;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits!: number;
    /** Controls order of choices within MenuID */
    MenuSeq!: number;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled!: boolean;

    constructor(data?: IMenuAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.MenuID = _data["MenuID"];
            this.CommandArgument = _data["CommandArgument"];
            this.CommandName = _data["CommandName"];
            this.Enabled = _data["Enabled"];
            this.HasPermits = _data["HasPermits"];
            this.IconImageUrl = _data["IconImageUrl"];
            this.ItemText = _data["ItemText"];
            this.HRef = _data["HRef"];
            this.HrefTarget = _data["HrefTarget"];
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.NeedPermits = _data["NeedPermits"];
            this.MenuSeq = _data["MenuSeq"];
            this.Confirm = _data["Confirm"];
            this.HideifDisabled = _data["HideifDisabled"];
        }
    }

    static fromJS(data: any): MenuAction {
        data = typeof data === 'object' ? data : {};
        let result = new MenuAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MenuID"] = this.MenuID;
        data["CommandArgument"] = this.CommandArgument;
        data["CommandName"] = this.CommandName;
        data["Enabled"] = this.Enabled;
        data["HasPermits"] = this.HasPermits;
        data["IconImageUrl"] = this.IconImageUrl;
        data["ItemText"] = this.ItemText;
        data["HRef"] = this.HRef;
        data["HrefTarget"] = this.HrefTarget;
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["NeedPermits"] = this.NeedPermits;
        data["MenuSeq"] = this.MenuSeq;
        data["Confirm"] = this.Confirm;
        data["HideifDisabled"] = this.HideifDisabled;
        return data; 
    }

    clone(): MenuAction {
        const json = this.toJSON();
        let result = new MenuAction();
        result.init(json);
        return result;
    }
}

/** Describes a Menu or Action */
export interface IMenuAction {
    /** The menu or group that connects a series of actions */
    MenuID?: string | undefined;
    /** optional arguement */
    CommandArgument?: string | undefined;
    /** Key for this action, unique within MenuID */
    CommandName?: string | undefined;
    /** True if enabled */
    Enabled: boolean;
    /** Actual Permits this user has for UCModule and UCFunction, when insufficient, enabled will be false */
    HasPermits: number;
    /** suggested image */
    IconImageUrl?: string | undefined;
    /** Display Text */
    ItemText?: string | undefined;
    /** URL for action */
    HRef?: string | undefined;
    /** target for URL (dashboard, _blank, etc) */
    HrefTarget?: string | undefined;
    /** For a permission demand lookup */
    UCModule?: string | undefined;
    /** The function within the specified module */
    UCFunction?: string | undefined;
    /** Demanded permissions within UCModule and UCFunction  */
    NeedPermits: number;
    /** Controls order of choices within MenuID */
    MenuSeq: number;
    /** If not empty, a confirmation prompt */
    Confirm?: string | undefined;
    /** When true, and not enabled, do not bother showing */
    HideifDisabled: boolean;
}

/** Legacy Site Authentication */
export class SiteLogin implements ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed!: boolean;

    constructor(data?: ISiteLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UID = _data["UID"];
            this.PW = _data["PW"];
            this.IsHashed = _data["IsHashed"];
        }
    }

    static fromJS(data: any): SiteLogin {
        data = typeof data === 'object' ? data : {};
        let result = new SiteLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UID"] = this.UID;
        data["PW"] = this.PW;
        data["IsHashed"] = this.IsHashed;
        return data; 
    }

    clone(): SiteLogin {
        const json = this.toJSON();
        let result = new SiteLogin();
        result.init(json);
        return result;
    }
}

/** Legacy Site Authentication */
export interface ISiteLogin {
    /** User ID EG: george@acme.com */
    UID?: string | undefined;
    /** Password */
    PW?: string | undefined;
    /** Set to TRUE if password has already been hashed (rare) */
    IsHashed: boolean;
}

/** Attributes describing the currently authenticated user */
export class CurrentUser implements ICurrentUser {
    /** User Key */
    UserKey!: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    PWMustChange!: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset!: number;
    /** Password Aging is enabled for this user */
    PWAging!: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration!: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut!: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun!: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser!: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin!: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey!: string;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** This data is locked in memory */
    IsDSProtected!: boolean;

    constructor(data?: ICurrentUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserLoginName = _data["UserLoginName"];
            this.FullName = _data["FullName"];
            this.email = _data["email"];
            this.PWMustChange = _data["PWMustChange"];
            this.UserTimeZone = _data["UserTimeZone"];
            this.TZOffset = _data["TZOffset"];
            this.PWAging = _data["PWAging"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.IsLockedOut = _data["IsLockedOut"];
            this.PWExpires = _data["PWExpires"] ? new Date(_data["PWExpires"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.LockoutReason = _data["LockoutReason"];
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SolomonUser = _data["SolomonUser"];
            this.IsFirstLogin = _data["IsFirstLogin"];
            this.MasterSession = _data["MasterSession"];
            this.UserSessionKey = _data["UserSessionKey"];
            this.PictureURL = _data["PictureURL"];
            this.PDSKey = _data["PDSKey"];
            this.IsDSProtected = _data["IsDSProtected"];
        }
    }

    static fromJS(data: any): CurrentUser {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserLoginName"] = this.UserLoginName;
        data["FullName"] = this.FullName;
        data["email"] = this.email;
        data["PWMustChange"] = this.PWMustChange;
        data["UserTimeZone"] = this.UserTimeZone;
        data["TZOffset"] = this.TZOffset;
        data["PWAging"] = this.PWAging;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["IsLockedOut"] = this.IsLockedOut;
        data["PWExpires"] = this.PWExpires ? this.PWExpires.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["LockoutReason"] = this.LockoutReason;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SolomonUser"] = this.SolomonUser;
        data["IsFirstLogin"] = this.IsFirstLogin;
        data["MasterSession"] = this.MasterSession;
        data["UserSessionKey"] = this.UserSessionKey;
        data["PictureURL"] = this.PictureURL;
        data["PDSKey"] = this.PDSKey;
        data["IsDSProtected"] = this.IsDSProtected;
        return data; 
    }

    clone(): CurrentUser {
        const json = this.toJSON();
        let result = new CurrentUser();
        result.init(json);
        return result;
    }
}

/** Attributes describing the currently authenticated user */
export interface ICurrentUser {
    /** User Key */
    UserKey: string;
    /** Login ID for user in name@domain.com or similar format */
    UserLoginName?: string | undefined;
    /** Full name, eg John M. Smithe */
    FullName?: string | undefined;
    /** Email Address */
    email?: string | undefined;
    /** True if user will have to change PW soon */
    PWMustChange: boolean;
    /** Three character time zone designation */
    UserTimeZone?: string | undefined;
    /** +/- Time offset from server */
    TZOffset: number;
    /** Password Aging is enabled for this user */
    PWAging: boolean;
    /** Account expiration is enabled for this user if account is not regularly used */
    SlidingExpiration: boolean;
    /** When true, the user is currently locked out */
    IsLockedOut: boolean;
    /** When the current password will expire if PWAging is true */
    PWExpires?: Date | undefined;
    /** When this account will expire */
    Expiration?: Date | undefined;
    /** When IsLockedOut, the lockout lasts until this date and time */
    LockedOutUntil?: Date | undefined;
    /** Text why the user is locked out (suitable for display) */
    LockoutReason?: string | undefined;
    /** How many bad password attempts in a row */
    FailedLoginRun: number;
    /** When true, this exact user ID is integrated with Accounting */
    SolomonUser: boolean;
    /** When true, this is the users first interactive session */
    IsFirstLogin: boolean;
    /** Current IIS Session ID */
    MasterSession?: string | undefined;
    /** Guid for this session in xsfUserSession  */
    UserSessionKey: string;
    /** URI for an image of this user */
    PictureURL?: string | undefined;
    /** hmmm */
    PDSKey?: string | undefined;
    /** This data is locked in memory */
    IsDSProtected: boolean;
}

export class PasswordConfiguredOptions implements IPasswordConfiguredOptions {

    constructor(data?: IPasswordConfiguredOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PasswordConfiguredOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordConfiguredOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): PasswordConfiguredOptions {
        const json = this.toJSON();
        let result = new PasswordConfiguredOptions();
        result.init(json);
        return result;
    }
}

export interface IPasswordConfiguredOptions {
}

/** Permission required flag -- bit flags can be combined */
export enum PermissionFlags {
    None = 0,
    Read = 1,
    Insert = 2,
    Update = 4,
    Delete = 8,
    Blanket = 16,
}

/** Describes permission being demanded and the context */
export class PermissionContext implements IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule!: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction!: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey!: string;
    /** Document Type */
    DocTypeKey!: string;
    /** Doc Reference (seldom used) */
    DocReference!: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded!: PermissionFlags;

    constructor(data?: IPermissionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UCModule = _data["UCModule"];
            this.UCFunction = _data["UCFunction"];
            this.Project = _data["Project"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.PermissionNeeded = _data["PermissionNeeded"];
        }
    }

    static fromJS(data: any): PermissionContext {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UCModule"] = this.UCModule;
        data["UCFunction"] = this.UCFunction;
        data["Project"] = this.Project;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["PermissionNeeded"] = this.PermissionNeeded;
        return data; 
    }

    clone(): PermissionContext {
        const json = this.toJSON();
        let result = new PermissionContext();
        result.init(json);
        return result;
    }
}

/** Describes permission being demanded and the context */
export interface IPermissionContext {
    /** Module Name (SYS, LIST, PART, PAGE, DOC)  */
    UCModule: string;
    /** Internal Name (see xsfUCFunction) */
    UCFunction: string;
    /** Project ID  */
    Project?: string | undefined;
    /** Key of document - if specified, DocTypeKey, DocReference and Project are loaded from the document */
    DocMasterKey: string;
    /** Document Type */
    DocTypeKey: string;
    /** Doc Reference (seldom used) */
    DocReference: string;
    /** Bit Coded R I U D S  */
    PermissionNeeded: PermissionFlags;
}

export class TabStripDetails implements ITabStripDetails {
    TabId!: number;
    TabKey?: string | undefined;
    TabText?: string | undefined;
    TabOrder!: number;
    TabType?: string | undefined;
    AuthorizedRoles?: string | undefined;
    LinkURL?: string | undefined;
    Tip?: string | undefined;
    IsVisible!: boolean;

    constructor(data?: ITabStripDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.TabId = _data["TabId"];
            this.TabKey = _data["TabKey"];
            this.TabText = _data["TabText"];
            this.TabOrder = _data["TabOrder"];
            this.TabType = _data["TabType"];
            this.AuthorizedRoles = _data["AuthorizedRoles"];
            this.LinkURL = _data["LinkURL"];
            this.Tip = _data["Tip"];
            this.IsVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): TabStripDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TabStripDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TabId"] = this.TabId;
        data["TabKey"] = this.TabKey;
        data["TabText"] = this.TabText;
        data["TabOrder"] = this.TabOrder;
        data["TabType"] = this.TabType;
        data["AuthorizedRoles"] = this.AuthorizedRoles;
        data["LinkURL"] = this.LinkURL;
        data["Tip"] = this.Tip;
        data["IsVisible"] = this.IsVisible;
        return data; 
    }

    clone(): TabStripDetails {
        const json = this.toJSON();
        let result = new TabStripDetails();
        result.init(json);
        return result;
    }
}

export interface ITabStripDetails {
    TabId: number;
    TabKey?: string | undefined;
    TabText?: string | undefined;
    TabOrder: number;
    TabType?: string | undefined;
    AuthorizedRoles?: string | undefined;
    LinkURL?: string | undefined;
    Tip?: string | undefined;
    IsVisible: boolean;
}

/** Attributes describing a member of a project team */
export class ProjectTeamMember implements IProjectTeamMember {
    /** Primary Key */
    UserProjectKey!: string;
    /** Key of Team Member in contact table */
    UserKey!: string;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility!: string;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Role Name (see Responsibility) */
    RoleName?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting!: Date;
    /** When the team member left (or was replaced) */
    Ending!: Date;
    /** When TRUE,  shown by default */
    TeamList!: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic!: boolean;
    /** When TRUE, this team member is active */
    Active!: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic!: boolean;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserNotActive!: boolean;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IProjectTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserProjectKey = _data["UserProjectKey"];
            this.UserKey = _data["UserKey"];
            this.Responsibility = _data["Responsibility"];
            this.UserName = _data["UserName"];
            this.Company = _data["Company"];
            this.email = _data["email"];
            this.UsePhone = _data["UsePhone"];
            this.ContactProject = _data["ContactProject"];
            this.RoleDescription = _data["RoleDescription"];
            this.RoleName = _data["RoleName"];
            this.LikenessURL = _data["LikenessURL"];
            this.WebURL = _data["WebURL"];
            this.Starting = _data["Starting"] ? new Date(_data["Starting"].toString()) : <any>undefined;
            this.Ending = _data["Ending"] ? new Date(_data["Ending"].toString()) : <any>undefined;
            this.TeamList = _data["TeamList"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.UserNotPublic = _data["UserNotPublic"];
            this.UserNotActive = _data["UserNotActive"];
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTeamMember {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserProjectKey"] = this.UserProjectKey;
        data["UserKey"] = this.UserKey;
        data["Responsibility"] = this.Responsibility;
        data["UserName"] = this.UserName;
        data["Company"] = this.Company;
        data["email"] = this.email;
        data["UsePhone"] = this.UsePhone;
        data["ContactProject"] = this.ContactProject;
        data["RoleDescription"] = this.RoleDescription;
        data["RoleName"] = this.RoleName;
        data["LikenessURL"] = this.LikenessURL;
        data["WebURL"] = this.WebURL;
        data["Starting"] = this.Starting ? this.Starting.toISOString() : <any>undefined;
        data["Ending"] = this.Ending ? this.Ending.toISOString() : <any>undefined;
        data["TeamList"] = this.TeamList;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["UserNotPublic"] = this.UserNotPublic;
        data["UserNotActive"] = this.UserNotActive;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectTeamMember {
        const json = this.toJSON();
        let result = new ProjectTeamMember();
        result.init(json);
        return result;
    }
}

/** Attributes describing a member of a project team */
export interface IProjectTeamMember {
    /** Primary Key */
    UserProjectKey: string;
    /** Key of Team Member in contact table */
    UserKey: string;
    /** Key of Role Responsibility on this team (UCRoleKey) */
    Responsibility: string;
    /** Login name of the team member */
    UserName?: string | undefined;
    /** Company Name (Acme Inc) */
    Company?: string | undefined;
    /** Email address */
    email?: string | undefined;
    /** Phone chosen as primary on the contact details */
    UsePhone?: string | undefined;
    /** Freeform: how the team member designates this project   */
    ContactProject?: string | undefined;
    /** Role Description */
    RoleDescription?: string | undefined;
    /** Role Name (see Responsibility) */
    RoleName?: string | undefined;
    /** Link to likeness of this team member */
    LikenessURL?: string | undefined;
    /** Link to an external resource associated with this team member */
    WebURL?: string | undefined;
    /** By default, When the team member was added  */
    Starting: Date;
    /** When the team member left (or was replaced) */
    Ending: Date;
    /** When TRUE,  shown by default */
    TeamList: boolean;
    /** When TRUE, is visible on this team even to users that do not have can see all */
    IsPublic: boolean;
    /** When TRUE, this team member is active */
    Active: boolean;
    /** Indicates if the user is always public (as opposed to public on this team: see IsPublic) */
    UserNotPublic: boolean;
    /** When TRUE, the contact for this team member has been marked inactive */
    UserNotActive: boolean;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Summary of Project Process (Document) types */
export class TypeSummary implements ITypeSummary {
    /** Key for Process Type */
    DocTypeKey!: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open!: number;
    /** Number of documents closed */
    cnt_closed!: number;
    /** Number of documents overdue */
    cnt_overdue!: number;
    /** Number of documents due soon */
    cnt_DueSoon!: number;
    /** Number of days tile due */
    DaysTillDue!: number;
    /** User has permission to create  */
    CanAdd!: boolean;

    constructor(data?: ITypeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocType = _data["DocType"];
            this.cnt_open = _data["cnt_open"];
            this.cnt_closed = _data["cnt_closed"];
            this.cnt_overdue = _data["cnt_overdue"];
            this.cnt_DueSoon = _data["cnt_DueSoon"];
            this.DaysTillDue = _data["DaysTillDue"];
            this.CanAdd = _data["CanAdd"];
        }
    }

    static fromJS(data: any): TypeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new TypeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocType"] = this.DocType;
        data["cnt_open"] = this.cnt_open;
        data["cnt_closed"] = this.cnt_closed;
        data["cnt_overdue"] = this.cnt_overdue;
        data["cnt_DueSoon"] = this.cnt_DueSoon;
        data["DaysTillDue"] = this.DaysTillDue;
        data["CanAdd"] = this.CanAdd;
        return data; 
    }

    clone(): TypeSummary {
        const json = this.toJSON();
        let result = new TypeSummary();
        result.init(json);
        return result;
    }
}

/** Summary of Project Process (Document) types */
export interface ITypeSummary {
    /** Key for Process Type */
    DocTypeKey: string;
    /** String Process (Doc Type) Name */
    DocType?: string | undefined;
    /** Number of documents currently open */
    cnt_open: number;
    /** Number of documents closed */
    cnt_closed: number;
    /** Number of documents overdue */
    cnt_overdue: number;
    /** Number of documents due soon */
    cnt_DueSoon: number;
    /** Number of days tile due */
    DaysTillDue: number;
    /** User has permission to create  */
    CanAdd: boolean;
}

/** Process Document on a Project */
export class ProjectDocsOfType implements IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey!: string;
    /** Type of Process */
    DocTypeKey!: string;
    /** Key to Process Reference */
    DocReference!: string;
    /** Document Date (header) */
    DocDate!: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority!: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential!: boolean;
    /** Key to Contact document was "from") */
    FromUser!: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty!: string;
    /** Resolved name of Responsible Party */
    SortResp?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company!: string;
    /** Resolved Company Name  of the source Contact  */
    SortCompany?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person)   */
    SortAuthor?: string | undefined;
    /** When the document/process is due */
    Due!: Date;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** check this */
    SpecSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved name of subtype */
    SubtypeDescription?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact!: number;
    /** Custome Amount */
    csAmount!: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Specification (document header) */
    Specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact!: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq!: number;
    /** Number of stages of routing  */
    MaxStage!: number;
    /** How many files are attached */
    FilesAttached!: number;

    constructor(data?: IProjectDocsOfType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.DocReference = _data["DocReference"];
            this.DocDate = _data["DocDate"] ? new Date(_data["DocDate"].toString()) : <any>undefined;
            this.DocNo = _data["DocNo"];
            this.DocBatchNo = _data["DocBatchNo"];
            this.SourceDocNo = _data["SourceDocNo"];
            this.Title = _data["Title"];
            this.Priority = _data["Priority"];
            this.Confidential = _data["Confidential"];
            this.FromUser = _data["FromUser"];
            this.SortFrom = _data["SortFrom"];
            this.ResponsibleParty = _data["ResponsibleParty"];
            this.SortResp = _data["SortResp"];
            this.Company = _data["Company"];
            this.SortCompany = _data["SortCompany"];
            this.ToUser = _data["ToUser"];
            this.SortTo = _data["SortTo"];
            this.Author = _data["Author"];
            this.SortAuthor = _data["SortAuthor"];
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Signoff = _data["Signoff"] ? new Date(_data["Signoff"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Project = _data["Project"];
            this.SpecSection = _data["SpecSection"];
            this.SubContract = _data["SubContract"];
            this.PayControl = _data["PayControl"];
            this.Subtype = _data["Subtype"];
            this.SubtypeDescription = _data["SubtypeDescription"];
            this.Status = _data["Status"];
            this.CostImpact = _data["CostImpact"];
            this.csAmount = _data["csAmount"];
            this.Subsegment = _data["Subsegment"];
            this.ContractType = _data["ContractType"];
            this.SourceDate = _data["SourceDate"] ? new Date(_data["SourceDate"].toString()) : <any>undefined;
            this.PayItemNumber = _data["PayItemNumber"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.Specification = _data["Specification"];
            this.SourceContact = _data["SourceContact"];
            this.CurrentSeq = _data["CurrentSeq"];
            this.MaxStage = _data["MaxStage"];
            this.FilesAttached = _data["FilesAttached"];
        }
    }

    static fromJS(data: any): ProjectDocsOfType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDocsOfType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTypeKey"] = this.DocTypeKey;
        data["DocReference"] = this.DocReference;
        data["DocDate"] = this.DocDate ? this.DocDate.toISOString() : <any>undefined;
        data["DocNo"] = this.DocNo;
        data["DocBatchNo"] = this.DocBatchNo;
        data["SourceDocNo"] = this.SourceDocNo;
        data["Title"] = this.Title;
        data["Priority"] = this.Priority;
        data["Confidential"] = this.Confidential;
        data["FromUser"] = this.FromUser;
        data["SortFrom"] = this.SortFrom;
        data["ResponsibleParty"] = this.ResponsibleParty;
        data["SortResp"] = this.SortResp;
        data["Company"] = this.Company;
        data["SortCompany"] = this.SortCompany;
        data["ToUser"] = this.ToUser;
        data["SortTo"] = this.SortTo;
        data["Author"] = this.Author;
        data["SortAuthor"] = this.SortAuthor;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Signoff"] = this.Signoff ? this.Signoff.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Project"] = this.Project;
        data["SpecSection"] = this.SpecSection;
        data["SubContract"] = this.SubContract;
        data["PayControl"] = this.PayControl;
        data["Subtype"] = this.Subtype;
        data["SubtypeDescription"] = this.SubtypeDescription;
        data["Status"] = this.Status;
        data["CostImpact"] = this.CostImpact;
        data["csAmount"] = this.csAmount;
        data["Subsegment"] = this.Subsegment;
        data["ContractType"] = this.ContractType;
        data["SourceDate"] = this.SourceDate ? this.SourceDate.toISOString() : <any>undefined;
        data["PayItemNumber"] = this.PayItemNumber;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["Specification"] = this.Specification;
        data["SourceContact"] = this.SourceContact;
        data["CurrentSeq"] = this.CurrentSeq;
        data["MaxStage"] = this.MaxStage;
        data["FilesAttached"] = this.FilesAttached;
        return data; 
    }

    clone(): ProjectDocsOfType {
        const json = this.toJSON();
        let result = new ProjectDocsOfType();
        result.init(json);
        return result;
    }
}

/** Process Document on a Project */
export interface IProjectDocsOfType {
    /** Key to Document (required to open) */
    DocMasterKey: string;
    /** Type of Process */
    DocTypeKey: string;
    /** Key to Process Reference */
    DocReference: string;
    /** Document Date (header) */
    DocDate: Date;
    /** Document Number (header; usually read only) */
    DocNo?: string | undefined;
    /** Batch Number (often unused) */
    DocBatchNo?: string | undefined;
    /** Source Document Number (eg: invoice number for a vendor invoice) */
    SourceDocNo?: string | undefined;
    /** Document Title */
    Title?: string | undefined;
    /** Document Priority 1==High */
    Priority: number;
    /** When true, document is confidential (only name routes have access) */
    Confidential: boolean;
    /** Key to Contact document was "from") */
    FromUser: string;
    /** Resolved name of user the Document is "from" */
    SortFrom?: string | undefined;
    /** Key to contact "Responsible" - used for Ball in Court and other use cases */
    ResponsibleParty: string;
    /** Resolved name of Responsible Party */
    SortResp?: string | undefined;
    /** Key for Contact, from SourceContact or ResponsibleParty or Doc Creator  */
    Company: string;
    /** Resolved Company Name  of the source Contact  */
    SortCompany?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    ToUser?: string | undefined;
    /** Resolved name of contact that this document is "to" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person) */
    SortTo?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Name), or data on address (Company or Person)   */
    Author?: string | undefined;
    /** Resolved name of contact that this document is "FROM" (uses To Address, contact (Compnay or Sort Name), or data on address (Company or Person)   */
    SortAuthor?: string | undefined;
    /** When the document/process is due */
    Due: Date;
    /** when the document/process was approved */
    Signoff?: Date | undefined;
    /** when the document/process was closed */
    Closed?: Date | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** check this */
    SpecSection?: string | undefined;
    /** Subcontract number (shared by commitment, payment requests, CCO, receipts, etc) */
    SubContract?: string | undefined;
    /** Flag indicating pay control option (auto, warn, block) */
    PayControl?: string | undefined;
    /** Subtype code */
    Subtype?: string | undefined;
    /** Resolved name of subtype */
    SubtypeDescription?: string | undefined;
    /** Status Code */
    Status?: string | undefined;
    /** Value of document/process - usually sum of Expense Amount on items (see DocFormula rule group) */
    CostImpact: number;
    /** Custome Amount */
    csAmount: number;
    /** Subsegment code */
    Subsegment?: string | undefined;
    /** Contract type code */
    ContractType?: string | undefined;
    /** Source date for document (eg invoice date) */
    SourceDate?: Date | undefined;
    /** Payment Item Number */
    PayItemNumber?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Specification (document header) */
    Specification?: string | undefined;
    /** Key of Primary Source Contact of document (eq vendor on commitments and related docs) */
    SourceContact: string;
    /** Current Routing sequence (zero if route is complete) */
    CurrentSeq: number;
    /** Number of stages of routing  */
    MaxStage: number;
    /** How many files are attached */
    FilesAttached: number;
}

/** Primary Summary */
export class ProjectSummary implements IProjectSummary {
    /** Project ID */
    Project!: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude!: number;
    /** Geo longitude from Project Setup Tab */
    longitude!: number;
    /** Start Date from Project Setup Dates tab */
    StartDate!: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate!: Date;
    /** Key for this user on project team */
    UserProjectKey!: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact!: string;
    /** Key for Image */
    ImageKey!: string;
    /** TRUE if this project is on the user list */
    UserList!: boolean;

    constructor(data?: IProjectSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectName = _data["ProjectName"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Description = _data["Description"];
            this.StatusText = _data["StatusText"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.StartDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
            this.FinishDate = _data["FinishDate"] ? new Date(_data["FinishDate"].toString()) : <any>undefined;
            this.UserProjectKey = _data["UserProjectKey"];
            this.SourceContact = _data["SourceContact"];
            this.ImageKey = _data["ImageKey"];
            this.UserList = _data["UserList"];
        }
    }

    static fromJS(data: any): ProjectSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectName"] = this.ProjectName;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Description"] = this.Description;
        data["StatusText"] = this.StatusText;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["StartDate"] = this.StartDate ? this.StartDate.toISOString() : <any>undefined;
        data["FinishDate"] = this.FinishDate ? this.FinishDate.toISOString() : <any>undefined;
        data["UserProjectKey"] = this.UserProjectKey;
        data["SourceContact"] = this.SourceContact;
        data["ImageKey"] = this.ImageKey;
        data["UserList"] = this.UserList;
        return data; 
    }

    clone(): ProjectSummary {
        const json = this.toJSON();
        let result = new ProjectSummary();
        result.init(json);
        return result;
    }
}

/** Primary Summary */
export interface IProjectSummary {
    /** Project ID */
    Project: string;
    /** Project Name */
    ProjectName?: string | undefined;
    /** Site Address Line 1 */
    Addr1?: string | undefined;
    /** Site Address Line 2 */
    Addr2?: string | undefined;
    /** Site Address City */
    City?: string | undefined;
    /** Site Address State */
    State?: string | undefined;
    /** Site Address Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Description from Project Setup Scope */
    Description?: string | undefined;
    /** Resolved Status */
    StatusText?: string | undefined;
    /** External Status from Project Setup Tab */
    ExternalStatus?: string | undefined;
    /** External Schedule from Project Setup Tab */
    ExternalSchedule?: string | undefined;
    /** Person on Site Address */
    Person?: string | undefined;
    /** Company */
    Company?: string | undefined;
    /** Geo Latitude from Project Setup Tab */
    latitude: number;
    /** Geo longitude from Project Setup Tab */
    longitude: number;
    /** Start Date from Project Setup Dates tab */
    StartDate: Date;
    /** Finish Date from Project Setup Dates tab */
    FinishDate: Date;
    /** Key for this user on project team */
    UserProjectKey: string;
    /** Key for Project Setup Source Contact (Customer/Owner) */
    SourceContact: string;
    /** Key for Image */
    ImageKey: string;
    /** TRUE if this project is on the user list */
    UserList: boolean;
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export class CodeChoice implements ICodeChoice {
    /** Name for a set of choices */
    SetName!: string;
    /** Code */
    Code!: string;
    /** Display Value  */
    Description!: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active!: boolean;
    /** True if code is allowed for new records */
    OnAdd!: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag!: boolean;

    constructor(data?: ICodeChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.SetName = _data["SetName"];
            this.Code = _data["Code"];
            this.Description = _data["Description"];
            this.NextSet = _data["NextSet"];
            this.Active = _data["Active"];
            this.OnAdd = _data["OnAdd"];
            this.CodeFlag = _data["CodeFlag"];
        }
    }

    static fromJS(data: any): CodeChoice {
        data = typeof data === 'object' ? data : {};
        let result = new CodeChoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SetName"] = this.SetName;
        data["Code"] = this.Code;
        data["Description"] = this.Description;
        data["NextSet"] = this.NextSet;
        data["Active"] = this.Active;
        data["OnAdd"] = this.OnAdd;
        data["CodeFlag"] = this.CodeFlag;
        return data; 
    }

    clone(): CodeChoice {
        const json = this.toJSON();
        let result = new CodeChoice();
        result.init(json);
        return result;
    }
}

/** Attributes describing a choice defined in Code Maintenance - for context UI */
export interface ICodeChoice {
    /** Name for a set of choices */
    SetName: string;
    /** Code */
    Code: string;
    /** Display Value  */
    Description: string;
    /** For cascading codes, names the next code set */
    NextSet?: string | undefined;
    /** True if code is still active */
    Active: boolean;
    /** True if code is allowed for new records */
    OnAdd: boolean;
    /** Code Flag - use varies by code set */
    CodeFlag: boolean;
}

/** Describes a Part, including the fields available to this user */
export class UIDisplayPart implements IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explaination or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI!: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI!: boolean;

    constructor(data?: IUIDisplayPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartName = _data["PartName"];
            this.DisplayName = _data["DisplayName"];
            this.Description = _data["Description"];
            this.GetAPI = _data["GetAPI"];
            this.SortHint = _data["SortHint"];
            this.PartType = _data["PartType"];
            if (Array.isArray(_data["UIItems"])) {
                this.UIItems = [] as any;
                for (let item of _data["UIItems"])
                    this.UIItems!.push(UIDisplayConfig.fromJS(item));
            }
            if (Array.isArray(_data["UIFilters"])) {
                this.UIFilters = [] as any;
                for (let item of _data["UIFilters"])
                    this.UIFilters!.push(UIDisplayFilter.fromJS(item));
            }
            this.ViaUI = _data["ViaUI"];
            this.wbxUI = _data["wbxUI"];
        }
    }

    static fromJS(data: any): UIDisplayPart {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartName"] = this.PartName;
        data["DisplayName"] = this.DisplayName;
        data["Description"] = this.Description;
        data["GetAPI"] = this.GetAPI;
        data["SortHint"] = this.SortHint;
        data["PartType"] = this.PartType;
        if (Array.isArray(this.UIItems)) {
            data["UIItems"] = [];
            for (let item of this.UIItems)
                data["UIItems"].push(item.toJSON());
        }
        if (Array.isArray(this.UIFilters)) {
            data["UIFilters"] = [];
            for (let item of this.UIFilters)
                data["UIFilters"].push(item.toJSON());
        }
        data["ViaUI"] = this.ViaUI;
        data["wbxUI"] = this.wbxUI;
        return data; 
    }

    clone(): UIDisplayPart {
        const json = this.toJSON();
        let result = new UIDisplayPart();
        result.init(json);
        return result;
    }
}

/** Describes a Part, including the fields available to this user */
export interface IUIDisplayPart {
    /** Reference to UI Part by name (Alternate Key) */
    PartName?: string | undefined;
    /** Display Name  */
    DisplayName?: string | undefined;
    /** Free form explaination or generic description   */
    Description?: string | undefined;
    /** API hint */
    GetAPI?: string | undefined;
    /** When not empty, provides hint as to initial sort */
    SortHint?: string | undefined;
    /** G(rid);F(ilters);P(anel);T(abs)
D(ashboard);L(ayout);N(avigation);GG: multiple grid; CC: Combo Control */
    PartType?: string | undefined;
    /** List of UI Items  */
    UIItems?: UIDisplayConfig[] | undefined;
    /** List of UI filters  */
    UIFilters?: UIDisplayFilter[] | undefined;
    /** When true, configurable for legacy UI */
    ViaUI: boolean;
    /** When true, configurable for WebIX UI */
    wbxUI: boolean;
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export class UIDisplayConfig implements IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey!: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo!: number;
    /** Max characters, for character types, this is from database size */
    MaxChars!: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore!: number;
    /** For controling tab order */
    SeqData!: number;
    /** When TRUE, UI will be read only */
    IsReadOnly!: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible!: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault!: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML!: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width!: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;

    constructor(data?: IUIDisplayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartConfigKey = _data["PartConfigKey"];
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.Label = _data["Label"];
            this.LookupName = _data["LookupName"];
            this.DisplayFormat = _data["DisplayFormat"];
            if (_data["OtherProperties"]) {
                this.OtherProperties = {} as any;
                for (let key in _data["OtherProperties"]) {
                    if (_data["OtherProperties"].hasOwnProperty(key))
                        this.OtherProperties![key] = _data["OtherProperties"][key];
                }
            }
            this.ClickAction = _data["ClickAction"];
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.MaxChars = _data["MaxChars"];
            this.RequiredBefore = _data["RequiredBefore"];
            this.SeqData = _data["SeqData"];
            this.IsReadOnly = _data["IsReadOnly"];
            this.Visible = _data["Visible"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.HTML = _data["HTML"];
            this.Overlay = _data["Overlay"];
            this.ShownWhen = _data["ShownWhen"];
            this.ValidateAgainst = _data["ValidateAgainst"];
            this.ValidateTextAgainst = _data["ValidateTextAgainst"];
            this.ValidationMax = _data["ValidationMax"];
            this.ValidationMin = _data["ValidationMin"];
            this.Width = _data["Width"];
            this.WidthCSS = _data["WidthCSS"];
            this.UIType = _data["UIType"];
        }
    }

    static fromJS(data: any): UIDisplayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.PartConfigKey;
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["Label"] = this.Label;
        data["LookupName"] = this.LookupName;
        data["DisplayFormat"] = this.DisplayFormat;
        if (this.OtherProperties) {
            data["OtherProperties"] = {};
            for (let key in this.OtherProperties) {
                if (this.OtherProperties.hasOwnProperty(key))
                    data["OtherProperties"][key] = this.OtherProperties[key];
            }
        }
        data["ClickAction"] = this.ClickAction;
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["MaxChars"] = this.MaxChars;
        data["RequiredBefore"] = this.RequiredBefore;
        data["SeqData"] = this.SeqData;
        data["IsReadOnly"] = this.IsReadOnly;
        data["Visible"] = this.Visible;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["HTML"] = this.HTML;
        data["Overlay"] = this.Overlay;
        data["ShownWhen"] = this.ShownWhen;
        data["ValidateAgainst"] = this.ValidateAgainst;
        data["ValidateTextAgainst"] = this.ValidateTextAgainst;
        data["ValidationMax"] = this.ValidationMax;
        data["ValidationMin"] = this.ValidationMin;
        data["Width"] = this.Width;
        data["WidthCSS"] = this.WidthCSS;
        data["UIType"] = this.UIType;
        return data; 
    }

    clone(): UIDisplayConfig {
        const json = this.toJSON();
        let result = new UIDisplayConfig();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI element (not for edit, see UIPartConfig) */
export interface IUIDisplayConfig {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey: string;
    /** One of the UI item names listed in Page.Config (PartCfgItem) */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 (AuxData Name-Value Pairs) */
    OtherProperties?: { [key: string]: any; } | undefined;
    /** Click Action */
    ClickAction?: string | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding length, in characters allowed in this field.  See also MaxChars */
    LimitTo: number;
    /** Max characters, for character types, this is from database size */
    MaxChars: number;
    /** For indicating a value is (or can sometimes be) required (zero is not required) */
    RequiredBefore: number;
    /** For controling tab order */
    SeqData: number;
    /** When TRUE, UI will be read only */
    IsReadOnly: boolean;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** When 1, allow HTML */
    HTML: boolean;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
    /** Limits Visibility to certain conditions */
    ShownWhen?: string | undefined;
    /** DV function used to validate */
    ValidateAgainst?: string | undefined;
    /** DV function used to validate alternate text (such as email -&gt; contact) */
    ValidateTextAgainst?: string | undefined;
    /** Max */
    ValidationMax?: string | undefined;
    /** Min */
    ValidationMin?: string | undefined;
    /** Width expressed in Pixels (if possible) */
    Width: number;
    /** HTML friendly, CSS compliant width; eg 20ex or 40% */
    WidthCSS?: string | undefined;
    /** textbox, freeform, checkbox, contact, selectone (see ENUM UITypeNames) */
    UIType?: string | undefined;
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export class UIDisplayFilter implements IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey!: string;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo!: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible!: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault!: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;

    constructor(data?: IUIDisplayFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.PartConfigKey = _data["PartConfigKey"];
            this.ItemName = _data["ItemName"];
            this.DataMember = _data["DataMember"];
            this.DataField = _data["DataField"];
            this.Label = _data["Label"];
            this.LookupName = _data["LookupName"];
            this.DisplayFormat = _data["DisplayFormat"];
            if (_data["AuxData"]) {
                this.AuxData = {} as any;
                for (let key in _data["AuxData"]) {
                    if (_data["AuxData"].hasOwnProperty(key))
                        this.AuxData![key] = _data["AuxData"][key];
                }
            }
            this.HelpText = _data["HelpText"];
            this.LimitTo = _data["LimitTo"];
            this.DefaultValue = _data["DefaultValue"];
            this.Visible = _data["Visible"];
            this.IsInternalDefault = _data["IsInternalDefault"];
            this.CSS = _data["CSS"];
            this.DV = _data["DV"];
            this.DependsOn = _data["DependsOn"];
            this.Overlay = _data["Overlay"];
        }
    }

    static fromJS(data: any): UIDisplayFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UIDisplayFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartConfigKey"] = this.PartConfigKey;
        data["ItemName"] = this.ItemName;
        data["DataMember"] = this.DataMember;
        data["DataField"] = this.DataField;
        data["Label"] = this.Label;
        data["LookupName"] = this.LookupName;
        data["DisplayFormat"] = this.DisplayFormat;
        if (this.AuxData) {
            data["AuxData"] = {};
            for (let key in this.AuxData) {
                if (this.AuxData.hasOwnProperty(key))
                    data["AuxData"][key] = this.AuxData[key];
            }
        }
        data["HelpText"] = this.HelpText;
        data["LimitTo"] = this.LimitTo;
        data["DefaultValue"] = this.DefaultValue;
        data["Visible"] = this.Visible;
        data["IsInternalDefault"] = this.IsInternalDefault;
        data["CSS"] = this.CSS;
        data["DV"] = this.DV;
        data["DependsOn"] = this.DependsOn;
        data["Overlay"] = this.Overlay;
        return data; 
    }

    clone(): UIDisplayFilter {
        const json = this.toJSON();
        let result = new UIDisplayFilter();
        result.init(json);
        return result;
    }
}

/** Describes the live configuration for a UI filter (not for edit, see UIPartConfig) */
export interface IUIDisplayFilter {
    /** Key for this Configuration Entry (for link to edit mode) */
    PartConfigKey: string;
    /** One of the UI item names   */
    ItemName?: string | undefined;
    /** Name of a table in the XSF schema (similar to SQL table name; may not match API model name) */
    DataMember?: string | undefined;
    /** Name of a field in the schema */
    DataField?: string | undefined;
    /** The visible label for this entry */
    Label?: string | undefined;
    /** Name of lookup */
    LookupName?: string | undefined;
    /** F2, C4, etc, plus some special cases (see KBA) */
    DisplayFormat?: string | undefined;
    /** see KBA-01336 */
    AuxData?: { [key: string]: any; } | undefined;
    /** For quick help */
    HelpText?: string | undefined;
    /** For overriding allowed length */
    LimitTo: number;
    /** Provides a default for a filter ( 1 for true/checked ) */
    DefaultValue?: string | undefined;
    /** Controls the visible attribute (or sets a boolean value) */
    Visible: boolean;
    /** When true, this data is object is from internal defaults */
    IsInternalDefault: boolean;
    /** CSS to be applied */
    CSS?: string | undefined;
    /** Client Side Describe Value name */
    DV?: string | undefined;
    /** Lookups and DV depend on these fields (up to 4) */
    DependsOn?: string | undefined;
    /** HTML 5 Placeholder text */
    Overlay?: string | undefined;
}

/** Primary Site Weather Now */
export class ProjKPIFact implements IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative!: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;

    constructor(data?: IProjKPIFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Column = _data["Column"];
            this.Label = _data["Label"];
            this.Value = _data["Value"];
            this.Action = _data["Action"];
            this.DForm = _data["DForm"];
            this.TForm = _data["TForm"];
            this.Negative = _data["Negative"];
            this.ItemName = _data["ItemName"];
        }
    }

    static fromJS(data: any): ProjKPIFact {
        data = typeof data === 'object' ? data : {};
        let result = new ProjKPIFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Column"] = this.Column;
        data["Label"] = this.Label;
        data["Value"] = this.Value;
        data["Action"] = this.Action;
        data["DForm"] = this.DForm;
        data["TForm"] = this.TForm;
        data["Negative"] = this.Negative;
        data["ItemName"] = this.ItemName;
        return data; 
    }

    clone(): ProjKPIFact {
        const json = this.toJSON();
        let result = new ProjKPIFact();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjKPIFact {
    /** Target which KPI column */
    Column?: string | undefined;
    /** Label  */
    Label?: string | undefined;
    /** Value to display */
    Value?: string | undefined;
    /** Set if value has a click action */
    Action?: string | undefined;
    /** Display Format (C2) */
    DForm?: string | undefined;
    /** CSS to apply */
    TForm?: string | undefined;
    Negative: boolean;
    /** UI CFG Item Name */
    ItemName?: string | undefined;
}

/** Summary information about a contact */
export class ContactSummary implements IContactSummary {
    /** Link to user/contact */
    UserKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser!: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags!: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active!: boolean;
    /** When true, there are no references to this contact */
    OkToDelete!: boolean;
    /** When true, this contact came from an external source */
    IsXTS!: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn!: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut!: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary!: boolean;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.SortName = _data["SortName"];
            this.Email = _data["Email"];
            this.UsePhone = _data["UsePhone"];
            this.Fax = _data["Fax"];
            this.sfUser = _data["sfUser"];
            this.ContactType = _data["ContactType"];
            this.ContactFlags = _data["ContactFlags"];
            this.ExternalID = _data["ExternalID"];
            this.Company = _data["Company"];
            this.CSIList = _data["CSIList"];
            this.Active = _data["Active"];
            this.OkToDelete = _data["OkToDelete"];
            this.IsXTS = _data["IsXTS"];
            this.XTSBlockIn = _data["XTSBlockIn"];
            this.XTSBlockOut = _data["XTSBlockOut"];
            this.IsPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["SortName"] = this.SortName;
        data["Email"] = this.Email;
        data["UsePhone"] = this.UsePhone;
        data["Fax"] = this.Fax;
        data["sfUser"] = this.sfUser;
        data["ContactType"] = this.ContactType;
        data["ContactFlags"] = this.ContactFlags;
        data["ExternalID"] = this.ExternalID;
        data["Company"] = this.Company;
        data["CSIList"] = this.CSIList;
        data["Active"] = this.Active;
        data["OkToDelete"] = this.OkToDelete;
        data["IsXTS"] = this.IsXTS;
        data["XTSBlockIn"] = this.XTSBlockIn;
        data["XTSBlockOut"] = this.XTSBlockOut;
        data["IsPrimary"] = this.IsPrimary;
        return data; 
    }

    clone(): ContactSummary {
        const json = this.toJSON();
        let result = new ContactSummary();
        result.init(json);
        return result;
    }
}

/** Summary information about a contact */
export interface IContactSummary {
    /** Link to user/contact */
    UserKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Standard SMTP Email Address */
    Email?: string | undefined;
    /** Which phone is preferred */
    UsePhone?: string | undefined;
    /** Predominantly Obsolete */
    Fax?: string | undefined;
    /** When True, can log in to sfPMS */
    sfUser: boolean;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Bit coded  */
    ContactFlags: number;
    /** ID from external source (customer or vendor ID, revision or batch id) */
    ExternalID?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** For Vendors, indicate related CSI  */
    CSIList?: string | undefined;
    /** When false, this row is ignored and ineffective */
    Active: boolean;
    /** When true, there are no references to this contact */
    OkToDelete: boolean;
    /** When true, this contact came from an external source */
    IsXTS: boolean;
    /** When true, external changes to this contact are currently ignored */
    XTSBlockIn: boolean;
    /** When true, changes to this contact are not being shared with external peer */
    XTSBlockOut: boolean;
    /** When true, this is the company contact - not a person at the company */
    IsPrimary: boolean;
}

/** Various filters for contact search */
export class ContactFilters implements IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users!: boolean;
    /** When true, result is limited to  */
    Customers!: boolean;
    /** When true, result is limited to  */
    Employee!: boolean;
    /** When true, result is limited to  */
    Public!: boolean;
    /** When true, result is limited to primary company contacts  */
    Company!: boolean;
    /** When true, result is limited to  */
    Vendors!: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState!: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;

    constructor(data?: IContactFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.NameLike = _data["NameLike"];
            this.EmailLike = _data["EmailLike"];
            this.CompanyLike = _data["CompanyLike"];
            this.LocationLike = _data["LocationLike"];
            this.IDLike = _data["IDLike"];
            this.CSIListLike = _data["CSIListLike"];
            this.PhoneLike = _data["PhoneLike"];
            this.Users = _data["Users"];
            this.Customers = _data["Customers"];
            this.Employee = _data["Employee"];
            this.Public = _data["Public"];
            this.Company = _data["Company"];
            this.Vendors = _data["Vendors"];
            this.ContactState = _data["ContactState"];
            this.RoleKey = _data["RoleKey"];
            this.UserKey = _data["UserKey"];
            this.FromDate = _data["FromDate"] ? new Date(_data["FromDate"].toString()) : <any>undefined;
            this.ThruDate = _data["ThruDate"] ? new Date(_data["ThruDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactFilters {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NameLike"] = this.NameLike;
        data["EmailLike"] = this.EmailLike;
        data["CompanyLike"] = this.CompanyLike;
        data["LocationLike"] = this.LocationLike;
        data["IDLike"] = this.IDLike;
        data["CSIListLike"] = this.CSIListLike;
        data["PhoneLike"] = this.PhoneLike;
        data["Users"] = this.Users;
        data["Customers"] = this.Customers;
        data["Employee"] = this.Employee;
        data["Public"] = this.Public;
        data["Company"] = this.Company;
        data["Vendors"] = this.Vendors;
        data["ContactState"] = this.ContactState;
        data["RoleKey"] = this.RoleKey;
        data["UserKey"] = this.UserKey;
        data["FromDate"] = this.FromDate ? this.FromDate.toISOString() : <any>undefined;
        data["ThruDate"] = this.ThruDate ? this.ThruDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ContactFilters {
        const json = this.toJSON();
        let result = new ContactFilters();
        result.init(json);
        return result;
    }
}

/** Various filters for contact search */
export interface IContactFilters {
    /** Name like */
    NameLike?: string | undefined;
    /** Email  */
    EmailLike?: string | undefined;
    /** Company like  */
    CompanyLike?: string | undefined;
    /** Location */
    LocationLike?: string | undefined;
    /** ID like (vendor, customer, employee IDs) */
    IDLike?: string | undefined;
    /** For Vendors, specified related CSI  */
    CSIListLike?: string | undefined;
    /** Phone Like (matches any phone number) */
    PhoneLike?: string | undefined;
    /** When true, result is limited to  */
    Users: boolean;
    /** When true, result is limited to  */
    Customers: boolean;
    /** When true, result is limited to  */
    Employee: boolean;
    /** When true, result is limited to  */
    Public: boolean;
    /** When true, result is limited to primary company contacts  */
    Company: boolean;
    /** When true, result is limited to  */
    Vendors: boolean;
    /** 1==Active;0==Inactive; 2==Both */
    ContactState: number;
    /** UCRole Key, or use 00000000-0000-0000-0000-000000000000 for unspecified */
    RoleKey?: string | undefined;
    /** Use 00000000-0000-0000-0000-000000000000 for unspecified */
    UserKey?: string | undefined;
    /** Default 2000-01-01 */
    FromDate?: Date | undefined;
    /** Default today */
    ThruDate?: Date | undefined;
}

/** Describes a contact */
export class Contact implements IContact {
    /** Key for this user/contact */
    UserKey!: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone!: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility!: string;
    /** Key to primary company */
    ContactCompanyKey!: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr!: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects!: boolean;
    /** When True, can log in to dashboard */
    sfUser!: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic!: boolean;
    /** When false, this row is ignored and ineffective */
    Active!: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser!: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration!: boolean;
    /** When TRUE, user must change password */
    PWMustChange!: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging!: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel!: number;
    /** Checksum of all externally syched data */
    SynchCheck!: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun!: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created!: Date;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.UserKey = _data["UserKey"];
            this.UserName = _data["UserName"];
            this.UserLogin = _data["UserLogin"];
            this.FederatedIdentityInfo = _data["FederatedIdentityInfo"];
            this.SortName = _data["SortName"];
            this.FamiliarName = _data["FamiliarName"];
            this.Salutation = _data["Salutation"];
            this.Title = _data["Title"];
            this.Role = _data["Role"];
            this.EMail = _data["EMail"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.cell = _data["cell"];
            this.pager = _data["pager"];
            this.Company = _data["Company"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.Country = _data["Country"];
            this.County = _data["County"];
            this.TimeZone = _data["TimeZone"];
            this.IMService = _data["IMService"];
            this.IMHandle = _data["IMHandle"];
            this.WebURL = _data["WebURL"];
            this.VendorID = _data["VendorID"];
            this.EmployeeID = _data["EmployeeID"];
            this.ContactType = _data["ContactType"];
            this.RouteVia = _data["RouteVia"];
            this.ShowPhone = _data["ShowPhone"];
            this.RouteeProxy = _data["RouteeProxy"];
            this.DefaultResponsibility = _data["DefaultResponsibility"];
            this.ContactCompanyKey = _data["ContactCompanyKey"];
            this.Signature = _data["Signature"];
            this.Likeness = _data["Likeness"];
            this.UseCompanyAddr = _data["UseCompanyAddr"];
            this.ShowNewProjects = _data["ShowNewProjects"];
            this.sfUser = _data["sfUser"];
            this.IsPublic = _data["IsPublic"];
            this.Active = _data["Active"];
            this.SolomonUser = _data["SolomonUser"];
            this.SlidingExpiration = _data["SlidingExpiration"];
            this.PWMustChange = _data["PWMustChange"];
            this.PWAging = _data["PWAging"];
            this.DivisionID = _data["DivisionID"];
            this.LockoutReason = _data["LockoutReason"];
            this.OrgLevel = _data["OrgLevel"];
            this.SynchCheck = _data["SynchCheck"];
            this.FailedLoginRun = _data["FailedLoginRun"];
            this.SuppressNotifyUntil = _data["SuppressNotifyUntil"] ? new Date(_data["SuppressNotifyUntil"].toString()) : <any>undefined;
            this.LastLogin = _data["LastLogin"] ? new Date(_data["LastLogin"].toString()) : <any>undefined;
            this.LastPWChange = _data["LastPWChange"] ? new Date(_data["LastPWChange"].toString()) : <any>undefined;
            this.LockedOutUntil = _data["LockedOutUntil"] ? new Date(_data["LockedOutUntil"].toString()) : <any>undefined;
            this.Expiration = _data["Expiration"] ? new Date(_data["Expiration"].toString()) : <any>undefined;
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserKey"] = this.UserKey;
        data["UserName"] = this.UserName;
        data["UserLogin"] = this.UserLogin;
        data["FederatedIdentityInfo"] = this.FederatedIdentityInfo;
        data["SortName"] = this.SortName;
        data["FamiliarName"] = this.FamiliarName;
        data["Salutation"] = this.Salutation;
        data["Title"] = this.Title;
        data["Role"] = this.Role;
        data["EMail"] = this.EMail;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["cell"] = this.cell;
        data["pager"] = this.pager;
        data["Company"] = this.Company;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["Country"] = this.Country;
        data["County"] = this.County;
        data["TimeZone"] = this.TimeZone;
        data["IMService"] = this.IMService;
        data["IMHandle"] = this.IMHandle;
        data["WebURL"] = this.WebURL;
        data["VendorID"] = this.VendorID;
        data["EmployeeID"] = this.EmployeeID;
        data["ContactType"] = this.ContactType;
        data["RouteVia"] = this.RouteVia;
        data["ShowPhone"] = this.ShowPhone;
        data["RouteeProxy"] = this.RouteeProxy;
        data["DefaultResponsibility"] = this.DefaultResponsibility;
        data["ContactCompanyKey"] = this.ContactCompanyKey;
        data["Signature"] = this.Signature;
        data["Likeness"] = this.Likeness;
        data["UseCompanyAddr"] = this.UseCompanyAddr;
        data["ShowNewProjects"] = this.ShowNewProjects;
        data["sfUser"] = this.sfUser;
        data["IsPublic"] = this.IsPublic;
        data["Active"] = this.Active;
        data["SolomonUser"] = this.SolomonUser;
        data["SlidingExpiration"] = this.SlidingExpiration;
        data["PWMustChange"] = this.PWMustChange;
        data["PWAging"] = this.PWAging;
        data["DivisionID"] = this.DivisionID;
        data["LockoutReason"] = this.LockoutReason;
        data["OrgLevel"] = this.OrgLevel;
        data["SynchCheck"] = this.SynchCheck;
        data["FailedLoginRun"] = this.FailedLoginRun;
        data["SuppressNotifyUntil"] = this.SuppressNotifyUntil ? this.SuppressNotifyUntil.toISOString() : <any>undefined;
        data["LastLogin"] = this.LastLogin ? this.LastLogin.toISOString() : <any>undefined;
        data["LastPWChange"] = this.LastPWChange ? this.LastPWChange.toISOString() : <any>undefined;
        data["LockedOutUntil"] = this.LockedOutUntil ? this.LockedOutUntil.toISOString() : <any>undefined;
        data["Expiration"] = this.Expiration ? this.Expiration.toISOString() : <any>undefined;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

/** Describes a contact */
export interface IContact {
    /** Key for this user/contact */
    UserKey: string;
    /** Proper name for display - John Smith; replaces ~U placeholder in Salutation */
    UserName?: string | undefined;
    /** Login name */
    UserLogin?: string | undefined;
    /** Source of external authentication that points to this contact */
    FederatedIdentityInfo?: string | undefined;
    /** Smith for Jon Smith; corresponds to ~S salutation placeholder */
    SortName?: string | undefined;
    /** Jack for Jon Smith; corresponds to ~F salutation placeholder */
    FamiliarName?: string | undefined;
    /** Default is Dear ~U; placeholders: ~ F,S,U,C,T,R */
    Salutation?: string | undefined;
    /** Short description */
    Title?: string | undefined;
    /** Free form; replaces ~R placeholder in Salutation */
    Role?: string | undefined;
    /** Standard SMTP Email Address */
    EMail?: string | undefined;
    /** Phone typically aaa xxx ssss or + with internaltional dialing string */
    phone?: string | undefined;
    /** Predominantly Obsolete */
    fax?: string | undefined;
    /** Mobile phone number */
    cell?: string | undefined;
    /** Gets phone designation  */
    pager?: string | undefined;
    /** free form; when various contacts match exactly, good things happen */
    Company?: string | undefined;
    /** First line of address */
    address?: string | undefined;
    /** Second line of address */
    address2?: string | undefined;
    /** City (for address) */
    city?: string | undefined;
    /** For Address */
    state?: string | undefined;
    /** Zipcode for address */
    zip?: string | undefined;
    /** Uses xsfCodeSet, not used in address */
    Country?: string | undefined;
    /** Applicable County / Organizational Juristiction (not used in address) */
    County?: string | undefined;
    /** EST, PST, etc */
    TimeZone?: string | undefined;
    /** Instant Messaging Service */
    IMService?: string | undefined;
    /** Instant Messaging Handle */
    IMHandle?: string | undefined;
    /** URL */
    WebURL?: string | undefined;
    /** Vendor Company ID */
    VendorID?: string | undefined;
    /** Weak link to Solomon */
    EmployeeID?: string | undefined;
    /** Emp, Vendor, Customer, Standard */
    ContactType?: string | undefined;
    /** Web; E-mail; Fax; Hard Copy */
    RouteVia?: string | undefined;
    /** 1=Phone; 2=Cell; 3-Pager */
    ShowPhone: number;
    /** Key to role that defines who can proxy for this contact */
    RouteeProxy?: string | undefined;
    /** A role with a responsibility */
    DefaultResponsibility: string;
    /** Key to primary company */
    ContactCompanyKey: string;
    /** HTML Markup for signature in templates */
    Signature?: string | undefined;
    /** Key to file in catalog that contains image */
    Likeness?: string | undefined;
    /** When TRUE, trigger updates address if company address changes */
    UseCompanyAddr: boolean;
    /** When true, new projects are added to the dashboard automatically */
    ShowNewProjects: boolean;
    /** When True, can log in to dashboard */
    sfUser: boolean;
    /** When true, this contact is included in lookups  */
    IsPublic: boolean;
    /** When false, this row is ignored and ineffective */
    Active: boolean;
    /** When true, is also an integrated DSL User */
    SolomonUser: boolean;
    /** When TRUE, expiration date is advanced each day the user logs in */
    SlidingExpiration: boolean;
    /** When TRUE, user must change password */
    PWMustChange: boolean;
    /** When TRUE, user can be locked out because of password age */
    PWAging: boolean;
    /** Company Division ID */
    DivisionID?: string | undefined;
    /** Why user has been blocked */
    LockoutReason?: string | undefined;
    /** When a user does a contact lookup, they can only see contacts with an OrgLevel less than 1.112 times their own OrgLevel */
    OrgLevel: number;
    /** Checksum of all externally syched data */
    SynchCheck: number;
    /** Number of consecutive login failures (reset upon success) */
    FailedLoginRun: number;
    /** Email notifications suppressed until this time */
    SuppressNotifyUntil?: Date | undefined;
    /** Set by data layer each time the user logs in */
    LastLogin?: Date | undefined;
    /** Date when password was last changed; can be null */
    LastPWChange?: Date | undefined;
    /** User cannot login until this time */
    LockedOutUntil?: Date | undefined;
    /** Date of Expiration for this account */
    Expiration?: Date | undefined;
    /** When entity was first recorded; read only */
    Created: Date;
}

/** Describes an Alert Condition */
export class UserAlert implements IUserAlert {
    /** Key for Alert */
    AlertKey!: string;
    /** Key for User for whom the alert was generated */
    UserKey!: string;
    /** Document about which the alert was generated */
    DocMasterKey!: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created!: Date;
    /** For Email Notification Type, when was the email sent */
    Notified!: Date;
    /** When was the alert viewed */
    Viewed!: Date;
    /** When action is due */
    Due!: Date;
    /** When closed (from document) */
    Closed!: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** Files attached to document */
    FilesAttached!: number;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert!: boolean;

    constructor(data?: IUserAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.AlertKey = _data["AlertKey"];
            this.UserKey = _data["UserKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.Status = _data["Status"];
            this.NotificationType = _data["NotificationType"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.Notified = _data["Notified"] ? new Date(_data["Notified"].toString()) : <any>undefined;
            this.Viewed = _data["Viewed"] ? new Date(_data["Viewed"].toString()) : <any>undefined;
            this.Due = _data["Due"] ? new Date(_data["Due"].toString()) : <any>undefined;
            this.Closed = _data["Closed"] ? new Date(_data["Closed"].toString()) : <any>undefined;
            this.Description = _data["Description"];
            this.AlertText = _data["AlertText"];
            this.Project = _data["Project"];
            this.Source = _data["Source"];
            this.SourceKey = _data["SourceKey"];
            this.Info1 = _data["Info1"];
            this.Info2 = _data["Info2"];
            this.FilesAttached = _data["FilesAttached"];
            this.MsgType = _data["MsgType"];
            this.MsgKey = _data["MsgKey"];
            this.MsgSuffix = _data["MsgSuffix"];
            this.SIVAlert = _data["SIVAlert"];
        }
    }

    static fromJS(data: any): UserAlert {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AlertKey"] = this.AlertKey;
        data["UserKey"] = this.UserKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["Status"] = this.Status;
        data["NotificationType"] = this.NotificationType;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["Notified"] = this.Notified ? this.Notified.toISOString() : <any>undefined;
        data["Viewed"] = this.Viewed ? this.Viewed.toISOString() : <any>undefined;
        data["Due"] = this.Due ? this.Due.toISOString() : <any>undefined;
        data["Closed"] = this.Closed ? this.Closed.toISOString() : <any>undefined;
        data["Description"] = this.Description;
        data["AlertText"] = this.AlertText;
        data["Project"] = this.Project;
        data["Source"] = this.Source;
        data["SourceKey"] = this.SourceKey;
        data["Info1"] = this.Info1;
        data["Info2"] = this.Info2;
        data["FilesAttached"] = this.FilesAttached;
        data["MsgType"] = this.MsgType;
        data["MsgKey"] = this.MsgKey;
        data["MsgSuffix"] = this.MsgSuffix;
        data["SIVAlert"] = this.SIVAlert;
        return data; 
    }

    clone(): UserAlert {
        const json = this.toJSON();
        let result = new UserAlert();
        result.init(json);
        return result;
    }
}

/** Describes an Alert Condition */
export interface IUserAlert {
    /** Key for Alert */
    AlertKey: string;
    /** Key for User for whom the alert was generated */
    UserKey: string;
    /** Document about which the alert was generated */
    DocMasterKey: string;
    /** Status of Alert (New, etc) */
    Status?: string | undefined;
    /** Notification type (M for email) */
    NotificationType?: string | undefined;
    /** When this alert was created.  Alerts automatically expire in ??? days */
    Created: Date;
    /** For Email Notification Type, when was the email sent */
    Notified: Date;
    /** When was the alert viewed */
    Viewed: Date;
    /** When action is due */
    Due: Date;
    /** When closed (from document) */
    Closed: Date;
    /** Short Description of alert */
    Description?: string | undefined;
    /** Long description (generated using AlertText rules) */
    AlertText?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Source of alert (ATC, CloudStorage, etc) */
    Source?: string | undefined;
    /** Key from source to indentify its alerts */
    SourceKey?: string | undefined;
    /** Extra info for categorization */
    Info1?: string | undefined;
    /** Extra info 2 */
    Info2?: string | undefined;
    /** Files attached to document */
    FilesAttached: number;
    /** unused */
    MsgType?: string | undefined;
    /** unused */
    MsgKey?: string | undefined;
    /** unused */
    MsgSuffix?: string | undefined;
    /** When true, this alert was from an external source (seldom used) */
    SIVAlert: boolean;
}

/** Describes a set of permissions for this user */
export class UCPermitSet implements IUCPermitSet {
    /** Key of this item */
    Project!: string;
    /** Links to Module|Function  */
    Permits!: { [key: string]: UCPermit[]; };

    constructor(data?: IUCPermitSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.Permits = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            if (_data["Permits"]) {
                this.Permits = {} as any;
                for (let key in _data["Permits"]) {
                    if (_data["Permits"].hasOwnProperty(key))
                        this.Permits![key] = _data["Permits"][key] ? _data["Permits"][key].map((i: any) => UCPermit.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): UCPermitSet {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermitSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        if (this.Permits) {
            data["Permits"] = {};
            for (let key in this.Permits) {
                if (this.Permits.hasOwnProperty(key))
                    data["Permits"][key] = this.Permits[key];
            }
        }
        return data; 
    }

    clone(): UCPermitSet {
        const json = this.toJSON();
        let result = new UCPermitSet();
        result.init(json);
        return result;
    }
}

/** Describes a set of permissions for this user */
export interface IUCPermitSet {
    /** Key of this item */
    Project: string;
    /** Links to Module|Function  */
    Permits: { [key: string]: UCPermit[]; };
}

/** Permissions for a specific function */
export class UCPermit implements IUCPermit {
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** When true, has read permission */
    ReadOK!: boolean;
    /** When true, has read permission */
    InsOK!: boolean;
    /** When true, has read permission */
    UpdOK!: boolean;
    /** When true, has read permission */
    DelOK!: boolean;
    /** When true, has read permission */
    BlanketOK!: boolean;
    /** When true, there is no restriction on this permission */
    IsGlobal!: boolean;

    constructor(data?: IUCPermit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocReference = _data["DocReference"];
            this.DocTypeKey = _data["DocTypeKey"];
            this.ReadOK = _data["ReadOK"];
            this.InsOK = _data["InsOK"];
            this.UpdOK = _data["UpdOK"];
            this.DelOK = _data["DelOK"];
            this.BlanketOK = _data["BlanketOK"];
            this.IsGlobal = _data["IsGlobal"];
        }
    }

    static fromJS(data: any): UCPermit {
        data = typeof data === 'object' ? data : {};
        let result = new UCPermit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocReference"] = this.DocReference;
        data["DocTypeKey"] = this.DocTypeKey;
        data["ReadOK"] = this.ReadOK;
        data["InsOK"] = this.InsOK;
        data["UpdOK"] = this.UpdOK;
        data["DelOK"] = this.DelOK;
        data["BlanketOK"] = this.BlanketOK;
        data["IsGlobal"] = this.IsGlobal;
        return data; 
    }

    clone(): UCPermit {
        const json = this.toJSON();
        let result = new UCPermit();
        result.init(json);
        return result;
    }
}

/** Permissions for a specific function */
export interface IUCPermit {
    /** If not empty, for a specific document (rare) */
    DocMasterKey?: string | undefined;
    /** If not empty, for a specific doc reference(rare) */
    DocReference?: string | undefined;
    /** If not empty, for a specific document process type(Common) */
    DocTypeKey?: string | undefined;
    /** When true, has read permission */
    ReadOK: boolean;
    /** When true, has read permission */
    InsOK: boolean;
    /** When true, has read permission */
    UpdOK: boolean;
    /** When true, has read permission */
    DelOK: boolean;
    /** When true, has read permission */
    BlanketOK: boolean;
    /** When true, there is no restriction on this permission */
    IsGlobal: boolean;
}

/** Passes data to a simple API */
export class APIData implements IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded!: boolean;

    constructor(data?: IAPIData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Data = _data["Data"];
            this.IsURIEncoded = _data["IsURIEncoded"];
        }
    }

    static fromJS(data: any): APIData {
        data = typeof data === 'object' ? data : {};
        let result = new APIData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.Data;
        data["IsURIEncoded"] = this.IsURIEncoded;
        return data; 
    }

    clone(): APIData {
        const json = this.toJSON();
        let result = new APIData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IAPIData {
    /** Raw Data */
    Data?: string | undefined;
    /** when true, data has been uri encoded (encodeURIComponent) */
    IsURIEncoded: boolean;
}

/** Passes data to a simple API */
export class PDSData extends APIData implements IPDSData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly!: boolean;

    constructor(data?: IPDSData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.PDSKey = _data["PDSKey"];
            this.Mode = _data["Mode"];
            this.Path = _data["Path"];
            this.Type = _data["Type"];
            this.UpdateReadOnly = _data["UpdateReadOnly"];
        }
    }

    static fromJS(data: any): PDSData {
        data = typeof data === 'object' ? data : {};
        let result = new PDSData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PDSKey"] = this.PDSKey;
        data["Mode"] = this.Mode;
        data["Path"] = this.Path;
        data["Type"] = this.Type;
        data["UpdateReadOnly"] = this.UpdateReadOnly;
        super.toJSON(data);
        return data; 
    }

    clone(): PDSData {
        const json = this.toJSON();
        let result = new PDSData();
        result.init(json);
        return result;
    }
}

/** Passes data to a simple API */
export interface IPDSData extends IAPIData {
    /** ID of data set */
    PDSKey?: string | undefined;
    /** Type of change (put, set) */
    Mode?: string | undefined;
    /** key or AK source (eg: AK/tdkeymapkey/TK/@xtsKeyMap.BlockOut/9c337885-0fb1-460c-960a-3bacc1d8e0)
             */
    Path?: string | undefined;
    /** Type of data (boolean,string) */
    Type?: string | undefined;
    /** When TRUE target field can be read only and will be updated in memory */
    UpdateReadOnly: boolean;
}

/** Abstracted information about a project */
export class ProjectAbstract implements IProjectAbstract {
    /** Project ID */
    Project!: string;
    /** Key for Project */
    ProjectKey!: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey!: string;
    /** Key for Site Address */
    SiteAddrKey!: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold!: number;
    /** Geo latitude (project setup) */
    latitude!: number;
    /** Geo longitude (project setup) */
    longitude!: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey!: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active!: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate!: Date;
    /** From Dates on project setup */
    ProjectFinishDate!: Date;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks!: boolean;
    /** When true, disable Note */
    ExcludeNoteUI!: boolean;
    /** When true, disable Links */
    ExcludeLinkUI!: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI!: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI!: boolean;
    /** Indicates when this abstract was generated */
    dataResolved!: Date;

    constructor(data?: IProjectAbstract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.Project = _data["Project"];
            this.ProjectKey = _data["ProjectKey"];
            this.ProjectType = _data["ProjectType"];
            this.SetupDocKey = _data["SetupDocKey"];
            this.SiteAddrKey = _data["SiteAddrKey"];
            this.Person = _data["Person"];
            this.Company = _data["Company"];
            this.Addr1 = _data["Addr1"];
            this.Addr2 = _data["Addr2"];
            this.City = _data["City"];
            this.State = _data["State"];
            this.Zip = _data["Zip"];
            this.County = _data["County"];
            this.Phone = _data["Phone"];
            this.Fax = _data["Fax"];
            this.ExternalStatus = _data["ExternalStatus"];
            this.ExternalSchedule = _data["ExternalSchedule"];
            this.SCBudgetMode = _data["SCBudgetMode"];
            this.PlanRoomMode = _data["PlanRoomMode"];
            this.WebCamURL = _data["WebCamURL"];
            this.Description = _data["Description"];
            this.ForecastThreshold = _data["ForecastThreshold"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.cldStoreKey = _data["cldStoreKey"];
            this.CloudDrivePath = _data["CloudDrivePath"];
            this.GLSUB = _data["GLSUB"];
            this.Active = _data["Active"];
            this.Status = _data["Status"];
            this.StatusText = _data["StatusText"];
            this.Subtype = _data["Subtype"];
            this.DocState = _data["DocState"];
            this.ProjectDocReference = _data["ProjectDocReference"];
            this.ProjectUniReference = _data["ProjectUniReference"];
            this.ProjectCustomerID = _data["ProjectCustomerID"];
            this.ProjectCustomerName = _data["ProjectCustomerName"];
            this.ProjectTitle = _data["ProjectTitle"];
            this.ProjectIDMasked = _data["ProjectIDMasked"];
            this.ProjectTabName = _data["ProjectTabName"];
            this.ProjectTabTip = _data["ProjectTabTip"];
            this.ProjectBar = _data["ProjectBar"];
            this.ProjectStartDate = _data["ProjectStartDate"] ? new Date(_data["ProjectStartDate"].toString()) : <any>undefined;
            this.ProjectFinishDate = _data["ProjectFinishDate"] ? new Date(_data["ProjectFinishDate"].toString()) : <any>undefined;
            this.ProjectStartFormat = _data["ProjectStartFormat"];
            this.ProjectFinishFormat = _data["ProjectFinishFormat"];
            this.ProjectPhoto = _data["ProjectPhoto"];
            this.ProjectCurrentNote = _data["ProjectCurrentNote"];
            if (Array.isArray(_data["actionsMenu"])) {
                this.actionsMenu = [] as any;
                for (let item of _data["actionsMenu"])
                    this.actionsMenu!.push(MenuAction.fromJS(item));
            }
            if (Array.isArray(_data["registerMenu"])) {
                this.registerMenu = [] as any;
                for (let item of _data["registerMenu"])
                    this.registerMenu!.push(MenuAction.fromJS(item));
            }
            this.AlwaysShowLinks = _data["AlwaysShowLinks"];
            this.ExcludeNoteUI = _data["ExcludeNoteUI"];
            this.ExcludeLinkUI = _data["ExcludeLinkUI"];
            this.ExcludeCostAnalysisUI = _data["ExcludeCostAnalysisUI"];
            this.ExcludeKPIUI = _data["ExcludeKPIUI"];
            this.dataResolved = _data["dataResolved"] ? new Date(_data["dataResolved"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectAbstract {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAbstract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Project"] = this.Project;
        data["ProjectKey"] = this.ProjectKey;
        data["ProjectType"] = this.ProjectType;
        data["SetupDocKey"] = this.SetupDocKey;
        data["SiteAddrKey"] = this.SiteAddrKey;
        data["Person"] = this.Person;
        data["Company"] = this.Company;
        data["Addr1"] = this.Addr1;
        data["Addr2"] = this.Addr2;
        data["City"] = this.City;
        data["State"] = this.State;
        data["Zip"] = this.Zip;
        data["County"] = this.County;
        data["Phone"] = this.Phone;
        data["Fax"] = this.Fax;
        data["ExternalStatus"] = this.ExternalStatus;
        data["ExternalSchedule"] = this.ExternalSchedule;
        data["SCBudgetMode"] = this.SCBudgetMode;
        data["PlanRoomMode"] = this.PlanRoomMode;
        data["WebCamURL"] = this.WebCamURL;
        data["Description"] = this.Description;
        data["ForecastThreshold"] = this.ForecastThreshold;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["cldStoreKey"] = this.cldStoreKey;
        data["CloudDrivePath"] = this.CloudDrivePath;
        data["GLSUB"] = this.GLSUB;
        data["Active"] = this.Active;
        data["Status"] = this.Status;
        data["StatusText"] = this.StatusText;
        data["Subtype"] = this.Subtype;
        data["DocState"] = this.DocState;
        data["ProjectDocReference"] = this.ProjectDocReference;
        data["ProjectUniReference"] = this.ProjectUniReference;
        data["ProjectCustomerID"] = this.ProjectCustomerID;
        data["ProjectCustomerName"] = this.ProjectCustomerName;
        data["ProjectTitle"] = this.ProjectTitle;
        data["ProjectIDMasked"] = this.ProjectIDMasked;
        data["ProjectTabName"] = this.ProjectTabName;
        data["ProjectTabTip"] = this.ProjectTabTip;
        data["ProjectBar"] = this.ProjectBar;
        data["ProjectStartDate"] = this.ProjectStartDate ? this.ProjectStartDate.toISOString() : <any>undefined;
        data["ProjectFinishDate"] = this.ProjectFinishDate ? this.ProjectFinishDate.toISOString() : <any>undefined;
        data["ProjectStartFormat"] = this.ProjectStartFormat;
        data["ProjectFinishFormat"] = this.ProjectFinishFormat;
        data["ProjectPhoto"] = this.ProjectPhoto;
        data["ProjectCurrentNote"] = this.ProjectCurrentNote;
        if (Array.isArray(this.actionsMenu)) {
            data["actionsMenu"] = [];
            for (let item of this.actionsMenu)
                data["actionsMenu"].push(item.toJSON());
        }
        if (Array.isArray(this.registerMenu)) {
            data["registerMenu"] = [];
            for (let item of this.registerMenu)
                data["registerMenu"].push(item.toJSON());
        }
        data["AlwaysShowLinks"] = this.AlwaysShowLinks;
        data["ExcludeNoteUI"] = this.ExcludeNoteUI;
        data["ExcludeLinkUI"] = this.ExcludeLinkUI;
        data["ExcludeCostAnalysisUI"] = this.ExcludeCostAnalysisUI;
        data["ExcludeKPIUI"] = this.ExcludeKPIUI;
        data["dataResolved"] = this.dataResolved ? this.dataResolved.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProjectAbstract {
        const json = this.toJSON();
        let result = new ProjectAbstract();
        result.init(json);
        return result;
    }
}

/** Abstracted information about a project */
export interface IProjectAbstract {
    /** Project ID */
    Project: string;
    /** Key for Project */
    ProjectKey: string;
    /** From Project Setup (Subtype_ */
    ProjectType?: string | undefined;
    /** Key for Project Setup */
    SetupDocKey: string;
    /** Key for Site Address */
    SiteAddrKey: string;
    /** Person */
    Person?: string | undefined;
    /** Company from Address tab */
    Company?: string | undefined;
    /** Address line 1 */
    Addr1?: string | undefined;
    /** Address Line 2 */
    Addr2?: string | undefined;
    /** City */
    City?: string | undefined;
    /** State */
    State?: string | undefined;
    /** Zip */
    Zip?: string | undefined;
    /** County */
    County?: string | undefined;
    /** Phone */
    Phone?: string | undefined;
    /** Fax (obsolete) */
    Fax?: string | undefined;
    /** External Status (from project setup) */
    ExternalStatus?: string | undefined;
    /** External Schedule (from project setup) */
    ExternalSchedule?: string | undefined;
    /** Subcontract Budget Mode flag (Seldom Used ) */
    SCBudgetMode?: string | undefined;
    /** Plan Room Mode (public or privae or none) */
    PlanRoomMode?: string | undefined;
    /** URI for site camera */
    WebCamURL?: string | undefined;
    /** Description */
    Description?: string | undefined;
    /** Forecasting Threshold (project setup) */
    ForecastThreshold: number;
    /** Geo latitude (project setup) */
    latitude: number;
    /** Geo longitude (project setup) */
    longitude: number;
    /** Cloud Storage Provider (project setup) */
    cldStoreKey: string;
    /** Cloud Path (CloudStorageConfig rule0 */
    CloudDrivePath?: string | undefined;
    /** GLSUB for project */
    GLSUB?: string | undefined;
    /** When true, project is active */
    Active: boolean;
    /** Status code  (project setup) */
    Status?: string | undefined;
    /** Resolved Status (project setup) */
    StatusText?: string | undefined;
    /** Subtype  */
    Subtype?: string | undefined;
    /** State of project setup */
    DocState?: string | undefined;
    /** Key From Project Setup Reference  */
    ProjectDocReference?: string | undefined;
    /** From UniReferenceKey */
    ProjectUniReference?: string | undefined;
    /** Customer ID From Project Setup Source Contact */
    ProjectCustomerID?: string | undefined;
    /** Resolve name of customer From Project Setup Source Contact */
    ProjectCustomerName?: string | undefined;
    /** From Project Setup */
    ProjectTitle?: string | undefined;
    /** From Project Setup */
    ProjectIDMasked?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectTabName?: string | undefined;
    /** from ProjectConfig TabTip rule */
    ProjectTabTip?: string | undefined;
    /** from ProjectConfig TabText rule */
    ProjectBar?: string | undefined;
    /** From Dates on project setup */
    ProjectStartDate: Date;
    /** From Dates on project setup */
    ProjectFinishDate: Date;
    /** how to display project start date */
    ProjectStartFormat?: string | undefined;
    /** how to display project finish date */
    ProjectFinishFormat?: string | undefined;
    /** URI to current project photo */
    ProjectPhoto?: string | undefined;
    /** Current Note on Project */
    ProjectCurrentNote?: string | undefined;
    /** list of actions */
    actionsMenu?: MenuAction[] | undefined;
    /** list of registers (includes link to project setup) */
    registerMenu?: MenuAction[] | undefined;
    /** When true, Always Show Links */
    AlwaysShowLinks: boolean;
    /** When true, disable Note */
    ExcludeNoteUI: boolean;
    /** When true, disable Links */
    ExcludeLinkUI: boolean;
    /** When true, disable Cost Analysis */
    ExcludeCostAnalysisUI: boolean;
    /** When true, disable KPI */
    ExcludeKPIUI: boolean;
    /** Indicates when this abstract was generated */
    dataResolved: Date;
}

/** Attributes describing a Link to a parent or child  project */
export class ProjectLink implements IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey!: string;
    /** Key for document that owns the link */
    DocMasterKey?: string | undefined;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart!: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish!: Date;
    /** EAC Contract Value  */
    CurrentContract!: number;
    /** When True, this is a child project */
    IsChild!: boolean;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocAttachKey = _data["DocAttachKey"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.LinkedProjectContractKey = _data["LinkedProjectContractKey"];
            this.Project = _data["Project"];
            this.Title = _data["Title"];
            this.Location = _data["Location"];
            this.ExternalDocNo = _data["ExternalDocNo"];
            this.StatusDescription = _data["StatusDescription"];
            this.ProjectStart = _data["ProjectStart"] ? new Date(_data["ProjectStart"].toString()) : <any>undefined;
            this.ProjectFinish = _data["ProjectFinish"] ? new Date(_data["ProjectFinish"].toString()) : <any>undefined;
            this.CurrentContract = _data["CurrentContract"];
            this.IsChild = _data["IsChild"];
        }
    }

    static fromJS(data: any): ProjectLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocAttachKey"] = this.DocAttachKey;
        data["DocMasterKey"] = this.DocMasterKey;
        data["LinkedProjectContractKey"] = this.LinkedProjectContractKey;
        data["Project"] = this.Project;
        data["Title"] = this.Title;
        data["Location"] = this.Location;
        data["ExternalDocNo"] = this.ExternalDocNo;
        data["StatusDescription"] = this.StatusDescription;
        data["ProjectStart"] = this.ProjectStart ? this.ProjectStart.toISOString() : <any>undefined;
        data["ProjectFinish"] = this.ProjectFinish ? this.ProjectFinish.toISOString() : <any>undefined;
        data["CurrentContract"] = this.CurrentContract;
        data["IsChild"] = this.IsChild;
        return data; 
    }

    clone(): ProjectLink {
        const json = this.toJSON();
        let result = new ProjectLink();
        result.init(json);
        return result;
    }
}

/** Attributes describing a Link to a parent or child  project */
export interface IProjectLink {
    /** Key for Attachment between projects */
    DocAttachKey: string;
    /** Key for document that owns the link */
    DocMasterKey?: string | undefined;
    /** Key for Project Setup  */
    LinkedProjectContractKey?: string | undefined;
    /** Project ID */
    Project?: string | undefined;
    /** Title of Project */
    Title?: string | undefined;
    /** Location of Project */
    Location?: string | undefined;
    /** External Doc Number */
    ExternalDocNo?: string | undefined;
    /** Resolved Status  */
    StatusDescription?: string | undefined;
    /** Project Start Date (from Dates tab) */
    ProjectStart: Date;
    /** Project Finish Date (from Dates tab) */
    ProjectFinish: Date;
    /** EAC Contract Value  */
    CurrentContract: number;
    /** When True, this is a child project */
    IsChild: boolean;
}

/** Primary Site Weather Now */
export class ProjectWeatherNow implements IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer!: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint!: number;
    /** Feels Like */
    FeelsLike!: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity!: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained!: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature!: number;
    /** Visibility (miles) */
    Visibility!: number;
    /** Wind (MPH) */
    Wind!: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    ZipCode?: string | undefined;

    constructor(data?: IProjectWeatherNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.At = _data["At"];
            this.Barometer = _data["Barometer"];
            this.Condition = _data["Condition"];
            this.DewPoint = _data["DewPoint"];
            this.FeelsLike = _data["FeelsLike"];
            this.Forecast = _data["Forecast"];
            this.Humidity = _data["Humidity"];
            this.Icon = _data["Icon"];
            this.Obtained = _data["Obtained"] ? new Date(_data["Obtained"].toString()) : <any>undefined;
            this.Provider = _data["Provider"];
            this.Reported = _data["Reported"];
            this.Temperature = _data["Temperature"];
            this.Visibility = _data["Visibility"];
            this.Wind = _data["Wind"];
            this.WindInfo = _data["WindInfo"];
            this.ZipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): ProjectWeatherNow {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWeatherNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["At"] = this.At;
        data["Barometer"] = this.Barometer;
        data["Condition"] = this.Condition;
        data["DewPoint"] = this.DewPoint;
        data["FeelsLike"] = this.FeelsLike;
        data["Forecast"] = this.Forecast;
        data["Humidity"] = this.Humidity;
        data["Icon"] = this.Icon;
        data["Obtained"] = this.Obtained ? this.Obtained.toISOString() : <any>undefined;
        data["Provider"] = this.Provider;
        data["Reported"] = this.Reported;
        data["Temperature"] = this.Temperature;
        data["Visibility"] = this.Visibility;
        data["Wind"] = this.Wind;
        data["WindInfo"] = this.WindInfo;
        data["ZipCode"] = this.ZipCode;
        return data; 
    }

    clone(): ProjectWeatherNow {
        const json = this.toJSON();
        let result = new ProjectWeatherNow();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IProjectWeatherNow {
    /** Description of location */
    At?: string | undefined;
    /** Barometer */
    Barometer: number;
    /** Descriptio of condition (cloudy) */
    Condition?: string | undefined;
    /** Dew Point  */
    DewPoint: number;
    /** Feels Like */
    FeelsLike: number;
    /** URI to full forecast */
    Forecast?: string | undefined;
    /** Current Humidity */
    Humidity: number;
    /** URI to icon  */
    Icon?: string | undefined;
    /** When this reading was taken */
    Obtained: Date;
    /** Source of weather data (usually noaa) */
    Provider?: string | undefined;
    /** When reading was acquired */
    Reported?: string | undefined;
    /** Temperature (F) */
    Temperature: number;
    /** Visibility (miles) */
    Visibility: number;
    /** Wind (MPH) */
    Wind: number;
    /** Description of Wind/direction */
    WindInfo?: string | undefined;
    /** Zipcode for which this reading was obtained */
    ZipCode?: string | undefined;
}

/** Primary Site Weather Now */
export class WeatherAtLocation implements IWeatherAtLocation {
    /** Location (typically zipcode) */
    LocationCode!: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey!: string;
    /** Key of this location */
    WeatherLocationKey!: string;
    /** When this reading was acquired */
    Reported!: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility!: number;
    /** Temperature (F) */
    Temperature!: number;
    /** Feels like (F) */
    FeelsLike!: number;
    /** Dewpoint (F) */
    Dewpoint!: number;
    /** Relative Humidity */
    HumidityPct!: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind!: number;
    /** Barametric Pressure */
    Barometer!: number;

    constructor(data?: IWeatherAtLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.LocationCode = _data["LocationCode"];
            this.Location = _data["Location"];
            this.RecordedAt = _data["RecordedAt"];
            this.Provider = _data["Provider"];
            this.WeatherInfoKey = _data["WeatherInfoKey"];
            this.WeatherLocationKey = _data["WeatherLocationKey"];
            this.Reported = _data["Reported"] ? new Date(_data["Reported"].toString()) : <any>undefined;
            this.Conditions = _data["Conditions"];
            this.Visibility = _data["Visibility"];
            this.Temperature = _data["Temperature"];
            this.FeelsLike = _data["FeelsLike"];
            this.Dewpoint = _data["Dewpoint"];
            this.HumidityPct = _data["HumidityPct"];
            this.WindDirection = _data["WindDirection"];
            this.Wind = _data["Wind"];
            this.Barometer = _data["Barometer"];
        }
    }

    static fromJS(data: any): WeatherAtLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAtLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocationCode"] = this.LocationCode;
        data["Location"] = this.Location;
        data["RecordedAt"] = this.RecordedAt;
        data["Provider"] = this.Provider;
        data["WeatherInfoKey"] = this.WeatherInfoKey;
        data["WeatherLocationKey"] = this.WeatherLocationKey;
        data["Reported"] = this.Reported ? this.Reported.toISOString() : <any>undefined;
        data["Conditions"] = this.Conditions;
        data["Visibility"] = this.Visibility;
        data["Temperature"] = this.Temperature;
        data["FeelsLike"] = this.FeelsLike;
        data["Dewpoint"] = this.Dewpoint;
        data["HumidityPct"] = this.HumidityPct;
        data["WindDirection"] = this.WindDirection;
        data["Wind"] = this.Wind;
        data["Barometer"] = this.Barometer;
        return data; 
    }

    clone(): WeatherAtLocation {
        const json = this.toJSON();
        let result = new WeatherAtLocation();
        result.init(json);
        return result;
    }
}

/** Primary Site Weather Now */
export interface IWeatherAtLocation {
    /** Location (typically zipcode) */
    LocationCode: number;
    /** Description of Location (JFK Airport, New York, NY) */
    Location?: string | undefined;
    RecordedAt?: string | undefined;
    /** Source of data (usually noaa weather.gov) */
    Provider?: string | undefined;
    /** Key of this record */
    WeatherInfoKey: string;
    /** Key of this location */
    WeatherLocationKey: string;
    /** When this reading was acquired */
    Reported: Date;
    /** Weather condition summary (windy) */
    Conditions?: string | undefined;
    /** Visibility (in miles) */
    Visibility: number;
    /** Temperature (F) */
    Temperature: number;
    /** Feels like (F) */
    FeelsLike: number;
    /** Dewpoint (F) */
    Dewpoint: number;
    /** Relative Humidity */
    HumidityPct: number;
    /** Description of wind direction */
    WindDirection?: string | undefined;
    /** Wind Speed (MPH) */
    Wind: number;
    /** Barametric Pressure */
    Barometer: number;
}

/** Comment about a topic */
export class Comment implements IComment {
    /** Key for this comment */
    DocCommentKey!: string;
    /** Key for the topic relating a group of comments */
    TopicKey!: string;
    /** Key for the author of this comment */
    FromUser!: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost!: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage!: number;
    /** When this comment was created (editable given sufficient permission) */
    Created!: Date;
    /** custom amount */
    csAmount!: number;
    /** custom amount */
    csValue!: number;
    /** custom quantity */
    csQty!: number;
    /** custom whole number */
    csNumber!: number;
    /** custom boolean */
    csCheck!: boolean;
    /** custom boolean */
    csFlag!: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.DocCommentKey = _data["DocCommentKey"];
            this.TopicKey = _data["TopicKey"];
            this.FromUser = _data["FromUser"];
            this.Note = _data["Note"];
            this.Cost = _data["Cost"];
            this.Stage = _data["Stage"];
            this.Created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.csAmount = _data["csAmount"];
            this.csValue = _data["csValue"];
            this.csQty = _data["csQty"];
            this.csNumber = _data["csNumber"];
            this.csCheck = _data["csCheck"];
            this.csFlag = _data["csFlag"];
            this.csNote = _data["csNote"];
            this.csCode = _data["csCode"];
            this.csString016 = _data["csString016"];
            this.csString030 = _data["csString030"];
            this.csString040 = _data["csString040"];
            this.csString050 = _data["csString050"];
            this.csString060 = _data["csString060"];
            this.csString080 = _data["csString080"];
            this.csString100 = _data["csString100"];
            this.csString120 = _data["csString120"];
            this.csString240 = _data["csString240"];
            this.csContactKey = _data["csContactKey"];
            this.csKey = _data["csKey"];
            this.csDate = _data["csDate"] ? new Date(_data["csDate"].toString()) : <any>undefined;
            this.csWhen = _data["csWhen"] ? new Date(_data["csWhen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocCommentKey"] = this.DocCommentKey;
        data["TopicKey"] = this.TopicKey;
        data["FromUser"] = this.FromUser;
        data["Note"] = this.Note;
        data["Cost"] = this.Cost;
        data["Stage"] = this.Stage;
        data["Created"] = this.Created ? this.Created.toISOString() : <any>undefined;
        data["csAmount"] = this.csAmount;
        data["csValue"] = this.csValue;
        data["csQty"] = this.csQty;
        data["csNumber"] = this.csNumber;
        data["csCheck"] = this.csCheck;
        data["csFlag"] = this.csFlag;
        data["csNote"] = this.csNote;
        data["csCode"] = this.csCode;
        data["csString016"] = this.csString016;
        data["csString030"] = this.csString030;
        data["csString040"] = this.csString040;
        data["csString050"] = this.csString050;
        data["csString060"] = this.csString060;
        data["csString080"] = this.csString080;
        data["csString100"] = this.csString100;
        data["csString120"] = this.csString120;
        data["csString240"] = this.csString240;
        data["csContactKey"] = this.csContactKey;
        data["csKey"] = this.csKey;
        data["csDate"] = this.csDate ? this.csDate.toISOString() : <any>undefined;
        data["csWhen"] = this.csWhen ? this.csWhen.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Comment {
        const json = this.toJSON();
        let result = new Comment();
        result.init(json);
        return result;
    }
}

/** Comment about a topic */
export interface IComment {
    /** Key for this comment */
    DocCommentKey: string;
    /** Key for the topic relating a group of comments */
    TopicKey: string;
    /** Key for the author of this comment */
    FromUser: string;
    /** Primary text of this comment */
    Note?: string | undefined;
    /** Primary amount */
    Cost: number;
    /** Stage (as in document re-route stage; no known use cases) */
    Stage: number;
    /** When this comment was created (editable given sufficient permission) */
    Created: Date;
    /** custom amount */
    csAmount: number;
    /** custom amount */
    csValue: number;
    /** custom quantity */
    csQty: number;
    /** custom whole number */
    csNumber: number;
    /** custom boolean */
    csCheck: boolean;
    /** custom boolean */
    csFlag: boolean;
    /** custom note */
    csNote?: string | undefined;
    /** custom code (potential code list lookup) */
    csCode?: string | undefined;
    /** custom string */
    csString016?: string | undefined;
    /** custom string */
    csString030?: string | undefined;
    /** custom string */
    csString040?: string | undefined;
    /** custom string */
    csString050?: string | undefined;
    /** custom string */
    csString060?: string | undefined;
    /** custom string */
    csString080?: string | undefined;
    /** custom string */
    csString100?: string | undefined;
    /** custom string */
    csString120?: string | undefined;
    /** custom string */
    csString240?: string | undefined;
    /** custom key - usually for a person */
    csContactKey?: string | undefined;
    /** custom key */
    csKey?: string | undefined;
    /** custom date */
    csDate?: Date | undefined;
    /** custom date */
    csWhen?: Date | undefined;
}

/** Readonly description of an cost transaction posted to a project */
export class ProjectTranDetail implements IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey!: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount!: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime!: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num!: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime!: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date!: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date!: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units!: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line!: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS!: boolean;
    /** Identifies a Document */
    DocMasterKey!: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;

    constructor(data?: IProjectTranDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.RowKey = _data["RowKey"];
            this.acct = _data["acct"];
            this.alloc_flag = _data["alloc_flag"];
            this.amount = _data["amount"];
            this.BaseCuryId = _data["BaseCuryId"];
            this.batch_id = _data["batch_id"];
            this.batch_type = _data["batch_type"];
            this.bill_batch_id = _data["bill_batch_id"];
            this.CpnyId = _data["CpnyId"];
            this.crtd_datetime = _data["crtd_datetime"] ? new Date(_data["crtd_datetime"].toString()) : <any>undefined;
            this.crtd_prog = _data["crtd_prog"];
            this.crtd_user = _data["crtd_user"];
            this.data1 = _data["data1"];
            this.detail_num = _data["detail_num"];
            this.employee = _data["employee"];
            this.fiscalno = _data["fiscalno"];
            this.gl_acct = _data["gl_acct"];
            this.gl_subacct = _data["gl_subacct"];
            this.lupd_datetime = _data["lupd_datetime"] ? new Date(_data["lupd_datetime"].toString()) : <any>undefined;
            this.lupd_prog = _data["lupd_prog"];
            this.lupd_user = _data["lupd_user"];
            this.pjt_entity = _data["pjt_entity"];
            this.post_date = _data["post_date"] ? new Date(_data["post_date"].toString()) : <any>undefined;
            this.project = _data["project"];
            this.Subcontract = _data["Subcontract"];
            this.system_cd = _data["system_cd"];
            this.trans_date = _data["trans_date"] ? new Date(_data["trans_date"].toString()) : <any>undefined;
            this.tr_comment = _data["tr_comment"];
            this.tr_id01 = _data["tr_id01"];
            this.InvoiceNumber = _data["InvoiceNumber"];
            this.PONumber = _data["PONumber"];
            this.SourceBatchNumber = _data["SourceBatchNumber"];
            this.LaborClass = _data["LaborClass"];
            this.tr_status = _data["tr_status"];
            this.unit_of_measure = _data["unit_of_measure"];
            this.units = _data["units"];
            this.vendor_num = _data["vendor_num"];
            this.voucher_line = _data["voucher_line"];
            this.voucher_num = _data["voucher_num"];
            this.emp_name = _data["emp_name"];
            this.name = _data["name"];
            this.equip_id = _data["equip_id"];
            this.invtid = _data["invtid"];
            this.lotsernbr = _data["lotsernbr"];
            this.siteid = _data["siteid"];
            this.whseloc = _data["whseloc"];
            this.Descr = _data["Descr"];
            this.IsXTS = _data["IsXTS"];
            this.DocMasterKey = _data["DocMasterKey"];
            this.DocTitle = _data["DocTitle"];
            this.Acct_Type = _data["Acct_Type"];
            this.Acct_TranClass = _data["Acct_TranClass"];
            this.Acct_Class = _data["Acct_Class"];
        }
    }

    static fromJS(data: any): ProjectTranDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTranDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowKey"] = this.RowKey;
        data["acct"] = this.acct;
        data["alloc_flag"] = this.alloc_flag;
        data["amount"] = this.amount;
        data["BaseCuryId"] = this.BaseCuryId;
        data["batch_id"] = this.batch_id;
        data["batch_type"] = this.batch_type;
        data["bill_batch_id"] = this.bill_batch_id;
        data["CpnyId"] = this.CpnyId;
        data["crtd_datetime"] = this.crtd_datetime ? this.crtd_datetime.toISOString() : <any>undefined;
        data["crtd_prog"] = this.crtd_prog;
        data["crtd_user"] = this.crtd_user;
        data["data1"] = this.data1;
        data["detail_num"] = this.detail_num;
        data["employee"] = this.employee;
        data["fiscalno"] = this.fiscalno;
        data["gl_acct"] = this.gl_acct;
        data["gl_subacct"] = this.gl_subacct;
        data["lupd_datetime"] = this.lupd_datetime ? this.lupd_datetime.toISOString() : <any>undefined;
        data["lupd_prog"] = this.lupd_prog;
        data["lupd_user"] = this.lupd_user;
        data["pjt_entity"] = this.pjt_entity;
        data["post_date"] = this.post_date ? this.post_date.toISOString() : <any>undefined;
        data["project"] = this.project;
        data["Subcontract"] = this.Subcontract;
        data["system_cd"] = this.system_cd;
        data["trans_date"] = this.trans_date ? this.trans_date.toISOString() : <any>undefined;
        data["tr_comment"] = this.tr_comment;
        data["tr_id01"] = this.tr_id01;
        data["InvoiceNumber"] = this.InvoiceNumber;
        data["PONumber"] = this.PONumber;
        data["SourceBatchNumber"] = this.SourceBatchNumber;
        data["LaborClass"] = this.LaborClass;
        data["tr_status"] = this.tr_status;
        data["unit_of_measure"] = this.unit_of_measure;
        data["units"] = this.units;
        data["vendor_num"] = this.vendor_num;
        data["voucher_line"] = this.voucher_line;
        data["voucher_num"] = this.voucher_num;
        data["emp_name"] = this.emp_name;
        data["name"] = this.name;
        data["equip_id"] = this.equip_id;
        data["invtid"] = this.invtid;
        data["lotsernbr"] = this.lotsernbr;
        data["siteid"] = this.siteid;
        data["whseloc"] = this.whseloc;
        data["Descr"] = this.Descr;
        data["IsXTS"] = this.IsXTS;
        data["DocMasterKey"] = this.DocMasterKey;
        data["DocTitle"] = this.DocTitle;
        data["Acct_Type"] = this.Acct_Type;
        data["Acct_TranClass"] = this.Acct_TranClass;
        data["Acct_Class"] = this.Acct_Class;
        return data; 
    }

    clone(): ProjectTranDetail {
        const json = this.toJSON();
        let result = new ProjectTranDetail();
        result.init(json);
        return result;
    }
}

/** Readonly description of an cost transaction posted to a project */
export interface IProjectTranDetail {
    /** Key for this transaction (does not persist) */
    RowKey: string;
    /** Account Category */
    acct?: string | undefined;
    /** Rarely used allocation flag */
    alloc_flag?: string | undefined;
    /** Amount  */
    amount: number;
    /** Typically US */
    BaseCuryId?: string | undefined;
    /** Batch ID */
    batch_id?: string | undefined;
    /** Batch Type  */
    batch_type?: string | undefined;
    /** Billing Batch ID  */
    bill_batch_id?: string | undefined;
    /** Company Division ID  */
    CpnyId?: string | undefined;
    /** When this transaction was written */
    crtd_datetime: Date;
    /** Id of Source logic that recorded this transaction */
    crtd_prog?: string | undefined;
    /** User ID under which this transaction was recorded  */
    crtd_user?: string | undefined;
    /** No known use */
    data1?: string | undefined;
    /** No known use */
    detail_num: number;
    /** Employee ID */
    employee?: string | undefined;
    /** Fiscal Period (YYYYMM) */
    fiscalno?: string | undefined;
    /** GL Account number */
    gl_acct?: string | undefined;
    /** GL Subaccount number */
    gl_subacct?: string | undefined;
    /** Last Update of this transaction (typically matches CRTD_) */
    lupd_datetime: Date;
    /** Source logic of this transaction (typically matches CRTD_) */
    lupd_prog?: string | undefined;
    /** Source user generating this transaction (typically matches CRTD_) */
    lupd_user?: string | undefined;
    /** Project Cost Code */
    pjt_entity?: string | undefined;
    /** posting Date of this transaction */
    post_date: Date;
    /** ID of Project (suitable for use as a key) */
    project?: string | undefined;
    /** Reference to related subcontract  */
    Subcontract?: string | undefined;
    /** System Code */
    system_cd?: string | undefined;
    /** Transaction Date */
    trans_date: Date;
    /** Transaction Comment */
    tr_comment?: string | undefined;
    /** No known use */
    tr_id01?: string | undefined;
    /** Invoice Number */
    InvoiceNumber?: string | undefined;
    /** PO Number */
    PONumber?: string | undefined;
    /** Source Batch Number */
    SourceBatchNumber?: string | undefined;
    /** Labor Class */
    LaborClass?: string | undefined;
    /** Transaction Status */
    tr_status?: string | undefined;
    /** UOM (code) */
    unit_of_measure?: string | undefined;
    /** Units */
    units: number;
    /** Vendor Number */
    vendor_num?: string | undefined;
    /** Voucher Line */
    voucher_line: number;
    /** Voucher Number */
    voucher_num?: string | undefined;
    /** Employee Name (blank if user lacks permission) */
    emp_name?: string | undefined;
    /** Vendor Name   */
    name?: string | undefined;
    /** Equipment ID */
    equip_id?: string | undefined;
    /** Inventory ID  */
    invtid?: string | undefined;
    /** Lot Serial Number */
    lotsernbr?: string | undefined;
    /** Site ID (inventory location) */
    siteid?: string | undefined;
    /** Wharehouse Location */
    whseloc?: string | undefined;
    /** Inventory Description */
    Descr?: string | undefined;
    /** Is XTS transaction  */
    IsXTS: boolean;
    /** Identifies a Document */
    DocMasterKey: string;
    /** Document Title */
    DocTitle?: string | undefined;
    /** Account Type (EX or RV) */
    Acct_Type?: string | undefined;
    /** No known use */
    Acct_TranClass?: string | undefined;
    /** Account Class (L, B, E, etc) */
    Acct_Class?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
